<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e0c6cd93db10995b051b068ce1439987f93a2699" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39902756" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示应用程序域，它是一个应用程序在其中执行的独立环境。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序域，由表示<xref:System.AppDomain>对象，可帮助为执行托管的代码提供隔离、 卸载和安全边界。  
  
-   使用应用程序域隔离可能会终止进程的任务。 如果状态<xref:System.AppDomain>的正在执行的任务变得不稳定，<xref:System.AppDomain>而不会影响该过程，可以卸载。 进程必须运行很长一段无需重新启动时，这很重要。 此外可以使用应用程序域隔离不应共享数据的任务。  
  
-   如果程序集加载到默认应用程序域，它不能从内存中卸载进程运行时。 但是，如果您打开第二个应用程序域加载和执行程序集，程序集是卸载该应用程序域卸载时。 使用此方法最大程度减少偶尔使用大型 Dll 的长时间运行进程的工作集。  
  
 可以在单个进程; 中运行多个应用程序域但是，没有应用程序域和线程之间具有一对一的相关性。 多个线程可以属于单个应用程序域，并且给定的线程并不局限于单个应用程序域，在任何给定时间，而在单个应用程序域中执行一个线程。  
  
 使用创建应用程序域<xref:System.AppDomain.CreateDomain%2A>方法。 <xref:System.AppDomain> 使用实例来加载和执行程序集 (<xref:System.Reflection.Assembly>)。 当<xref:System.AppDomain>是不能再在使用中，可能会被卸载。  
  
 <xref:System.AppDomain>类实现一组事件，使应用程序进行响应时的应用程序域将被卸载，加载程序集或引发未经处理的异常。  
  
 使用应用程序域的详细信息，请参阅[应用程序域](~/docs/framework/app-domains/application-domains.md)。  
  
 此类实现<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>接口。  
  
 决不要创建的可远程处理包装<xref:System.AppDomain>对象。 执行此操作可以将发布到的远程引用<xref:System.AppDomain>，如公开方法<xref:System.AppDomain.CreateInstance%2A>远程访问和有效地销毁该代码访问安全性<xref:System.AppDomain>。 恶意客户端连接到远程<xref:System.AppDomain>无法获取任何资源的访问权限<xref:System.AppDomain>本身有权访问。 不要创建可远程处理的任何类型，将扩展包装<xref:System.MarshalByRefObject>并实现恶意客户端无法用于绕过安全系统的方法。  
  
> [!CAUTION]
>  默认值为<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>属性是`false`。 此设置是不安全的服务。 若要防止服务下载部分受信任的代码，请将此属性设置为`true`。  
  
   
  
## Examples  
 此示例演示如何创建一个新<xref:System.AppDomain>，实例化类型中的新<xref:System.AppDomain>，并与该类型的对象进行通信。 此外，此示例演示如何卸载<xref:System.AppDomain>导致要进行垃圾回收的对象。  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前应用程序域的激活上下文。</summary>
        <value>一个对象，表示当前应用程序域的激活上下文；或者如果域没有激活上下文，则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要追加到专用路径的目录名称。</param>
        <summary>将指定的目录名追加到专用路径列表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不建议使用此属性，因为它可能会更改之后它们必须已经加载的程序集探测路径。 改用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 属性。  
  
 专用路径或相对搜索路径是相对于程序集解析程序，探测专用程序集的基目录的路径。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获得应用程序域中的应用程序标识。</summary>
        <value>标识应用程序域中应用程序的对象。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取说明授予应用程序的权限以及应用程序是否拥有允许其运行的信任级别的信息。</summary>
        <value>封装应用程序域中应用程序的权限及信任信息的对象。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集显示名称，采用 <see cref="P:System.Reflection.Assembly.FullName" /> 属性提供的格式。</param>
        <summary>返回应用策略后的程序集显示名称。</summary>
        <returns>包含应用策略后的程序集显示名称的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A>方法采用程序集的显示名称，并返回策略后的显示名称。 这是您需要加载使用策略、 程序集，因为仅反射上下文不适用于策略的情况下很有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在加载程序集时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler>委托此事件指示哪些程序集被加载。  
  
 若要注册此事件的事件处理程序，必须具有所需的权限，或<xref:System.Security.SecurityException>引发。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.AssemblyLoad>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在对程序集的解析失败时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它负责<xref:System.ResolveEventHandler>对于此事件，将返回该程序集指定<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性，或返回空值，如果无法识别该程序集。 程序集必须加载到执行上下文;如果加载到只反射上下文中，导致引发此事件则加载会失败。  
  
 使用此事件的指南，请参阅[解析程序集加载](~/docs/framework/app-domains/resolve-assembly-loads.md)。  
  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>属性返回请求无法解析的程序集加载的程序集。 例如，加载程序可能无法加载请求的程序集的依赖项，因为请求的程序集和其依赖项不在探测路径中。 如果多个依赖项的版本可用，知道请求的程序集的标识可能很有用或标识正确的版本中，查找依赖项中。 有关详情，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  开头[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，则<xref:System.ResolveEventHandler>事件引发的所有程序集，包括资源程序集。 在早期版本中的资源程序集不引发事件。 如果本地化操作系统，则可能会调用处理程序多个时间： 为每个区域性回退链中的一次。  
  
 对于此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性返回的程序集名称之前应用策略。  
  
> [!IMPORTANT]
>  如果此事件注册了多个事件处理程序，直到事件处理程序返回一个值的顺序事件 handlersarecalled 这并不是`null`。 后续的事件处理程序将被忽略。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取基目录，它由程序集冲突解决程序用来探测程序集。</summary>
        <value>基目录，由程序集冲突解决程序用来探测程序集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性对应于<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>属性。 它也可以检索使用<xref:System.AppDomain.GetData%2A>与字符串"APPBASE"的方法。  
  
   
  
## Examples  
 下面的代码示例创建一个新的应用程序域，指定要加载到域中搜索的程序集时要使用的基目录。 该示例然后使用<xref:System.AppDomain.BaseDirectory%2A>属性获取的基目录路径，用于显示到控制台。  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">访问路径本身中的信息，如果包括路径采用的是窗体"file://"或\\\UNC\dir 或"c:\\"。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将指定专用程序集位置的路径重置为空字符串 ("")。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 专用路径是相对于公共语言运行时搜索来定位私有程序集的基目录的路径。  
  
 有关详情，请参阅<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.AppDomain.ClearPrivatePath%2A>方法从时程序集都会加载用于搜索的专用路径列表中删除所有条目。  
  
 此方法现已过时，并且不应使用新的开发。  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将包含影像复制的程序集的目录列表重置为空字符串 ("")。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 卷影复制路径是存储的卷影复制程序集的位置的目录列表。  
  
 有关详细信息，请参阅<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>并[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建指定 COM 类型的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">文件的名称，该文件包含定义所请求的类型的程序集。</param>
        <param name="typeName">所请求类型的名称。</param>
        <summary>创建指定 COM 类型的新实例。 形参指定文件的名称，该文件包含含有类型和类型名称的程序集。</summary>
        <returns>一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以远程创建对象，而无需本地加载该类型。  
  
 返回值必须为打开包装才能访问真实对象。  
  
 一个<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>值的属性`true`必须应用显式或默认情况下对此方法的 COM 类型，创建该类型; 的实例为<xref:System.TypeLoadException>引发。  
  
   
  
## Examples  
 下面的示例演示如何  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">无法加载此类型。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.MissingMethodException">未找到公共无形参构造函数。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> 未找到。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> 是一个抽象类。  
  
或 
使用晚期绑定机制调用了此成员。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> 为空字符串 ("")。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NullReferenceException">所引用的 COM 对象为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">文件的名称，该文件包含定义所请求的类型的程序集。</param>
        <param name="typeName">所请求类型的名称。</param>
        <param name="hashValue">表示计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">表示程序集清单使用的哈希算法。</param>
        <summary>创建指定 COM 类型的新实例。 形参指定文件的名称，该文件包含含有类型和类型名称的程序集。</summary>
        <returns>一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以远程创建对象，而无需本地加载该类型。  
  
 返回值必须为打开包装才能访问真实对象。  
  
 一个<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>值的属性`true`必须应用显式或默认情况下对此方法的 COM 类型，创建该类型; 的实例为<xref:System.TypeLoadException>引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">无法加载此类型。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.MissingMethodException">未找到公共无形参构造函数。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> 是一个抽象类。  
  
或 
使用晚期绑定机制调用了此成员。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 为空字符串 ("")。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NullReferenceException">所引用的 COM 对象为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的应用程序域。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">域的友好名称。</param>
        <summary>使用指定的名称新建应用程序域。</summary>
        <returns>新创建的应用程序域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName`参数用于确定对人类有意义的方式中的域。 此字符串应适合在用户界面中显示。  
  
 此方法的重载使用<xref:System.AppDomainSetup>默认应用程序域中的信息。  
  
   
  
## Examples  
 下面的示例演示一般情况下，如何创建使用其中一个域<xref:System.AppDomain.CreateDomain%2A>重载。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">域的友好名称。 此友好名称可在用户界面中显示以标识域。 有关详情，请参阅<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">确定代码标识的证据，该代码在应用程序域中运行。 传递 <see langword="null" /> 以使用当前应用程序域的证据。</param>
        <summary>使用所提供的证据创建具有给定名称的新应用程序域。</summary>
        <returns>新创建的应用程序域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的重载使用<xref:System.AppDomainSetup>默认应用程序域中的信息。  
  
 如果`securityInfo`是未提供，使用从当前的应用程序域证据。  
  
> [!IMPORTANT]
>  不使用此方法的重载来创建沙盒应用程序域。 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，为提供的证据`securityInfo`不会再影响应用程序域的授予集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法重载来创建沙盒应用程序域。  
  
   
  
## Examples  
 下面的示例演示一般情况下，如何创建使用其中一个域<xref:System.AppDomain.CreateDomain%2A>重载。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">域的友好名称。 此友好名称可在用户界面中显示以标识域。 有关详情，请参阅<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">确定代码标识的证据，该代码在应用程序域中运行。 传递 <see langword="null" /> 以使用当前应用程序域的证据。</param>
        <param name="info">包含应用程序域初始化信息的对象。</param>
        <summary>使用指定的名称、证据和应用程序域设置信息创建新的应用程序域。</summary>
        <returns>新创建的应用程序域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`info`是未提供，此方法的重载使用<xref:System.AppDomainSetup>默认应用程序域中的信息。  
  
 如果`securityInfo`是未提供，使用从当前的应用程序域证据。  
  
> [!IMPORTANT]
>  不使用此方法的重载来创建沙盒应用程序域。 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，为提供的证据`securityInfo`不会再影响应用程序域的授予集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法重载来创建沙盒应用程序域。  
  
   
  
## Examples  
 下面的示例演示一般情况下，如何创建使用其中一个域<xref:System.AppDomain.CreateDomain%2A>重载。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">域的友好名称。 此友好名称可在用户界面中显示以标识域。 有关更多信息，请参见 <see cref="P:System.AppDomain.FriendlyName" /> 的说明。</param>
        <param name="securityInfo">确定代码标识的证据，该代码在应用程序域中运行。 传递 <see langword="null" /> 以使用当前应用程序域的证据。</param>
        <param name="info">包含应用程序域初始化信息的对象。</param>
        <param name="grantSet">一个默认权限集，被授予加载到新应用程序域的所有无特定权限的程序集。</param>
        <param name="fullTrustAssemblies">一组强名称，表示在新应用程序域中被认为完全受信任的程序集。</param>
        <summary>使用指定的名称、证据、应用程序域设置信息、默认权限集和一组完全受信任的程序集创建新的应用程序域。</summary>
        <returns>新创建的应用程序域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须设置<xref:System.AppDomainSetup.ApplicationBase%2A>的属性<xref:System.AppDomainSetup>对象，它提供有关`info`。 否则会引发异常。  
  
 如果`securityInfo`是未提供，使用从当前的应用程序域证据。  
  
 为提供的信息`grantSet`并`fullTrustAssemblies`用于创建<xref:System.Security.Policy.ApplicationTrust>新的应用程序域的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">应用程序域为 <see langword="null" />。  
  
或 
<see cref="P:System.AppDomainSetup.ApplicationBase" /> 属性在为 <paramref name="info" /> 提供的 <see cref="T:System.AppDomainSetup" /> 对象上没有设置。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关创建和操作应用程序域的功能。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">域的友好名称。 此友好名称可在用户界面中显示以标识域。 有关详情，请参阅<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">确定代码标识的证据，该代码在应用程序域中运行。 传递 <see langword="null" /> 以使用当前应用程序域的证据。</param>
        <param name="appBasePath">基目录，由程序集冲突解决程序用来探测程序集。 有关详情，请参阅<see cref="P:System.AppDomain.BaseDirectory" />。</param>
        <param name="appRelativeSearchPath">相对于基目录的路径，在此程序集冲突解决程序应探测专用程序集。 有关详情，请参阅<see cref="P:System.AppDomain.RelativeSearchPath" />。</param>
        <param name="shadowCopyFiles">如果为 <see langword="true" />，则向此应用程序域中加载程序集的卷影副本。</param>
        <summary>使用证据、应用程序基路径、相对搜索路径和指定是否向应用程序域中加载程序集的影像副本的形参创建具有给定名称的新应用程序域。</summary>
        <returns>新创建的应用程序域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`securityInfo`是未提供，使用从当前的应用程序域证据。  
  
 有关卷影复制的详细信息，请参阅<xref:System.AppDomain.ShadowCopyFiles%2A>并[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  不使用此方法的重载来创建沙盒应用程序域。 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，为提供的证据`securityInfo`不会再影响应用程序域的授予集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法重载来创建沙盒应用程序域。  
  
   
  
## Examples  
 下面的示例演示一般情况下，如何创建使用其中一个域<xref:System.AppDomain.CreateDomain%2A>重载。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">域的友好名称。 此友好名称可在用户界面中显示以标识域。 有关详情，请参阅<see cref="P:System.AppDomain.FriendlyName" />。</param>
        <param name="securityInfo">确定代码标识的证据，该代码在应用程序域中运行。 传递 <see langword="null" /> 以使用当前应用程序域的证据。</param>
        <param name="appBasePath">基目录，由程序集冲突解决程序用来探测程序集。 有关详情，请参阅<see cref="P:System.AppDomain.BaseDirectory" />。</param>
        <param name="appRelativeSearchPath">相对于基目录的路径，在此程序集冲突解决程序应探测专用程序集。 有关详情，请参阅<see cref="P:System.AppDomain.RelativeSearchPath" />。</param>
        <param name="shadowCopyFiles">如果为 <see langword="true" />，则将程序集的卷影副本加载到应用程序域中。</param>
        <param name="adInit">
          <see cref="T:System.AppDomainInitializer" /> 委托，表示初始化新的 <see cref="T:System.AppDomain" /> 对象时调用的回调方法。</param>
        <param name="adInitArgs">字符串实参数组，在初始化新的 <see cref="T:System.AppDomain" /> 对象时传递给由 <c>adInit</c> 表示的回调。</param>
        <summary>使用证据、应用程序基路径、相对搜索路径和指定是否向应用程序域中加载程序集的影像副本的形参创建具有给定名称的新应用程序域。 指定在初始化应用程序域时调用的回调方法，以及传递回调方法的字符串实参数组。</summary>
        <returns>新创建的应用程序域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所表示的方法`adInit`新创建的应用程序域的上下文中执行。  
  
 如果`securityInfo`是未提供，使用从当前的应用程序域证据。  
  
 有关卷影复制的详细信息，请参阅<xref:System.AppDomain.ShadowCopyFiles%2A>并[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
> [!IMPORTANT]
>  不使用此方法的重载来创建沙盒应用程序域。 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，为提供的证据`securityInfo`不会再影响应用程序域的授予集。 使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法重载来创建沙盒应用程序域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建在指定程序集中定义的指定类型的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <summary>创建在指定程序集中定义的指定类型的新实例。</summary>
        <returns>一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用的默认构造函数`typeName`。  
  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。  
  
 尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集的成功加载。 由于<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前应用程序域加载程序集，公共语言运行时将尝试将该程序集加载到当前应用程序域和负载可能会失败。 加载到当前应用程序域的程序集可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示创建委托的实例时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定程序集中定义的指定类型的新实例。 形参指定激活特性数组。</summary>
        <returns>一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用的默认构造函数`typeName`。  
  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。  
  
 尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集的成功加载。 由于<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前应用程序域加载程序集，公共语言运行时将尝试将该程序集加载到当前应用程序域和负载可能会失败。 加载到当前应用程序域的程序集可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示创建委托的实例时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">它能够调用类型的所有成员上的操作。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">区域性特定的信息，这些信息控制将 <c>args</c> 强制转换为 <c>typeName</c> 构造函数所声明的正式类型。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定程序集中定义的指定类型的新实例。 形参指定联编程序、绑定标志、构造函数实参、用于解释实参的特定于区域性的信息，以及可选激活特性。</summary>
        <returns>一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。  
  
 尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集的成功加载。 由于<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前应用程序域加载程序集，公共语言运行时将尝试将该程序集加载到当前应用程序域和负载可能会失败。 加载到当前应用程序域的程序集可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示创建委托的实例时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">它能够调用类型的所有成员上的操作。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">区域性特定的信息，这些信息控制将 <c>args</c> 强制转换为 <c>typeName</c> 构造函数所声明的正式类型。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <param name="securityAttributes">用于授权创建 <c>typeName</c> 的信息。</param>
        <summary>创建在指定程序集中定义的指定类型的新实例。 参数指定联编程序、绑定标志、构造函数自变量、特定于区域性的信息，这些信息用于解释自变量、激活特性和授权，以创建类型。</summary>
        <returns>一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。  
  
 尝试调用<xref:System.AppDomain.CreateInstance%2A>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集的成功加载。 由于<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，当此方法尝试返回<xref:System.Reflection.Assembly>到当前应用程序域加载程序集，公共语言运行时将尝试将该程序集加载到当前应用程序域和负载可能会失败。 加载到当前应用程序域的程序集可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。  
  
或 
 <paramref name="securityAttributes" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="securityAttributes" /> 应该为 <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">它能够调用类型的所有成员上的操作。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建指定类型的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <summary>创建指定类型的新实例。 形参指定定义类型的程序集以及类型的名称。</summary>
        <returns>
          <paramref name="typeName" /> 所指定对象的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 此方法调用的默认构造函数`typeName`。  
  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。 请参阅<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性的格式`typeName`。  
  
> [!NOTE]
>  如果进行早期绑定调用的方法`M`的类型的对象`T1`返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，和方法可对类型的对象的方法的早期绑定调用`T2`程序集中`C`以外当前程序集或包含的程序集`T1`，程序集`C`加载到当前应用程序域。 即使早期绑定调用也会发生这种加载`T1.M()`中的正文进行<xref:System.Reflection.Emit.DynamicMethod>，或其他动态生成的代码中。 如果当前域是默认域，程序集`C`在进程结束前不能卸载。 如果当前域更高版本尝试加载程序集`C`，负载可能会失败。  
  
   
  
## Examples  
 下面的代码示例显示了另一个应用程序域中执行代码的最简单方法。 该示例定义一个名为类`Worker`，它继承自<xref:System.MarshalByRefObject>。 `Worker`类定义的方法，将显示在其中执行的应用程序域的名称。 该示例创建的实例`Worker`在默认应用程序域和新的应用程序域中。  
  
> [!NOTE]
>  包含的程序集`Worker`必须加载到这两个应用程序域，但是它可以加载仅在新的应用程序域中存在的其他程序集。  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取该文件包含程序集清单，或如果要从不同的清单文件的模块创建一种类型。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建指定类型的新实例。 形参指定定义类型的程序集、类型的名称和激活特性的数组。</summary>
        <returns>
          <paramref name="typeName" /> 所指定对象的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 此方法调用的默认构造函数`typeName`。  
  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。 请参阅<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性的格式`typeName`。  
  
> [!NOTE]
>  如果进行早期绑定调用的方法`M`的类型的对象`T1`返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，和方法可对类型的对象的方法的早期绑定调用`T2`程序集中`C`以外当前程序集或包含的程序集`T1`，程序集`C`加载到当前应用程序域。 即使早期绑定调用也会发生这种加载`T1.M()`中的正文进行<xref:System.Reflection.Emit.DynamicMethod>，或其他动态生成的代码中。 如果当前域是默认域，程序集`C`在进程结束前不能卸载。 如果当前域更高版本尝试加载程序集`C`，负载可能会失败。  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示创建委托的实例时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">它能够调用类型的所有成员上的操作。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">用于控制类型强制的特定于区域性的对象。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常是包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组。 指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定的程序集中定义的指定类型的新实例，指定是否忽略类型名称的大小写，并指定绑定特性和用于选择要创建的类型的联编程序、构造函数的自变量、区域性以及激活特性。</summary>
        <returns>
          <paramref name="typeName" /> 所指定对象的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。 请参阅<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性的格式`typeName`。  
  
> [!NOTE]
>  如果进行早期绑定调用的方法`M`的类型的对象`T1`返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，和方法可对类型的对象的方法的早期绑定调用`T2`程序集中`C`以外当前程序集或包含的程序集`T1`，程序集`C`加载到当前应用程序域。 即使早期绑定调用也会发生这种加载`T1.M()`中的正文进行<xref:System.Reflection.Emit.DynamicMethod>，或其他动态生成的代码中。 如果当前域是默认域，程序集`C`在进程结束前不能卸载。 如果当前域更高版本尝试加载程序集`C`，负载可能会失败。  
  
   
  
## Examples  
 下面的示例演示如何使用`ignoreCase`参数。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示创建委托的实例时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">它能够调用类型的所有成员上的操作。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">用于控制类型强制的特定于区域性的对象。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <param name="securityAttributes">用于授权创建 <c>typeName</c> 的信息。</param>
        <summary>创建指定类型的新实例。 形参指定类型的名称以及查找和创建该类型的方式。</summary>
        <returns>
          <paramref name="typeName" /> 所指定对象的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 请参阅<xref:System.Reflection.AssemblyName>的格式为`assemblyName`。 请参阅<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性的格式`typeName`。  
  
> [!NOTE]
>  如果进行早期绑定调用的方法`M`的类型的对象`T1`返回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，和方法可对类型的对象的方法的早期绑定调用`T2`程序集中`C`以外当前程序集或包含的程序集`T1`，程序集`C`加载到当前应用程序域。 即使早期绑定调用也会发生这种加载`T1.M()`中的正文进行<xref:System.Reflection.Emit.DynamicMethod>，或其他动态生成的代码中。 如果当前域是默认域，程序集`C`在进程结束前不能卸载。 如果当前域更高版本尝试加载程序集`C`，负载可能会失败。  
  
   
  
## Examples  
 下面的示例演示如何使用`ignoreCase`参数。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有权限调用此构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">它能够调用类型的所有成员上的操作。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">文件的名称（包括路径），该文件包含定义所请求类型的程序集。 该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认构造函数`typeName`调用。  
  
 有关更多信息，请参见 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域，而不从其进行调用的应用程序域中创建一个实例，该程序集是加载目标应用程序域中。 但是，如果在调用应用程序域实例解包，以某些方式使用未包装的实例可能导致程序集加载到调用应用程序域。 例如，该实例进行解包后，可能会请求其类型信息、 要调用其方法后期绑定的。 程序集加载到调用应用程序域时，会发生异常。  
  
-   如果在同一程序集中的另一个版本之前加载到调用应用程序域，或调用应用程序域加载路径是不同的目标应用程序域的异常，如<xref:System.MissingMethodException>可能发生。  
  
-   如果调用应用程序域进行早期绑定调用的实例类型，<xref:System.InvalidCastException>可能会尝试强制转换实例时引发。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法重载来在目标应用程序域中创建对象的实例并调用其方法。  
  
 该示例定义了`MarshallableExample`类，该类可以跨应用程序域边界封送。 此示例生成一个对当前正在执行的程序集的路径、 创建目标应用程序域，并使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法重载来示例程序集加载到目标应用程序域并创建一个实例的`MarshallableExample`。  
  
> [!NOTE]
>  路径是绝对地址在此示例中，但相对路径也将起作用，因为<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法用于加载程序集。  
  
 取消包装操作对象句柄之后, 的示例演示三种方法可以在目标应用程序域中使用对象：  
  
-   与使用反射的后期绑定调用的方法。 这需要类型信息，这会导致要加载到调用方的应用程序域的程序集。 （在此示例中，它已经加载。）  
  
-   强制转换为调用方和被调用方所知的接口的对象。 如果在调用程序集或在调用方和被调用方所引用的第三个程序集中定义接口，则调用的程序集不是加载到调用方的应用程序域。  
  
-   直接调用方知道其类型时使用的对象。 程序集必须加载到调用方的应用程序域。  
  
 若要避免被调用的程序集加载到调用方的应用程序域的另一个方法是调用方为派生<xref:System.MarshalByRefObject>类和定义可以在目标应用程序域中运行的方法。 该方法可以使用反射来检查目标程序集，因为目标程序集已加载到目标应用程序域。 有关示例，请参阅<xref:System.AppDomain.DynamicDirectory%2A>属性。  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.MissingMethodException">未找到无形参的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">文件的名称（包括路径），该文件包含定义所请求类型的程序集。 该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认构造函数`typeName`调用。  
  
 有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域，而不从其进行调用的应用程序域中创建一个实例，该程序集是加载目标应用程序域中。 但是，如果在调用应用程序域实例解包，以某些方式使用未包装的实例可能导致程序集加载到调用应用程序域。 例如，该实例进行解包后，可能会请求其类型信息、 要调用其方法后期绑定的。 程序集加载到调用应用程序域时，会发生异常。  
  
-   如果在同一程序集中的另一个版本之前加载到调用应用程序域，或调用应用程序域加载路径是不同的目标应用程序域的异常，如<xref:System.MissingMethodException>可能发生。  
  
-   如果调用应用程序域进行早期绑定调用的实例类型，<xref:System.InvalidCastException>可能会尝试强制转换实例时引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">文件的名称（包括路径），该文件包含定义所请求类型的程序集。 该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">区域性特定的信息，这些信息控制将 <c>args</c> 强制转换为 <c>typeName</c> 构造函数所声明的正式类型。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关更多信息，请参见 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域，而不从其进行调用的应用程序域中创建一个实例，该程序集是加载目标应用程序域中。 但是，如果在调用应用程序域实例解包，以某些方式使用未包装的实例可能导致程序集加载到调用应用程序域。 例如，该实例进行解包后，可能会请求其类型信息、 要调用其方法后期绑定的。 程序集加载到调用应用程序域时，会发生异常。  
  
-   如果在同一程序集中的另一个版本之前加载到调用应用程序域，或调用应用程序域加载路径是不同的目标应用程序域的异常，如<xref:System.MissingMethodException>可能发生。  
  
-   如果调用应用程序域进行早期绑定调用的实例类型，<xref:System.InvalidCastException>可能会尝试强制转换实例时引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">文件的名称（包括路径），该文件包含定义所请求类型的程序集。 该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">区域性特定的信息，这些信息控制将 <c>args</c> 强制转换为 <c>typeName</c> 构造函数所声明的正式类型。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <param name="securityAttributes">用于授权创建 <c>typeName</c> 的信息。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。 返回值需要打开包装才能访问真实对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 当<xref:System.AppDomain.CreateInstanceFrom%2A>方法用于在目标应用程序域，而不从其进行调用的应用程序域中创建一个实例，该程序集是加载目标应用程序域中。 但是，如果在调用应用程序域实例解包，以某些方式使用未包装的实例可能导致程序集加载到调用应用程序域。 例如，该实例进行解包后，可能会请求其类型信息、 要调用其方法后期绑定的。 程序集加载到调用应用程序域时，会发生异常。  
  
-   如果在同一程序集中的另一个版本之前加载到调用应用程序域，或调用应用程序域加载路径是不同的目标应用程序域的异常，如<xref:System.MissingMethodException>可能发生。  
  
-   如果调用应用程序域进行早期绑定调用的实例类型，<xref:System.InvalidCastException>可能会尝试强制转换实例时引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。  
  
或 
 <paramref name="securityAttributes" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="securityAttributes" /> 应为 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyFile" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NullReferenceException">此示例为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定义所请求类型的程序集的文件名和路径。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 此方法调用的默认构造函数`typeName`。  
  
 有关更多信息，请参见 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到无形参的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定义所请求类型的程序集的文件名和路径。</param>
        <param name="typeName">所请求类型的完全限定名，包括命名空间而不是程序集（请参见 <see cref="P:System.Type.FullName" /> 属性）。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。 此方法调用的默认构造函数`typeName`。  
  
 有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到无形参的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">定义所请求类型的程序集的文件名和路径。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">区域性特定的信息，这些信息控制将 <c>args</c> 强制转换为 <c>typeName</c> 构造函数所声明的正式类型。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>创建在指定的程序集文件中定义的指定类型的新实例，指定是否忽略类型名称的大小写，并指定绑定特性和用于选择要创建的类型的联编程序、构造函数的自变量、区域性以及激活特性。</summary>
        <returns>请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">定义所请求类型的程序集的文件名和路径。</param>
        <param name="typeName">
          <see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</param>
        <param name="ignoreCase">一个布尔值，指示是否执行区分大小写的搜索。</param>
        <param name="bindingAttr">影响 <c>typeName</c> 构造函数搜索的零个或多个位标志的组合。 如果 <c>bindingAttr</c> 为零，则对公共构造函数进行区分大小写的搜索。</param>
        <param name="binder">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 null，则使用默认联编程序。</param>
        <param name="args">要传递给构造函数的实参。 此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。 如果默认的构造函数是首选构造函数，则 <c>args</c> 必须为空数组或 null。</param>
        <param name="culture">区域性特定的信息，这些信息控制将 <c>args</c> 强制转换为 <c>typeName</c> 构造函数所声明的正式类型。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  
  
此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <param name="securityAttributes">用于授权创建 <c>typeName</c> 的信息。</param>
        <summary>创建在指定程序集文件中定义的指定类型的新实例。</summary>
        <returns>请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个便利方法，将组合在一起<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。  
  
 有关此方法的详细信息，请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。  
  
或 
 <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyName" />。</exception>
        <exception cref="T:System.TypeLoadException">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typeName" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的公共构造函数。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有足够的权限调用此构造函数。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">它能够读取包含程序集清单的文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Threading.Thread" /> 的当前应用程序域。</summary>
        <value>当前应用程序域。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例创建一个新的应用程序域。 <xref:System.AppDomain.CurrentDomain%2A>属性用于获取<xref:System.AppDomain>对象，表示当前应用程序域。 <xref:System.AppDomain.FriendlyName%2A>属性提供当前应用程序域，然后在命令行上显示的名称。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在当前应用程序域中定义动态程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">动态程序集的访问模式。</param>
        <summary>以指定名称和访问模式定义动态程序集。</summary>
        <returns>含指定名称和访问模式的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">动态程序集的访问模式。</param>
        <param name="assemblyAttributes">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</param>
        <summary>使用指定的名称、访问模式和自定义特性定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载来指定属性，除非在已应用创建动态程序集时，可能无法正常工作。 例如，安全属性，如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>即使添加了创建动态程序集后，可能无法正常工作。  
  
 应使用此方法只能用于当前应用程序域中定义动态程序集。 有关此限制的详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
 中引入了此方法重载[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
   
  
## Examples  
 下面的代码示例演示如何创建动态程序集具有<xref:System.Security.SecurityTransparentAttribute>。 必须将属性指定的数组的元素为<xref:System.Reflection.Emit.CustomAttributeBuilder>对象。  
  
 创建的第一步<xref:System.Reflection.Emit.CustomAttributeBuilder>以获取该属性的构造函数。 构造函数没有任何参数，因此<xref:System.Type.GetConstructor%2A>的空数组与调用方法<xref:System.Type>对象来表示参数的类型。 第二步是将生成<xref:System.Reflection.ConstructorInfo>对象的构造函数<xref:System.Reflection.Emit.CustomAttributeBuilder>类，以及类型的空数组<xref:System.Object>来表示的参数。  
  
 得到<xref:System.Reflection.Emit.CustomAttributeBuilder>随后将传递到<xref:System.AppDomain.DefineDynamicAssembly%2A>方法作为数组的唯一元素。  
  
 示例代码在新的动态程序集中定义模块和一个类型，然后显示该程序集的属性。  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="evidence">为动态程序集提供的证据。 该证据始终作为最后一组用于策略解析的证据来使用。</param>
        <summary>使用指定名称、访问模式和证据定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任调用方可以提供其`evidence`定义动态时<xref:System.Reflection.Assembly>。 在运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略，以确定授予的权限。 部分受信任的调用方必须提供 null `evidence`。 如果`evidence`是`null`，在运行时将复制的权限集，即，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>到动态<xref:System.Reflection.Assembly>正在定义，并将策略标记为已解决。  
  
 如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获取基于与位置相关联的策略授予其中<xref:System.Reflection.Assembly>已保存。  
  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 首先，此代码示例尝试创建的实例`MyDynamicType`通过调用<xref:System.AppDomain.CreateInstance%2A>方法替换为无效的程序集名称，并捕获产生的异常。  
  
 然后，该代码示例添加的事件处理程序<xref:System.AppDomain.AssemblyResolve>事件，并再次尝试创建的实例`MyDynamicType`。 在调用<xref:System.AppDomain.CreateInstance%2A>，则<xref:System.AppDomain.AssemblyResolve>为无效的程序集引发事件。 事件处理程序将创建包含名为的类型的动态程序集`MyDynamicType`，提供的类型无参数构造函数，并返回新的动态程序集。 在调用<xref:System.AppDomain.CreateInstance%2A>成功，然后完成的构造函数和`MyDynamicType`在控制台上显示一条消息。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存程序集的目录的名称。 如果 <c>dir</c> 是 <see langword="null" />，目录将默认为当前目录。</param>
        <summary>使用指定名称、访问模式和存储目录定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">动态程序集的访问模式。</param>
        <param name="assemblyAttributes">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</param>
        <param name="securityContextSource">安全上下文的源。</param>
        <summary>定义具有指定名称、访问模式和自定义特性的动态程序集，并将指定源用于动态程序集的安全上下文。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载来指定属性，除非在已应用创建动态程序集时，可能无法正常工作。 例如，安全属性，如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>即使添加了创建动态程序集后，可能无法正常工作。  
  
 应使用此方法只能用于当前应用程序域中定义动态程序集。 有关此限制的详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> 的值不是枚举值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存程序集的目录的名称。 如果 <c>dir</c> 是 <see langword="null" />，目录将默认为当前目录。</param>
        <param name="evidence">为动态程序集提供的证据。 该证据始终作为最后一组用于策略解析的证据来使用。</param>
        <summary>使用指定名称、访问模式、存储目录和证据定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有完全受信任调用方可以提供其`evidence`定义动态时<xref:System.Reflection.Assembly>。 在运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略，以确定授予的权限。 部分受信任的调用方必须提供 null `evidence`。 如果`evidence`是`null`，在运行时将复制的权限集，即，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>到动态<xref:System.Reflection.Assembly>正在定义，并将策略标记为已解决。  
  
 如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获取基于与位置相关联的策略授予其中<xref:System.Reflection.Assembly>已保存。  
  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="requiredPermissions">必需的权限请求。</param>
        <param name="optionalPermissions">可选的权限请求。</param>
        <param name="refusedPermissions">被拒绝的权限请求。</param>
        <summary>使用指定名称、访问模式和权限请求定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不使用除非保存该动态程序集并将其重新加载到内存。 若要指定永远不会保存到磁盘中，使用的重载的瞬态程序集的权限请求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和所请求的权限，并提供<xref:System.Security.Policy.Evidence>对象。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存动态程序集的目录的名称。 如果 <c>dir</c> 为 <see langword="null" />，则使用当前目录。</param>
        <param name="isSynchronized">若要在动态程序集中同步模块、类型和成员的创建，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="assemblyAttributes">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</param>
        <summary>使用指定名称、访问模式、存储目录和同步选项定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载来指定属性，除非在已应用创建动态程序集时，可能无法正常工作。 例如，安全属性，如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>即使添加了创建动态程序集后，可能无法正常工作。  
  
 如果`isSynchronized`是`true`，生成的以下方法<xref:System.Reflection.Emit.AssemblyBuilder>将同步： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果在不同的线程上调用这些方法的两个程序，一个将另完成之前一直阻止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="evidence">为动态程序集提供的证据。 该证据始终作为最后一组用于策略解析的证据来使用。</param>
        <param name="requiredPermissions">必需的权限请求。</param>
        <param name="optionalPermissions">可选的权限请求。</param>
        <param name="refusedPermissions">被拒绝的权限请求。</param>
        <summary>使用指定名称、访问模式、证据和权限请求定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的权限请求`requiredPermissions`， `optionalPermissions`，并`refusedPermissions`才会使用`evidence`还提供，或如果动态程序集是保存和重新加载到内存。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
 只有完全受信任调用方可以提供其`evidence`定义动态时<xref:System.Reflection.Assembly>。 在运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略，以确定授予的权限。 部分受信任的调用方必须提供 null `evidence`。 如果`evidence`是`null`，在运行时将复制的权限集，即，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>到动态<xref:System.Reflection.Assembly>正在定义，并将策略标记为已解决。  
  
 如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获取基于与位置相关联的策略授予其中<xref:System.Reflection.Assembly>已保存。  
  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存程序集的目录的名称。 如果 <c>dir</c> 是 <see langword="null" />，目录将默认为当前目录。</param>
        <param name="requiredPermissions">必需的权限请求。</param>
        <param name="optionalPermissions">可选的权限请求。</param>
        <param name="refusedPermissions">被拒绝的权限请求。</param>
        <summary>使用指定名称、访问模式、存储目录和权限请求定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的权限请求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不使用除非保存该动态程序集并将其重新加载到内存。 若要指定永远不会保存到磁盘中，使用的重载的瞬态程序集的权限请求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和所请求的权限，并提供<xref:System.Security.Policy.Evidence>对象。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议你使用的重载<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，它指定证据和权限，提供你想要有，并且包含的动态程序集的证据<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`. 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存程序集的目录的名称。 如果 <c>dir</c> 是 <see langword="null" />，目录将默认为当前目录。</param>
        <param name="evidence">为动态程序集提供的证据。 该证据始终作为最后一组用于策略解析的证据来使用。</param>
        <param name="requiredPermissions">必需的权限请求。</param>
        <param name="optionalPermissions">可选的权限请求。</param>
        <param name="refusedPermissions">被拒绝的权限请求。</param>
        <summary>使用指定名称、访问模式、存储目录、证据和权限请求定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的权限请求`requiredPermissions`， `optionalPermissions`，并`refusedPermissions`才会使用`evidence`还提供，或如果动态程序集是保存和重新加载到内存。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
 只有完全受信任调用方可以提供其`evidence`定义动态时<xref:System.Reflection.Assembly>。 在运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略，以确定授予的权限。 部分受信任的调用方必须提供 null `evidence`。 如果`evidence`是`null`，在运行时将复制的权限集，即，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>到动态<xref:System.Reflection.Assembly>正在定义，并将策略标记为已解决。  
  
 如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获取基于与位置相关联的策略授予其中<xref:System.Reflection.Assembly>已保存。  
  
 此方法只应该用于当前应用程序域中定义动态程序集。 有关详细信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存动态程序集的目录的名称。 如果 <c>dir</c> 是 <see langword="null" />，目录将默认为当前目录。</param>
        <param name="evidence">为动态程序集提供的证据。 该证据始终作为最后一组用于策略解析的证据来使用。</param>
        <param name="requiredPermissions">必需的权限请求。</param>
        <param name="optionalPermissions">可选的权限请求。</param>
        <param name="refusedPermissions">被拒绝的权限请求。</param>
        <param name="isSynchronized">若要在动态程序集中同步模块、类型和成员的创建，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用指定名称、访问模式、存储目录、证据、权限请求和同步选项定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的权限请求`requiredPermissions`， `optionalPermissions`，并`refusedPermissions`才会使用`evidence`还提供，或如果动态程序集是保存和重新加载到内存。  
  
> [!NOTE]
>  在开发期间用于发出动态程序集的代码，建议您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。 其中包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`参数可确保验证 MSIL。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>与要求完全信任的代码一起使用时引发。  
  
 只有完全受信任调用方可以提供其证据定义动态时<xref:System.Reflection.Assembly>。 在运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略，以确定授予的权限。 部分受信任的调用方必须提供`null`为`evidence`参数。 如果`evidence`是`null`，在运行时将复制的权限集，即，当前授予和拒绝集，从调用方的<xref:System.Reflection.Assembly>到动态<xref:System.Reflection.Assembly>正在定义，并将策略标记为已解决。  
  
 如果动态<xref:System.Reflection.Assembly>是保存到磁盘，后面的加载将获取基于与位置相关联的策略授予其中<xref:System.Reflection.Assembly>已保存。  
  
 如果`isSynchronized`是`true`，生成的以下方法<xref:System.Reflection.Emit.AssemblyBuilder>将同步： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果在不同的线程上调用这些方法的两个程序，一个将其他完成之前一直阻止。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">动态程序集的唯一标识。</param>
        <param name="access">访问动态程序集所采用的模式。</param>
        <param name="dir">保存动态程序集的目录的名称。 如果 <c>dir</c> 为 <see langword="null" />，则使用当前目录。</param>
        <param name="evidence">为动态程序集提供的证据。 该证据始终作为最后一组用于策略解析的证据来使用。</param>
        <param name="requiredPermissions">必需的权限请求。</param>
        <param name="optionalPermissions">可选的权限请求。</param>
        <param name="refusedPermissions">被拒绝的权限请求。</param>
        <param name="isSynchronized">若要在动态程序集中同步模块、类型和成员的创建，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="assemblyAttributes">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</param>
        <summary>使用指定的名称、访问模式、存储目录、证据、权限请求、同步选项和自定义特性定义动态程序集。</summary>
        <returns>具有指定名称和功能的动态程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载来指定属性，除非在已应用创建动态程序集时，可能无法正常工作。 例如，安全属性，如<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>即使添加了创建动态程序集后，可能无法正常工作。  
  
 为指定的权限请求`requiredPermissions`， `optionalPermissions`，并`refusedPermissions`参数才会使用`evidence`还提供参数，或如果动态程序集是保存和重新加载到内存。  
  
> [!NOTE]
>  开发时发出动态程序集的代码，我们建议您包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>标记中`refusedPermissions`参数。 包含此标志可确保的 Microsoft 中间语言 (MSIL) 将进行验证。 此方法会检测无意间生成不可验证的代码，否则为这是很难检测到。 此技术的一个限制是，它还会导致<xref:System.Security.SecurityException>要求完全信任的代码中使用它时引发。  
  
 只有完全受信任调用方可以提供证据定义动态时<xref:System.Reflection.Assembly>。 运行时将映射<xref:System.Security.Policy.Evidence>通过安全策略，以确定授予的权限。 部分受信任的调用方必须提供`null`为`evidence`参数。 如果`evidence`是`null`，运行时将从调用方的程序集的权限集 （即，当前授予和拒绝集） 复制到正在定义中，并将策略标记为已解决的动态程序集。  
  
 如果动态程序集保存到磁盘，后续加载会授予基于与保存动态程序集的位置相关联的策略。  
  
 如果`isSynchronized`是`true`，生成的以下方法<xref:System.Reflection.Emit.AssemblyBuilder>将同步： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 如果在不同的线程上调用这些方法的两个程序，一个将另完成之前一直阻止。  
  
 中引入了此方法重载[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。  
  
或 
<paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">指定要调用的方法的委托。</param>
        <summary>在另一个应用程序域中执行代码，该应用程序域由指定的委托标识。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` 可以指定封送按值， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>。  
  
   
  
## Examples  
 下面的示例演示了如何使用静态<xref:System.AppDomain.DoCallBack%2A>方法。  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 下面的示例演示了如何使用<xref:System.AppDomain.DoCallBack%2A>按值的方法。  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 下面的示例演示了如何使用<xref:System.AppDomain.DoCallBack%2A>方法按引用。  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获得初始化应用程序域时主机提供的域管理器。</summary>
        <value>一个对象，表示初始化应用程序域时主机提供的域管理器；或者如果没有提供域管理器，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时 (CLR) 的非托管的主机可以提供域管理器。 域管理器可以参与初始化新的应用程序域并提供其他管理器，如<xref:System.Security.HostSecurityManager>，该元素参与应用程序域的操作。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在即将卸载 <see cref="T:System.AppDomain" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>委托卸载应用程序域之前，此事件可以执行任何终止活动。  
  
 需要对其执行处理卸载时每个应用程序域应注册此事件的事件处理程序。 共享的事件处理程序不应使用，因为<xref:System.EventHandler>委托将无法识别的域正在卸载模块。  
  
> [!NOTE]
>  默认应用程序域中永远不会引发此事件。  
  
 不进行有关线程引发事件的假设。 可以在比调用不同的线程上引发该事件<xref:System.AppDomain.Unload%2A>方法。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取目录，它由程序集冲突解决程序用来探测动态创建的程序集。</summary>
        <value>目录，它由程序集冲突解决程序用来探测动态创建的程序集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要设置的动态目录，将分配到的基目录路径<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>属性的<xref:System.AppDomainSetup>将用于创建新的应用程序域的对象。 通过简单名称是将分配到的字符串的哈希代码子目录添加修改分配给属性的基目录路径<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>属性，因此在基目录的格式是*原始路径* \\*哈希代码*。 动态目录是此基目录的子目录。 其简单的名称为的值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>属性，因此其格式是*原始路径*\\*哈希代码*\\*应用程序名称*。  
  
   
  
## Examples  
 下面的示例创建与目录的动态程序集的应用程序域、 发出动态程序集并将其存储在动态目录中，将程序集加载到新的应用程序域并使用它。  
  
 此示例将创建<xref:System.AppDomainSetup>对象并设置其<xref:System.AppDomainSetup.ApplicationName%2A>属性设置为"示例"并将其<xref:System.AppDomainSetup.DynamicBase%2A>属性设置为"C:\DynamicAssemblyDir"。 该示例然后显示<xref:System.AppDomainSetup.DynamicBase%2A>属性，以显示应用程序名称的哈希代码具有已追加为最初分配的路径的子目录。  
  
> [!NOTE]
>  在此示例中的基目录被用于示例应用程序位于探测路径外部。 请确保编译中的其他位置的示例。 每次运行该示例删除在基目录及其所有的子目录。  
  
 该示例创建一个新的应用程序域，使用<xref:System.AppDomainSetup>对象。 该示例使用<xref:System.AppDomain.DynamicDirectory%2A>属性检索的目录的名称，因此它可以创建目录。 （该示例可以轻松地创建目录事先通过连接的原始路径、 应用程序名称和应用程序名称的哈希代码。）  
  
 本示例具有`GenerateDynamicAssembly`方法发出的程序集名为`DynamicHelloWorld.dll`并将其存储在新应用程序域的动态目录。 动态程序集包含一种类型， `HelloWorld`，具有一个静态方法 (`Shared`方法在 Visual Basic 中的) 名为`HelloFromAD`。 调用此方法显示应用程序域的名称。  
  
 `Example`类派生自<xref:System.MarshalByRefObject>，因此该示例可以创建类的实例中，新应用程序域并调用其`Test`方法。 `Test`方法加载的动态程序集按其显示名称，并调用静态`HelloFromAD`方法。  
  
 可以显示后正常的探测路径搜索动态目录，通过编写代码的名为程序集`DynamicHelloWorld.dll`并将其编译为此示例中的相同目录中。 程序集必须具有一个名为类`HelloWorld`与名为静态方法`HelloFromAD`。 此方法不需要具有相同的功能中这些示例。它可以只需将字符串显示到控制台。 程序集还必须具有<xref:System.Reflection.AssemblyVersionAttribute>设置其版本为 1.0.0.0 的属性。 运行示例时，动态目录中搜索之前，找到在当前目录中编译的程序集。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序域关联的 <see cref="T:System.Security.Policy.Evidence" />。</summary>
        <value>与该应用程序域关联的证据。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行指定文件中包含的程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要执行程序集的文件的名称。</param>
        <summary>执行指定文件中包含的程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 此外可以执行使用的程序集<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 若要创建<xref:System.AppDomain>若要加载并执行，请使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
   
  
## Examples  
 下面的示例演示了如何使用的重载之一<xref:System.AppDomain.ExecuteAssembly%2A>在两个不同的域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要执行程序集的文件的名称。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>使用指定的证据执行指定文件中包含的程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 <xref:System.AppDomain.ExecuteAssembly%2A>方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 此外可以执行使用的程序集<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下面的示例演示了如何使用的重载之一<xref:System.AppDomain.ExecuteAssembly%2A>在两个不同的域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要执行程序集的文件的名称。</param>
        <param name="args">程序集的入口点的自变量。</param>
        <summary>使用指定的自变量执行指定文件中包含的程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 此外可以执行使用的程序集<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下面的示例演示了如何使用的重载之一<xref:System.AppDomain.ExecuteAssembly%2A>在两个不同的域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要执行程序集的文件的名称。</param>
        <param name="assemblySecurity">为程序集提供的证据。</param>
        <param name="args">程序集的入口点的自变量。</param>
        <summary>使用指定的证据和自变量执行指定文件中包含的程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 此外可以执行使用的程序集<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下面的示例演示了如何使用的重载之一<xref:System.AppDomain.ExecuteAssembly%2A>在两个不同的域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="assemblySecurity" /> 应为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要执行程序集的文件的名称。</param>
        <param name="args">程序集的入口点的自变量。</param>
        <param name="hashValue">表示计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">表示程序集清单使用的哈希算法。</param>
        <summary>使用指定的自变量、哈希值和哈希算法执行指定文件中包含的程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 此外可以执行使用的程序集<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 下面的示例演示了如何使用的重载之一<xref:System.AppDomain.ExecuteAssembly%2A>在两个不同的域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含要执行程序集的文件的名称。</param>
        <param name="assemblySecurity">为程序集提供的证据。</param>
        <param name="args">程序集的入口点的自变量。</param>
        <param name="hashValue">表示计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">表示程序集清单使用的哈希算法。</param>
        <summary>使用指定的证据、自变量、哈希值和哈希算法执行指定文件中包含的程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 此方法加载程序集使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。 此外可以执行使用的程序集<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
   
  
## Examples  
 以下示例演示如何使用的重载之一<xref:System.AppDomain.ExecuteAssembly%2A>在两个不同的域。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="assemblySecurity" /> 应为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <summary>在给定其显示名称的情况下执行程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供了与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的程序集的显示名称或<xref:System.Reflection.AssemblyName>而不是按文件位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载的程序集<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 若要创建<xref:System.AppDomain>若要加载并执行，请使用<xref:System.AppDomain.CreateDomain%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的程序集。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件或目录，用于对路径本身中的信息的访问和重定向到的路径的显示名称的访问。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于访问网站，显示名称重定向到 URL 时。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> 对象，表示程序集名称。</param>
        <param name="args">启动该进程时传递的命令行参数。</param>
        <summary>根据给定的 <see cref="T:System.Reflection.AssemblyName" /> 使用指定的参数执行程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供了与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的程序集的显示名称或<xref:System.Reflection.AssemblyName>而不是按文件位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载的程序集<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。  
  
或 
 <paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件或目录，用于对路径本身中的信息的访问和重定向到的路径的显示名称的访问。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于访问网站，显示名称重定向到 URL 时。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>在给定显示名称的情况下，使用指定证据执行程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供了与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的程序集的显示名称或<xref:System.Reflection.AssemblyName>而不是按文件位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载的程序集<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
> [!NOTE]
>  当你使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法替换<xref:System.Security.Policy.Evidence>参数，证据进行合并。 作为参数提供的证据<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代加载程序提供的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件或目录，用于对路径本身中的信息的访问和重定向到的路径的显示名称的访问。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于访问网站，显示名称重定向到 URL 时。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="args">启动该进程时传递的命令行参数。</param>
        <summary>在给定显示名称的情况下，使用指定自变量执行程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供了与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的程序集的显示名称或<xref:System.Reflection.AssemblyName>而不是按文件位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载的程序集<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。  
  
或 
 <paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件或目录，用于对路径本身中的信息的访问和重定向到的路径的显示名称的访问。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于访问网站，显示名称重定向到 URL 时。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="T:System.Reflection.AssemblyName" /> 对象，表示程序集名称。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <param name="args">启动该进程时传递的命令行参数。</param>
        <summary>根据给定的 <see cref="T:System.Reflection.AssemblyName" /> 使用指定的证据和实参执行程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供了与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的程序集的显示名称或<xref:System.Reflection.AssemblyName>而不是按文件位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载的程序集<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
> [!NOTE]
>  当你使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法替换<xref:System.Security.Policy.Evidence>参数，证据进行合并。 作为参数提供的证据<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代加载程序提供的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="assemblySecurity" /> 应为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件或目录，用于对路径本身中的信息的访问和重定向到的路径的显示名称的访问。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于访问网站，显示名称重定向到 URL 时。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <param name="args">启动该进程时传递的命令行参数。</param>
        <summary>在给定其显示名称的情况下，使用指定证据和自变量执行程序集。</summary>
        <returns>程序集的入口点返回的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法提供了与类似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的程序集的显示名称或<xref:System.Reflection.AssemblyName>而不是按文件位置。 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>加载的程序集<xref:System.Reflection.Assembly.Load%2A>方法而不是与<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 程序集开始在.NET Framework 标头中指定的入口点执行。  
  
 此方法不会创建新的进程或应用程序域，并且它不在新线程上执行的入口点方法。  
  
> [!NOTE]
>  当你使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法替换<xref:System.Security.Policy.Evidence>参数，证据进行合并。 作为参数提供的证据<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代加载程序提供的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 <paramref name="assemblyName" /> 指定的程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="assemblySecurity" /> 应为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">指定的程序集没有入口点。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件或目录，用于对路径本身中的信息的访问和重定向到的路径的显示名称的访问。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于访问网站，显示名称重定向到 URL 时。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">若要执行的控制台应用程序。 关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当托管代码抛出异常时发生，在运行时在调用堆栈中搜索应用程序域中的异常处理程序之前。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件只是一个通知。 处理此事件不处理该异常也会影响后续异常以任何方式处理。 引发该事件并在调用事件处理程序后，公共语言运行时 (CLR) 开始搜索异常处理程序。 <xref:System.AppDomain.FirstChanceException> 第一次机会检查任何托管的异常中提供的应用程序域。  
  
 可以针对每个应用程序域处理此事件。 如果一个线程在执行调用时通过多个应用程序域，CLR 开始搜索匹配的异常处理程序在该应用程序域之前已注册事件处理程序，每个应用程序域中引发事件。 处理该事件后，为该应用程序域中匹配的异常处理程序进行搜索。 如果找不到下, 一步的应用程序域中引发事件。  
  
 必须处理发生在事件处理程序的所有异常<xref:System.AppDomain.FirstChanceException>事件。 否则为<xref:System.AppDomain.FirstChanceException>引发以递归方式。 这可能导致堆栈溢出和终止应用程序。 我们建议你实现此事件的事件处理程序为受约束的执行区域 (Cer)，以防止与基础结构相关的异常，例如内存不足或堆栈溢出异常通知时，会影响虚拟机正在处理。  
  
 此事件不引发的异常指示损坏进程状态，例如，访问冲突，除非事件处理程序是安全关键的并且具有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。  
  
 正在处理此通知事件时，公共语言运行时将挂起线程中止。  
  
   
  
## Examples  
 下面的示例创建名为应用程序域的一系列`AD0`通过`AD3`，使用`Worker`每个应用程序域中的对象。 每个`Worker`对象具有对引用`Worker`对象在下一步的应用程序域中，除`Worker`最后一个应用程序域中。 <xref:System.AppDomain.FirstChanceException>以外的所有应用程序域中处理事件`AD1`。  
  
> [!NOTE]
>  除了此示例中，该示例演示了多个应用程序域中的第一次异常通知，您可以发现中的简单用例[如何： 接收首次异常通知](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)。  
  
 当已创建应用程序域时，默认应用程序域调用`TestException`方法的第一个应用程序域。 每个`Worker`对象调用`TestException`方法下一步的应用程序域，直到最后一个`Worker`引发的异常处理的或未经处理的。 因此，当前线程通过所有应用程序域和`TestException`添加到每个应用程序域中的堆栈。  
  
 当最后一个`Worker`对象处理异常，<xref:System.AppDomain.FirstChanceException>仅在最后一个应用程序域中引发事件。 其他应用程序域永远不会有机会处理异常，因此不会引发事件。  
  
 当最后一个`Worker`对象不处理异常，<xref:System.AppDomain.FirstChanceException>具有事件处理程序的每个应用程序域中引发事件。 每个事件处理程序完成后，堆栈将继续展开，直到通过默认应用程序域中捕获的异常。  
  
> [!NOTE]
>  若要查看堆栈显示如更接近引发该事件的增长和更接近于默认应用程序域，请更改`e.Exception.Message`到`e.Exception`中`FirstChanceHandler`事件处理程序。 请注意，当`TestException`调用跨应用程序域边界，它会出现两次： 一次为代理和存根 （stub） 的一次。  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此应用程序域的友好名称。</summary>
        <value>此应用程序域的友好名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认应用程序域的友好名称是进程可执行文件的文件名。 例如，如果用于启动进程可执行文件是`"c:\MyAppDirectory\MyAssembly.exe"`，默认应用程序域的友好名称是`"MyAssembly.exe"`。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.AppDomain.FriendlyName%2A>属性来获取当前应用程序域的友好名称。 对于默认应用程序域，友好名称是应用程序的可执行文件的名称。 代码示例还显示有关应用程序域的其他信息。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取已加载到此应用程序域的执行上下文中的程序集。</summary>
        <returns>此应用程序域中的程序集的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例使用<xref:System.AppDomain.GetAssemblies%2A>方法以获取已加载到应用程序域的所有程序集的列表。 程序集将显示到控制台。  
  
 若要运行此代码示例，需要创建名为程序集`CustomLibrary.dll`，或更改程序集名称传递给<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前线程标识符。</summary>
        <returns>一个 32 位带符号整数，它是当前线程的标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>属性，它是稳定甚至.NET Framework 托管通过支持纤程 （即，轻量级线程） 的环境。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要调用此方法。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">预定义应用程序域属性的名称，或已定义的应用程序域属性的名称。</param>
        <summary>为指定名称获取存储在当前应用程序域中的值。</summary>
        <returns>
          <paramref name="name" /> 属性的值，或 <see langword="null" />（如果属性不存在）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于检索名称数据对描述此实例的属性的内部缓存中的条目的值<xref:System.AppDomain>。 请注意，比较`name`键-值对的名称是区分大小写。  
  
 该缓存自动包含预定义的系统项的创建应用程序域时插入。 您可以检查它们的值与<xref:System.AppDomain.GetData%2A>方法或等效<xref:System.AppDomainSetup>属性。  
  
 可以插入或修改与自己用户定义名称数据对<xref:System.AppDomain.SetData%2A>方法，并检查其值与<xref:System.AppDomain.GetData%2A>方法。  
  
 下表描述了`name`每个预定义的系统入口和其对应<xref:System.AppDomainSetup>属性。  
  
|Name 的值|Property|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|（无属性）<br /><br /> "APP_LAUNCH_URL"表示之前的任何重定向,，用户最初请求的 URL。 仅当已使用 Internet Explorer 等浏览器启动了应用程序时，它是可用。 并非所有浏览器提供此值。|  
|"A P P _"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|（无属性）|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE"或特定于应用程序的字符串|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|（无属性）|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT"不是系统条目，并且其值可通过调用设置<xref:System.AppDomain.SetData%2A>方法。|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 下面的示例创建一个新的应用程序域，设置在域中的系统提供值并将域的新值对。 该示例然后演示如何使用<xref:System.AppDomain.GetData%2A>方法以从这些值对检索数据并将其显示到控制台。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身，如果该属性适用于路径中的信息。 关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的类型。</summary>
        <returns>当前实例的类型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获得一个整数，该整数唯一标识进程中的应用程序域。</summary>
        <value>标识应用程序域的整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例创建第二个应用程序域，并显示的默认域和新的域有关的信息。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过防止创建租约来给予 <see cref="T:System.AppDomain" /> 无限生存期。</summary>
        <returns>总是为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要测试的兼容性开关。</param>
        <summary>获取可以为 null 的布尔值，该值指示是否设置了任何兼容性开关，如果已设置，则指定是否设置了指定的兼容性开关。</summary>
        <returns>如果未设置任何兼容性开关，则为 null 引用（Visual Basic 中的 <see langword="Nothing" />）；否则，为布尔值，指示是否设置了由 <paramref name="value" /> 指定的兼容性开关。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法测试是否已为当前应用程序域中设置指定兼容性开关。 兼容性开关通常还原行为 （例如，字符串的方式进行排序） 的.NET Framework 版本之间已更改。  它们由调用设置<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>方法，然后再创建一个应用程序域。  
  
 下表提供了兼容性开关，可设置为还原的早期版本的.NET Framework 的行为的示例。  
  
|开关|含义|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|有关代码访问安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]启用此应用程序域中。 请参阅[ &lt;NetFx40_LegacySecurityPolicy&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|字符串排序的默认值[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]在此应用程序域中启用。 它成功要求 sort00001000.dll 安装。 请参阅[ &lt;CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|字符串排序的默认值[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，并且在此应用程序域中启用 Unicode 5.0。 它成功需要 sort00060101.dll 安装。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式设置行为的[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]启用此应用程序域中。  请参阅[ &lt;TimeSpan_LegacyFormatMode&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和"还原旧版 TimeSpan 格式设置"部分的<xref:System.TimeSpan>主题。|  
|"UseRandomizedStringHashAlgorithm"|在运行时计算字符串的哈希代码对每个应用程序域而不是使用跨应用程序域生成一致的哈希代码的单个哈希算法。 请参阅[ &lt;userandomizedstringhashalgorithm，那么&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，指示应用程序域是否是进程的默认应用程序域。</summary>
        <returns>如果当前 <see cref="T:System.AppDomain" /> 对象表示进程的默认应用程序域，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个托管的进程都有一个默认应用程序域。 默认域中开始执行。  
  
   
  
## Examples  
 下面的代码示例创建第二个应用程序域，并显示的默认域和新的域有关的信息。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示此应用程序域是否正在卸载以及公共语言运行时是否正在终止该域包含的对象。</summary>
        <returns>如果此应用程序域正在卸载，并且公共语言运行时已开始调用终止程序，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个对象的完成方法提供该对象进行垃圾回收之前执行任何必要的清理操作的机会。 完成后，该对象处于可访问，但处于无效状态，因而无法使用。 最终，垃圾回收完成，并回收对象。  
  
 在以下情况之一调用对象的完成方法： 垃圾回收期间时公共语言运行时关闭或卸载应用程序域包含的对象时。 <xref:System.AppDomain.IsFinalizingForUnload%2A>方法将返回`true`仅在最后一种情况; 它不返回`true`终止结果从常规垃圾回收或 CLR 关闭时。  
  
> [!NOTE]
>  若要确定是否由于 CLR 关闭完成，请使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>属性。 它将返回`true`终止是否由于应用程序域正在卸载或者 CLR 正在关闭。  
  
 执行时完成方法域卸载期间，你可能想要访问引用的静态字段和已完成方法的另一个对象。 但是，您不能可靠地这样做，因为访问的对象可能已完成。  
  
> [!NOTE]
>  此规则的例外是<xref:System.Console>类，该类包含引用流对象的静态字段，但比较特殊，以便可以始终写入系统控制台中，即使在域卸载或系统关闭期间实现。  
  
 对象的完成方法中使用此方法，以确定是否正在卸载应用程序域包含的对象。 如果是这种情况，不能可靠地访问任何已完成方法，并由静态字段引用对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示加载到当前应用程序域的程序集是否是以完全信任方式执行的。</summary>
        <value>如果加载到当前应用程序域的程序集是以完全信任方式执行的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终返回`true`在桌面上运行的应用程序的默认应用程序域。 它将返回`false`已通过使用为沙盒应用程序域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法重载，除非应用程序域授予的权限是等效于完全信任。  
  
   
  
## Examples  
 下面的示例演示<xref:System.AppDomain.IsFullyTrusted%2A>属性和<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>具有完全受信任和部分受信任的应用程序域的属性。 完全受信任的应用程序域是应用程序的默认应用程序域。 通过创建部分受信任的应用程序域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法重载。  
  
 该示例使用`Worker`派生的类<xref:System.MarshalByRefObject>，因此它可以跨应用程序域边界封送。 此示例将创建`Worker`默认应用程序域中的对象。 然后，它调用`TestIsFullyTrusted`方法以显示属性值为应用程序域和加载到应用程序域的两个程序集： mscorlib 除外，它是.NET Framework 中，并将示例程序集的一部分。 应用程序域是完全受信任的因此这两个程序集是完全受信任。  
  
 该示例将创建另一个`Worker`对象在沙盒应用程序域并再次调用`TestIsFullyTrusted`方法。 Mscorlib 始终受信任的甚至在部分受信任的应用程序域中，但示例程序集是部分受信任。  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前应用程序域是否拥有一个为加载到该应用程序域的所有程序集授予的权限集。</summary>
        <value>如果当前应用程序域具有一组同构权限，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`true`使用创建的沙盒应用程序域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法重载。 沙盒应用程序域具有一组同构权限;即，相同的权限集授予的所有部分受信任程序集加载到应用程序域。 沙盒应用程序域 （可选） 有强名称的程序集设置，并改为使用完全信任运行此权限不受约束的列表。  
  
 完全受信任的代码可以使用<xref:System.AppDomain.PermissionSet%2A>属性来确定沙盒应用程序域的同构的授予集。  
  
 此属性也会返回`true`的默认应用程序域的桌面应用程序，因为该应用程序域将为所有程序集授予完全信任。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Reflection.Assembly" /> 加载到此应用程序域中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的图像的 <see cref="T:System.Reflection.Assembly" />，该图像包含已发出的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。  
  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何使用原始程序集加载。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要加载的程序集的对象。</param>
        <summary>在给定 <see cref="T:System.Reflection.AssemblyName" /> 的情况下加载 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 如果已加载请求的程序集的版本，则此方法返回加载的程序集，即使要求不同版本。  
  
 提供的部分程序集名称`assemblyRef`不建议。 （一个或多个区域性、 版本或公钥标记，则省略了部分名称。 对于采用字符串而不是重载<xref:System.Reflection.AssemblyName>对象，"MyAssembly，版本 = 1.0.0.0"是一个示例部分的名称和"MyAssembly，版本 = 1.0.0.0，区域性 = neutral，PublicKeyToken = 18ab3442da84b47"是一个示例的完整名称。)使用部分名称具有负面影响性能。 此外，部分程序集名称可以加载程序集从全局程序集缓存才应用程序基目录中的程序集的一个精确副本 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>)。  
  
 如果当前<xref:System.AppDomain>对象表示应用程序域`A`，并<xref:System.AppDomain.Load%2A>方法从应用程序域调用`B`，该程序集被加载到这两个应用程序域。 例如，下面的代码加载`MyAssembly`到新的应用程序域`ChildDomain`还到应用程序域执行的代码：  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 程序集加载到这两个域，因为<xref:System.Reflection.Assembly>不是派生自<xref:System.MarshalByRefObject>，并因此返回值的<xref:System.AppDomain.Load%2A>方法不能进行封送处理。 相反，公共语言运行时尝试将该程序集加载到调用应用程序域。 加载到两个应用程序域的程序集可能是不同的两个应用程序域的路径设置是否不同。  
  
> [!NOTE]
>  如果这两个<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>属性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>属性设置，第一次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，所返回的<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性)。 如果找不到该文件，<xref:System.Reflection.AssemblyName.CodeBase%2A>属性用来搜索该程序集。 如果使用找到的程序集<xref:System.Reflection.AssemblyName.CodeBase%2A>，与程序集匹配的显示名称。 如果匹配失败，<xref:System.IO.FileLoadException>引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <summary>在给定其显示名称的情况下加载 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">它能够访问的程序集的位置，如果该程序集不在本地。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</param>
        <param name="rawSymbolStore">
          <see langword="byte" /> 类型的数组，它包含表示程序集符号的原始字节。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的图像的 <see cref="T:System.Reflection.Assembly" />，该图像包含已发出的 <see cref="T:System.Reflection.Assembly" />。 还加载表示 <see cref="T:System.Reflection.Assembly" /> 的符号的原始字节。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。  
  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何使用原始程序集加载。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Net.WebPermission">用于读取不以"file://"开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要加载的程序集的对象。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>在给定 <see cref="T:System.Reflection.AssemblyName" /> 的情况下加载 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取路径不在窗体"file://"或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集的显示名称。 请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>在给定其显示名称的情况下加载 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取路径不在窗体"file://"或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <see langword="byte" /> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</param>
        <param name="rawSymbolStore">
          <see langword="byte" /> 类型的数组，它包含表示程序集符号的原始字节。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的图像的 <see cref="T:System.Reflection.Assembly" />，该图像包含已发出的 <see cref="T:System.Reflection.Assembly" />。 还加载表示 <see cref="T:System.Reflection.Assembly" /> 的符号的原始字节。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。  
  
 此方法应仅用于将程序集加载到当前应用程序域。 不能调用静态的互操作性调用方为方便起见提供此方法是<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。 若要将程序集加载到其他应用程序域中，使用一种方法如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。  
  
 普遍适用于此方法的所有重载的信息，请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何使用原始程序集加载。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。 未启用旧版 CAS 策略时，<paramref name="securityEvidence" /> 应为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问权限。 关联枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <permission cref="T:System.Net.WebPermission">用于读取路径不在窗体"file://"或"\\\UNC\dir\\"或"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否对当前进程启用应用程序域的 CPU 和内存监视。 一旦对进程启用了监视，则无法将其禁用。</summary>
        <value>如果启用监视，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这`static`属性 (`Shared`属性在 Visual Basic) 控制 CPU 和内存监视的进程中的所有应用程序域。  
  
 如果尝试将此属性设置为`false`、 一个<xref:System.ArgumentException>引发异常，即使该属性的当前值是`false`。  
  
 启用了监视后，可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>实例来监视 CPU 和内存使用的各个应用程序域的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前进程尝试将值 <see langword="false" /> 分配给该属性。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取上次回收后保留下来的，已知由当前应用程序域引用的字节数。</summary>
        <value>保留下来的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个垃圾回收中的更新统计信息。 但是，可确保仅在完整、 阻碍性回收; 后不准确也就是说，其中包括所有的生成和停止应用程序，同时集合的集合时发生。 例如，<xref:System.GC.Collect?displayProperty=nameWithType>方法重载执行完整、 阻碍性回收。 （并发集合在后台发生，并且不会阻止应用程序。）  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程中所有应用程序域的上次回收后保留下来的总字节数。</summary>
        <value>进程的保留下来的总字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完整、 阻碍性回收之后，字节数当前实时上保留该数字表示托管堆。 它应该报告的数量接近<xref:System.GC.GetTotalMemory%2A>方法。 暂时的回收之后, 该数字表示的字节数当前中实时保留暂时代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取自从创建应用程序域后由应用程序域进行的所有内存分配的总大小（以字节为单位，不扣除已回收的内存）。</summary>
        <value>所有内存分配的总大小。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取自从进程启动后所有线程在当前应用程序域中执行时所使用的总处理器时间。</summary>
        <value>当前应用程序域的总处理器时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 报告应用程序域的总时间包括该应用程序域中执行的进程中的每个线程所用的时间。  
  
 线程调用非托管代码程序仍与应用程序域，并执行应用程序域调用了报告的非托管的代码所用的处理器时间。  
  
 当线程受阻或处于休眠状态，它不会消耗处理器时间百分比。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取沙盒应用程序域的权限集。</summary>
        <value>沙盒应用程序域的权限集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用创建的沙盒应用程序域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法重载具有一组同构权限; 即，相同的权限集授予对所有部分受信任的程序集加载到应用程序域。 沙盒应用程序域 （可选） 有强名称的程序集设置，并改为使用完全信任运行此权限不受约束的列表。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当默认应用程序域的父进程存在时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>此事件可以执行终止活动，例如，关闭文件，释放存储空间等，在进程结束之前。  
  
 从.NET Framework 2.0 版开始，在每个注册事件处理程序的应用程序域中引发此事件。  
  
> [!NOTE]
>  总执行时间的所有<xref:System.AppDomain.ProcessExit>事件处理程序是有限的就像总执行时间的所有终结器被限制在进程关闭。 默认值为两秒。 非托管的主机可以通过调用来更改此执行时间[iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)方法替换[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)枚举值。  
  
 在.NET framework 1.0 和 1.1 版中，此事件是引发仅在默认应用程序域，且仅当在默认应用程序域中注册事件处理程序。  
  
 若要注册此事件的事件处理程序，必须具有所需的权限，或<xref:System.Security.SecurityException>引发。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当程序集的解析在仅限反射的上下文中失败时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在仅限反射上下文中，不会自动解析依赖项。 它们必须预加载或返回的此事件的处理程序。 程序集具有尚未加载到只反射上下文中的依赖项时，引发此事件。 通过指定缺少的依赖项<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性。 <xref:System.ResolveEventHandler>为此事件必须返回满足依赖项的程序集。 返回的程序集必须加载到仅反射上下文。  
  
> [!IMPORTANT]
>  要加载到仅反射上下文的程序集缺少的依赖项仅对引发此事件 (例如，通过使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法)。 如果找不到要加载的程序集，它不被引发。  
  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>属性返回请求无法解析的程序集加载的程序集。 了解请求的程序集的标识可能标识正确版本的依赖项，如果多个版本都提供很有用。 有关详情，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 对于此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性返回的程序集名称之前应用策略。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回已加载到应用程序域的只反射上下文中的程序集。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 对象数组，表示加载到应用程序域的只反射上下文中的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回已加载到仅反射上下文的程序集。 若要获取已加载的程序集的执行，请使用<xref:System.AppDomain.GetAssemblies%2A>方法。  
  
   
  
## Examples  
 下面的代码示例将插入的执行上下文，然后再到只反射上下文中加载的 System.dll 程序集。 <xref:System.AppDomain.GetAssemblies%2A>和<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>方法用于显示的程序集加载到每个上下文。  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">尝试对已卸载的应用程序域进行操作。</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取基目录下的路径，在此程序集冲突解决程序应探测专用程序集。</summary>
        <value>基目录下的路径，在此程序集冲突解决程序应探测专用程序集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 专用程序集部署在与应用程序相同的目录结构中。 如果通过指定的路径<xref:System.AppDomain.RelativeSearchPath%2A>属性不是在<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>，它将被忽略。  
  
 此属性返回的值设置使用<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当资源解析因资源不是程序集中的有效链接资源或嵌入资源而失败时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler>为此事件可以尝试查找包含该资源的程序集并将其返回。  
  
> [!IMPORTANT]
>  如果解析失败，因为没有文件可以找到有效的链接资源，不引发此事件。 如果找不到清单资源流，但它不会引发如果找不到单独的资源键，则将引发该事件。  
  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>属性包含请求的资源的程序集。 有关详情，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要注册此事件的事件处理程序，必须具有所需的权限，或<xref:System.Security.SecurityException>引发。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">安全策略级别。</param>
        <summary>为此应用程序域确定安全策略级别。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加载到程序集之前调用此方法<xref:System.AppDomain>使安全策略产生影响。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomain.SetAppDomainPolicy%2A>方法设置的应用程序域的安全策略级别。  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">已经设置了安全策略级别。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">到卷影副本位置的完全限定路径。</param>
        <summary>确定指定目录路径为对程序集进行影像复制的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果缓存路径将被忽略<xref:System.AppDomainSetup.ApplicationName%2A>未设置属性。 请参阅 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 属性。  
  
 卷影复制的详细信息请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为应用程序域属性分配值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要创建或更改的用户定义应用程序域属性的名称。</param>
        <param name="data">该属性的值。</param>
        <summary>为指定的应用程序域属性分配指定值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来插入项时，或修改名称数据对描述此实例的属性的内部缓存中的条目的值<xref:System.AppDomain>。  
  
 该缓存自动包含预定义的系统项的创建应用程序域时插入。 无法插入或使用此方法修改系统项。 尝试来修改系统条目的方法调用不起任何作用;该方法不会引发异常。 您可以检查与系统项的值<xref:System.AppDomain.GetData%2A>方法或等效<xref:System.AppDomainSetup>属性中所述<xref:System.AppDomain.GetData%2A>。  
  
 可以为的值调用此方法以设置评估供应"REGEX_DEFAULT_MATCH_TIMEOUT"正则表达式模式的默认超时间隔的值`name`自变量和一个<xref:System.TimeSpan>值，该值表示超时间隔的值为`data`参数。 此外可以插入或修改使用此方法的用户定义名称数据对和检查它们的值与<xref:System.AppDomain.GetData%2A>方法。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>方法来创建新的值对。 该示例然后使用<xref:System.AppDomain.GetData%2A>方法来检索值，并将其显示到控制台。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">要创建或更改的用户定义应用程序域属性的名称。</param>
        <param name="data">该属性的值。</param>
        <param name="permission">检索属性时调用方需要具有的权限。</param>
        <summary>将指定值分配给指定应用程序域属性，检索该属性时要求调用方具有指定权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于插入或修改中描述的应用程序域的属性的名称/数据对的内部缓存自己用户定义的条目。 当您插入一个条目时，可以指定权限请求来检索项时，强制执行。此外，可以调用此方法以设置评估供应"REGEX_DEFAULT_MATCH_TIMEOUT"正则表达式模式的默认超时间隔的值的值作为`name`自变量和一个<xref:System.TimeSpan>值，该值表示超时间隔的值作为`data`参数。  
  
 此方法不能用于将安全要求分配给系统定义的属性字符串。  
  
 该缓存自动包含预定义的系统项的创建应用程序域时插入。 无法插入或使用此方法修改系统项。 尝试来修改系统条目的方法调用不起任何作用;该方法不会引发异常。 您可以检查与系统项的值<xref:System.AppDomain.GetData%2A>方法或等效<xref:System.AppDomainSetup>属性中的备注部分所述<xref:System.AppDomain.GetData%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> 指定系统定义的属性字符串，并且 <paramref name="permission" /> 不为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">完全限定路径，是存储动态程序集的子目录的基目录。</param>
        <summary>建立指定的目录路径，作为存储和访问动态生成的文件的子目录的基目录。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法设置<xref:System.AppDomainSetup.DynamicBase%2A>属性的内部<xref:System.AppDomainSetup>与此实例关联。  
  
   
  
## Examples  
 此方法现已过时，并且不应使用新的开发。 下面的示例演示如何使用非过时的替代项，<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>属性。 此示例的说明，请参阅<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>属性或<xref:System.AppDomain.DynamicDirectory%2A>属性。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">
          <see cref="T:System.Security.Principal.PrincipalPolicy" /> 值之一，指定要附加到线程的主体对象类型。</param>
        <summary>指定在此应用程序域中执行时如果线程尝试绑定到用户，用户和标识对象应如何附加到该线程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此值才有效，如果在使用前设置<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性。 例如，如果您设置<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>到给定的主体 （例如，泛型主体），然后使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法以设置<xref:System.Security.Principal.PrincipalPolicy>到<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>，当前主体将保留泛型主体。  
  
   
  
## Examples  
 下面的示例演示使用的线程的影响<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以更改应用程序域的主体的策略。 它还显示使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>方法，以更改可用于将附加到应用程序域中线程的主体。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">能够操作主体对象。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>打开影像复制功能。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 卷影复制的详细信息，请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 此方法现已过时，并且不应使用新的开发。  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">目录名列表，各名称用分号隔开。</param>
        <summary>确定指定目录路径为要进行影像复制的程序集的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，卷影副本包含通过探测所发现的所有程序集。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法将卷影副本限制为指定的目录中的程序集`path`。  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A>方法未指定要在其中搜索的程序集的其他目录。 要进行卷影复制程序集必须已经位于搜索路径，例如下<xref:System.AppDomain.BaseDirectory%2A>。 <xref:System.AppDomain.SetShadowCopyPath%2A>方法指定的搜索路径均有资格将卷影复制。  
  
 此方法设置<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>属性的内部<xref:System.AppDomainSetup>与此实例关联。  
  
 卷影复制的详细信息，请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
   
  
## Examples  
 此方法现已过时，并且不应使用新的开发。  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">要附加到线程的主体对象。</param>
        <summary>设置在以下情况下要附加到线程的默认主体对象，即当线程在此应用程序域中执行时，如果线程尝试绑定到主体这种情况。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>方法，以更改可用于将附加到应用程序域中执行的线程的主体。 它还演示了使用的线程的影响<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以更改应用程序域的主体的策略。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">已经设置了线程用户。</exception>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">能够操作主体对象。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的应用程序域配置信息。</summary>
        <value>应用程序域初始化信息。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序域是否配置为影像副本文件的指示。</summary>
        <value>如果应用程序域配置为卷影副本文件，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>并[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">在卸载的应用程序域上尝试该操作。</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类到从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetIDsOfNames`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">接收一个指针，指向请求的类型信息对象。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类到从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfo`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类到从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfoCount`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释参数的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错自变量的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类到从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::Invoke`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个字符串表示，包含应用程序域友好名称和任意上下文策略。</summary>
        <returns>一个字符串，通过连接字符串“Name:”、应用程序域的友好名称以及上下文策略的字符串表示或字符串“There are no context policies”而成。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例显示的返回值<xref:System.AppDomain.ToString%2A>方法。  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">当前 <see cref="T:System.AppDomain" /> 表示的应用程序域已卸载。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在对类型的解析失败时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve>事件发生时公共语言运行时不能确定程序集，可以创建请求的类型。 如果类型定义动态程序集中，或在动态程序集未定义类型，但运行时不知道该类型定义中的程序集，这可能发生。 后一种情况可能发生时<xref:System.Type.GetType%2A?displayProperty=nameWithType>调用具有程序集名称不受限定的类型名称。  
  
 <xref:System.ResolveEventHandler>为此事件可以尝试查找并创建类型。  
  
 但是，<xref:System.AppDomain.TypeResolve>事件，则不会运行时知道不能以查找特定程序集中的类型。 例如，如果因为运行时知道类型不能动态地添加到静态程序集未在静态程序集中找到的类型不会不会发生此事件。  
  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，则<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>属性包含请求的类型的程序集。 有关详情，请参阅<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。  
  
 若要注册此事件的事件处理程序，必须具有所需的权限，或<xref:System.Security.SecurityException>引发。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.AppDomain.TypeResolve>事件。  
  
 有关运行此代码示例，必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当某个异常未被捕获时出现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件提供通知的未捕获的异常。 它允许应用程序的系统默认处理程序报告给用户异常和终止应用程序之前记录有关异常的信息。 如果应用程序的状态的足够信息不可用，可能会采取其他措施，例如保存程序便于以后恢复数据。 建议谨慎行事，因为未处理异常时，可能会损坏程序数据。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 中，应用程序终止时调试选项报告和对用户引发此事件之前，而不是后。  
  
 可以在任何应用程序域中处理此事件。 但是，不一定会引发事件在发生异常的应用程序域中。 仅当没有找到适用的异常处理程序，因此可以引发该事件的第一个位置是在生成该线程的应用程序域中的线程的整个堆栈已被展开，会处理异常。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 中，仅用于启动的应用程序时，系统会创建默认应用程序域时发生此事件。 如果应用程序可创建其他应用程序域，在这些应用程序域中指定此事件的委托无效。  
  
 如果<xref:System.AppDomain.UnhandledException>默认应用程序域中处理事件，对于任何未经处理的异常在任何线程中，无论何种应用程序域启动的线程存在引发。 如果在具有的事件处理程序的应用程序域中启动线程<xref:System.AppDomain.UnhandledException>，该应用程序域中引发该事件。 如果该应用程序域不是默认应用程序域，并且在默认应用程序域中还有一个事件处理程序，将这两个应用程序域中引发事件。  
  
 例如，假设中启动线程应用程序域"AD1"调用"AD2"的应用程序域中的方法，并从那里调用的方法在应用程序域"AD3"，它将引发异常。 在其中的第一个应用程序域<xref:System.AppDomain.UnhandledException>可以引发事件是"AD1"。 如果该应用程序域不是默认应用程序域，那么还可以在默认应用程序域中引发该事件。  
  
> [!NOTE]
>  公共语言运行时挂起时的事件处理程序的线程中止<xref:System.AppDomain.UnhandledException>执行事件。  
  
 如果事件处理程序具有<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>属性带有相应标志的事件处理程序被视为受约束的执行区域。  
  
 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，不会引发此事件的损坏状态的进程，如堆栈溢出，或者是访问冲突，除非事件处理程序是安全关键的并且具有异常<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。  
  
 在.NET framework 1.0 和 1.1 版中，在主应用程序线程以外的线程中出现未经处理的异常由运行时捕获，并因此不会导致应用程序终止。 因此，很可能<xref:System.AppDomain.UnhandledException>不终止的应用程序的情况下引发的事件。 从.NET Framework 2.0 版开始，此对子子线程中未经处理的异常已被移除，因为这种无提示失败的累积效应包含性能降低、 损坏的数据和锁定，所有这些非常难以调试。 有关详细信息，包括一系列情况下在其中运行时不会终止，请参阅[托管线程异常](~/docs/standard/threading/exceptions-in-managed-threads.md)。  
  
 若要注册此事件的事件处理程序，必须具有所需的权限，或<xref:System.Security.SecurityException>引发。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
## <a name="other-events-for-unhandled-exceptions"></a>未经处理的异常的其他事件  
 对于某些应用程序模型，<xref:System.AppDomain.UnhandledException>主应用程序线程中未经处理的异常时，可以由其他事件被抢占的事件。  
  
 使用 Windows 窗体的应用程序中未经处理的异常中的主应用程序线程原因<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>事件被引发。 如果此事件的处理，默认行为是未处理的异常不会终止该应用程序，尽管应用程序将继续处于未知状态。 在这种情况下，<xref:System.AppDomain.UnhandledException>不会引发事件。 可以更改此行为，通过使用应用程序配置文件，或通过使用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>方法以将模式更改为<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>之前<xref:System.Windows.Forms.Application.ThreadException>挂接事件处理程序。 这仅适用于主应用程序线程。 <xref:System.AppDomain.UnhandledException>的未经处理的异常引发在其他线程中引发事件。  
  
 从 Microsoft Visual Studio 2005 开始，Visual Basic 应用程序框架提供的主应用程序线程中未经处理异常的另一个事件。 请参阅<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>事件。 此事件有一个事件参数对象使用的事件参数对象与同名<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>，但具有不同的属性。 具体而言，此事件参数对象具有<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>属性，它允许应用程序继续运行，将忽略未处理的异常 （和应用程序处于未知状态）。 在这种情况下，<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>不会引发事件。  
  
   
  
## Examples  
 以下示例演示了<xref:System.AppDomain.UnhandledException>事件。 它定义了一个事件处理程序`MyHandler`，每当在默认应用程序域中引发未经处理的异常时调用。 然后，它会引发两种例外情况。 第一个由**try/catch**块。 第二个是未经处理并调用`MyHandle`例程之前在应用程序终止。  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">要卸载的应用程序域。</param>
        <summary>卸载指定的应用程序域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 2.0 版中没有线程专用于卸载应用程序域。 这提高了可靠性，尤其是在.NET Framework 承载。 当线程调用<xref:System.AppDomain.Unload%2A>，目标域做标记以进行卸载。 专用的线程尝试卸载域，并在域中的所有线程都将立即都中止。 如果一个线程不会中止，例如因为它正在执行非托管的代码，或因为正在执行它`finally`块中的，然后在一段时间后<xref:System.CannotUnloadAppDomainException>最初调用线程中引发<xref:System.AppDomain.Unload%2A>。 如果无法最终中止的线程结束时，目标域不是卸载。 因此，在.NET Framework 2.0 版`domain`不能保证卸载，因为它可能无法终止正在执行的线程。  
  
> [!NOTE]
>  在某些情况下，调用<xref:System.AppDomain.Unload%2A>会导致立即<xref:System.CannotUnloadAppDomainException>，例如它在终结器调用。  
  
 中的线程`domain`使用终止<xref:System.Threading.Thread.Abort%2A>方法，将引发<xref:System.Threading.ThreadAbortException>线程中。 尽管立即终止线程，但它仍可以继续执行不可预测中的时间量`finally`子句。  
  
## <a name="version-compatibility"></a>版本兼容性  
 .NET Framework 版本 1.0 和 1.1 中，如果线程的调用中<xref:System.AppDomain.Unload%2A>是否正在`domain`，另一个线程开始执行卸载操作。 如果`domain`不能卸载<xref:System.CannotUnloadAppDomainException>不在原始线程上调用，该线程中引发<xref:System.AppDomain.Unload%2A>。 但是，如果调用线程<xref:System.AppDomain.Unload%2A>外部运行`domain`，线程都会收到异常。  
  
   
  
## Examples  
 下面的代码示例演示如何卸载应用程序域。  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> 未能卸载。</exception>
        <exception cref="T:System.Exception">在卸载进程期间出错。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要添加此事件的事件处理程序。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
  </Members>
</Type>