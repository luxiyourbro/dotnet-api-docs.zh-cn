<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="018e5371bd85cbb8ad0cda7ecba314155412268d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51896594" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示委托，委托是一种数据结构，它引用静态方法或引用类实例及该类的实例方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate>类是委托类型的基类。 但是，只有系统和编译器可以派生自显式<xref:System.Delegate>类或从<xref:System.MulticastDelegate>类。 此外，还不允许从委托类型派生新类型。 <xref:System.Delegate>类不被视为是委托类型; 它是用于委托类型派生一个类。  
  
 大多数语言实现`delegate`关键字，并为这些语言的编译器可派生自<xref:System.MulticastDelegate>类; 因此，用户应使用`delegate`语言提供的关键字。  
  
> [!NOTE]
>  公共语言运行时提供`Invoke`对于每个委托类型，具有相同的签名与委托的方法。 您不需要显式调用此方法，从 C#、 Visual Basic 或 Visual c + +，因为编译器会自动调用。 `Invoke`方法可在[反射](~/docs/framework/reflection-and-codedom/reflection.md)时想要查找的委托类型签名。  
  
 公共语言运行时提供每个委托类型与`BeginInvoke`和`EndInvoke`方法，以便能够异步调用的委托。 有关这些方法的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
 委托类型的声明建立指定的一个或多个方法签名的协定。 委托是所引用的委托类型的实例：  
  
-   类型和可分配给该类型的目标对象的实例方法。  
  
-   具有隐藏的类型的实例方法`this`参数在形参表中公开。 委托被称为是一个委托，它打开的实例。  
  
-   一种静态方法。  
  
-   静态方法，并且可分配给该方法的第一个参数的目标对象。 委托被称为封闭式其第一个参数。  
  
 有关绑定的委托的详细信息，请参阅<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 中，委托可以表示一种方法，仅当该方法的签名与委托类型指定的签名完全匹配。 因此，仅第一个和第三个项目符号前面的列表中都受支持，并且第一项要求的类型完全匹配项。  
  
 委托时委托表示实例方法通过其第一个参数 （最常见的情况） 关闭时，将对方法的入口点的引用和对一个名为目标，这是赋给定义的类型的类型的对象的引用存储方法。 当委托表示打开的实例方法时，它存储到该方法的入口点的引用。 委托签名必须包括隐藏`this`参数在其形参表; 在这种情况下，委托不具有对目标对象的引用和调用委托时，必须提供目标对象。  
  
 当委托表示静态方法时，该委托存储到该方法的入口点的引用。 当委托表示静态方法通过其第一个参数已关闭时，委托将存储对方法的入口点的引用和对可分配给该方法的第一个参数的类型的目标对象的引用。 当调用委托时，静态方法的第一个参数接收目标对象。  
  
 委托的调用列表是列表的一个有序中的每个元素调用一个委托所表示的方法的委托。 调用列表可以包含重复的方法。 在调用过程的调用列表中出现的顺序调用的方法。 尝试调用其调用列表; 中的每个方法的委托对于每个时间它们会显示在调用列表后，会调用重复项。 委托是固定不变;创建后，委托的调用列表将不会更改。  
  
 委托被引用的多路广播，或可组合，因为委托可以调用一个或多个方法，并且可以用在组合操作。  
  
 合并操作，如<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>，不会更改现有委托。 相反，此类操作返回包含结果的操作，一个不变的委托，一个新委托或`null`。 合并操作将返回`null`时操作的结果是不引用至少一种方法的委托。 合并操作，返回未更改的委托时请求的操作不起作用。  
  
> [!NOTE]
>  托管语言使用<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>方法来实现委托操作。 示例包括`AddHandler`和`RemoveHandler`在 Visual Basic 中的语句和上的 + = 和-= 运算符委托在 C# 中的类型。  
  
 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，泛型委托类型可以具有 variant 类型参数。 逆变类型参数可以用作参数类型的委托，协变类型参数可以用作返回类型。 此功能允许泛型委托类型相同的泛型类型定义，如中所述为赋值兼容其类型参数是引用类型具有继承关系，如果从[协方差和逆变](~/docs/standard/generics/covariance-and-contravariance.md)。  
  
> [!NOTE]
>  赋值兼容的泛型委托的变体由于并不一定是可组合。 若要可组合，类型必须完全匹配。 例如，假设一个名为`Derived`派生的类名为`Base`。 类型的委托`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以分配给类型的变量的`Action<Derived>`，但不能组合两个委托，因为类型不完全匹配。  
  
 如果调用的方法引发异常，该方法停止执行、 异常传递回委托，调用方和剩余方法的调用列表中不会调用。 在调用方中捕获该异常不会更改此行为。  
  
 当由委托调用的方法的签名包括返回值时，委托的调用列表中返回的最后一个元素的返回值。 如果签名包括按引用传递的参数，参数的最终值将按顺序执行并更新参数的值的调用列表中每个方法的结果。  
  
 最接近的 C 或 c + + 中是委托的函数指针。 委托可以表示的静态方法或实例方法。 当委托表示实例方法时，该委托存储不仅对方法的入口点，而且还对类实例的引用。 函数与指针不同，委托是面向对象和类型安全的。  
  
   
  
## Examples  
 下面的示例演示如何定义一个名为的委托`myMethodDelegate`。 实例方法和嵌套的静态方法来创建此委托的实例`mySampleClass`类。 实例方法的委托需要的实例`mySampleClass`。 `mySampleClass`实例保存在名为`mySC`。  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">使用异步方式调用同步方法</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">委托（C# 编程指南）</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">委托 (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">如何：定义和使用委托 (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">处理和引发事件</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化一个新委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">类实例，委托对其调用 <c>method</c>。</param>
        <param name="method">委托表示的实例方法的名称。</param>
        <summary>初始化一个委托，该委托对指定的类实例调用指定的实例方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能在应用程序代码中使用此构造函数。 若要通过指定实例方法的名称创建一个委托，使用的重载<xref:System.Delegate.CreateDelegate%2A>指定方法名称和目标对象的方法。 例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>方法重载创建具有指定名称的实例方法的委托。  
  
 此构造函数实例只方法创建委托。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">绑定到目标方法时出错。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">表示定义 <c>method</c> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托表示的静态方法的名称。</param>
        <summary>初始化一个委托，该委托从指定的类调用指定的静态方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能在应用程序代码中使用此构造函数。 若要指定静态方法的名称创建一个委托，使用的重载<xref:System.Delegate.CreateDelegate%2A>指定方法名称，但未指定目标对象的方法。 例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>方法重载创建具有指定名称的方法的静态委托。  
  
 此构造函数创建只为静态方法的委托。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="target" /> 表示开放式泛型类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建委托的浅表副本。</summary>
        <returns>委托的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 克隆具有相同<xref:System.Type>，与原始委托的目标、 方法和调用列表。  
  
 浅表副本创建与原始对象相同的类型的新实例，然后将复制的原始对象的非静态字段。 如果此字段为值类型，则执行字段的按位复制。 如果此字段为引用类型，则复制引用，但被引用的对象;因此，在原始对象的引用和克隆中的引用点对同一对象。 与此相反，对象的深层副本会复制所有内容直接或间接引用的对象中的字段。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的多路广播（可组合）委托的调用列表连接起来。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">要组合的委托的数组。</param>
        <summary>将委托数组的调用列表连接在一起。</summary>
        <returns>新的委托，该委托的调用列表将 <paramref name="delegates" /> 数组中的委托的调用列表串联在一起。 如果 <paramref name="delegates" /> 为 <see langword="null" />，<paramref name="delegates" /> 包含零个元素，或 <paramref name="delegates" /> 中的每个条目均为 <see langword="null" />，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`delegates`数组包含的条目`null`，这些条目将被忽略。  
  
 调用列表可以包含重复项;它是指同一对象上的相同方法的条目。  
  
> [!NOTE]
>  赋值兼容的泛型委托的变体由于并不一定是可组合。 若要可组合，类型必须完全匹配。 例如，假设一个名为`Derived`派生的类名为`Base`。 类型的委托`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以分配给类型的变量`Action<Derived>`，如中所述[协变和逆变](~/docs/standard/generics/covariance-and-contravariance.md)，但不能组合两个委托，因为此操作类型不完全匹配。  
  
 <xref:System.Delegate.Combine%2A> 可用于创建调用多个方法的时间事件发生的事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">不是所有 <paramref name="delegates" /> 中的非 null 项都是同一委托类型的实例。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">最先出现其调用列表的委托。</param>
        <param name="b">最后出现其调用列表的委托。</param>
        <summary>将两个委托的调用列表连接在一起。</summary>
        <returns>新的委托，它的调用列表将 <paramref name="a" /> 和 <paramref name="b" /> 的调用列表按该顺序连接在一起。 如果 <paramref name="b" /> 为 <see langword="null" />，则返回 <paramref name="a" />；如果 <paramref name="a" /> 为 null 引用，则返回 <paramref name="b" />；如果 <paramref name="a" /> 和 <paramref name="b" /> 均为 null 引用，则返回 null 引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用列表可以包含重复项;它是指同一对象上的相同方法的条目。  
  
> [!NOTE]
>  赋值兼容的泛型委托的变体由于并不一定是可组合。 若要可组合，类型必须完全匹配。 例如，假设一个名为`Derived`派生的类名为`Base`。 类型的委托`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以分配给类型的变量`Action<Derived>`，如中所述[协变和逆变](~/docs/standard/generics/covariance-and-contravariance.md)，但不能组合两个委托，因为此操作类型不完全匹配。  
  
 <xref:System.Delegate.Combine%2A> 可用于创建调用多个方法的时间事件发生的事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="a" /> 和 <paramref name="b" /> 均不为 <see langword="null" />，且 <paramref name="a" /> 和 <paramref name="b" /> 不是相同委托类型的实例。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">多路广播（可组合）委托，其调用列表要追加到当前多路广播（可组合）委托的调用列表的结尾。</param>
        <summary>将指定多路广播（可组合）委托和当前多路广播（可组合）委托的调用列表连接起来。</summary>
        <returns>新的多路广播（可组合）委托，其调用列表将当前多路广播（可组合）委托的调用列表和 <paramref name="d" /> 的调用列表连接在一起；或者如果 <paramref name="d" /> 为 <see langword="null" />，则返回当前多路广播（可组合）委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于当前委托是多路广播 （可组合）。  
  
 当前实现只需引发<xref:System.MulticastNotSupportedException>。  
  
 调用列表可以包含重复项;它是指同一对象上的相同方法的条目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">始终引发。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建指定类型的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。 .NET Framework 1.0 和 1.1 版中仅支持静态方法。</param>
        <summary>创建指定类型的委托以表示指定的静态方法。</summary>
        <returns>表示指定静态方法的指定类型的委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 1.0 和 1.1 版中，此方法的重载创建只为静态方法的委托。 在.NET Framework 2.0 版中，此方法的重载还可以创建打开实例方法的委托;即，显式提供的隐藏第一个参数的委托实例方法。 有关的详细说明，请参阅更多常规<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法重载，它允许您创建的打开或关闭实例或静态方法的委托的所有组合并根据需要指定第一个参数。  
  
> [!NOTE]
>  此方法应使用重载时委托未关闭通过其第一个参数，因为它在这种情况下是某种程度上更快。  
  
 此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载并指定`true`为`throwOnBindFailure`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 在.NET Framework 2.0 版中，参数类型和使用此方法的重载创建委托的返回类型必须是与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。 这表示在.NET Framework 版本 1.0 和 1.1 中，类型必须完全匹配的绑定行为是放宽了。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示两种类型的委托可以使用此方法的重载来创建： 打开通过实例方法，并通过静态方法。  
  
 第二个代码示例演示了兼容的参数类型和返回类型。  
  
 **示例 1**  
  
 下面的代码示例演示了可以使用此重载创建委托的两种方法<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有两个重载<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，但不是第一个参数; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。 此代码示例使用两个重载。  
  
 此示例声明一个类`C`静态方法一起`M2`和实例方法`M1`，和两个委托类型：`D1`的实例`C`和一个字符串，和`D2`采用一个字符串。  
  
 名为第二个类`Example`包含创建委托的代码。  
  
-   类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。 当调用委托时，必须传递实例。  
  
-   类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **示例 2**  
  
 下面的代码示例演示了兼容性的参数类型和返回类型。  
  
 代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。 派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。 代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。  
  
 代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。 该方法可以绑定到委托，因为：  
  
-   委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。  
  
-   返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。  
  
 代码示例会生成任何输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="method" /> 不是一种静态方法，并且 .NET Framework 版本为 1.0 或 1.1。  
  
或 
 无法绑定 <paramref name="method" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="firstArgument">委托要绑定到的对象，若要将 <c>method</c> 作为 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />），则为 <see langword="null" />。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <summary>使用指定的第一个参数创建指定类型的委托，该委托表示指定的静态方法或实例方法。</summary>
        <returns>指定类型的委托，表示指定的静态或实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载并指定`true`为`throwOnBindFailure`。 这两个重载提供最灵活的方式来创建委托。 若要创建委托的静态或实例方法，并可以选择指定的第一个参数，可以使用它们。  
  
> [!NOTE]
>  如果未提供第一个参数，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载，以更好的性能。  
  
 委托类型和方法必须具有兼容返回类型。 返回类型，即`method`必须是可赋值的返回类型为`type`。  
  
 如果`firstArgument`是提供，将它传递到`method`每次调用委托时;`firstArgument`称为绑定到委托，委托是说要关闭通过其第一个参数。 如果`method`是`static`(`Shared`在 Visual Basic 中)，则参数调用委托时提供的列表包括除第一个; 以外的所有参数，如果`method`然后是实例方法，`firstArgument`传递到隐藏的实例参数 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。  
  
 如果`firstArgument`提供，则第一个参数`method`必须是引用类型，和`firstArgument`必须与该类型兼容。  
  
> [!IMPORTANT]
>  如果`method`是`static`(`Shared`在 Visual Basic 中) 且其第一个参数的类型<xref:System.Object>或<xref:System.ValueType>，然后`firstArgument`可以是值类型。 在这种情况下`firstArgument`自动装箱。 自动装箱不会发生的任何其他参数，因为它将在 C# 或 Visual Basic 函数中调用。  
  
 如果`firstArgument`为 null 引用和`method`是实例方法，结果取决于委托类型的签名`type`和`method`:  
  
-   如果签名`type`显式包含的隐藏第一个参数`method`，则委托被称为来表示打开的实例方法。 当调用委托时，参数列表中的第一个参数传递到隐藏的实例参数`method`。  
  
-   如果签名的`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托称为关闭通过空引用。 调用委托就像不是特别有用的办法就的 null 实例上调用实例方法。  
  
 如果`firstArgument`为 null 引用和`method`是静态的结果依赖于委托类型的签名`type`和`method`:  
  
-   如果签名`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托被称为来表示开放的静态方法。 这是最常见的情况对静态方法。 在这种情况下，通过获取性能稍好<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。  
  
-   如果签名`type`开头的第二个参数`method`和参数类型的其余部分是兼容的设备，然后委托被称为封闭式 null 引用。 调用委托时，将为 null 引用传递到的第一个参数`method`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 参数类型和委托的返回类型必须与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>确定方法委托可以表示  
 另一个有用方法看作的灵活性方面的此重载的<xref:System.Delegate.CreateDelegate%2A>是任何给定的委托可以表示四个不同的方法签名和方法的类型 （静态和实例） 的组合。 委托类型，请考虑`D`带有一个自变量类型的`C`。 以下介绍的方法`D`可以表示，因为它必须匹配在所有情况下忽略的返回类型：  
  
-   `D` 可以表示有且只有一个参数类型的任何实例方法`C`，无论实例方法属于哪种类型。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`是类型的实例`method`属于，和结果委托所说，通过该实例关闭。 (一般而言，`D`如果还可以通过 null 引用封闭`firstArgument`为 null 引用。)  
  
-   `D` 可以表示的实例方法`C`不带任何参数。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。 结果委托表示打开的实例方法，并且的实例`C`必须提供每次调用它时。  
  
-   `D` 可以表示采用一种参数类型的静态方法`C`，和方法可以属于任何类型。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。 结果委托表示开放的静态方法，并且的实例`C`必须提供每次调用它时。  
  
-   `D` 可以表示所属类型的静态方法`F`并且有两个参数，类型为`F`并键入`C`。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`的一个实例`F`。 生成委托表示静态方法，通过该实例的关闭`F`。 请注意，在这种情况其中`F`和`C`属于同一类型、 静态方法有两个参数为该类型。 (在这种情况下，`D`如果通过 null 引用封闭`firstArgument`为 null 引用。)  
  
   
  
## Examples  
 本部分包含三个代码示例。 第一个示例演示了四种类型的可创建的委托： 关闭通过实例方法，通过实例方法，打开的静态方法，通过打开和关闭通过静态方法。  
  
 第二个代码示例演示了兼容的参数类型和返回类型。  
  
 第三个代码示例定义一个委托类型，并演示可以表示委托类型的所有方法。  
  
 **示例 1**  
  
 下面的代码示例演示了可以使用此重载创建委托的四个方法<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。 此代码示例使用两个重载。  
  
 此示例声明一个类`C`使用静态方法`M2`和实例方法`M1`，和三个委托类型：`D1`的实例`C`和一个字符串，`D2`采用一个字符串，并`D3`没有参数。  
  
 名为第二个类`Example`包含创建委托的代码。  
  
-   类型的委托`D2`、 已关闭的实例`C`，为实例方法创建`M1`。 使用不同的字符串，显示的绑定的实例调用`C`始终使用。  
  
-   类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。 当调用委托时，必须传递实例。  
  
-   类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。  
  
-   最后，类型的委托`D3`、 已关闭的字符串上，为静态方法创建`M2`。 调用方法以显示其使用的绑定的字符串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **示例 2**  
  
 下面的代码示例演示了兼容性的参数类型和返回类型。  
  
> [!NOTE]
>  此代码示例使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。 使用其他重载采用<xref:System.Reflection.MethodInfo>类似。  
  
 代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。 派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。 代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。  
  
 代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。 该方法可以绑定到委托，因为：  
  
-   委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。  
  
-   返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。  
  
 代码示例会生成任何输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **示例 3**  
  
 下面的代码示例显示了所有方法的单个的委托类型可以表示使用<xref:System.Delegate.CreateDelegate%2A>方法来创建委托。  
  
> [!NOTE]
>  有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。 此代码示例使用两个重载。  
  
 代码示例定义两个类：`C`并`F`，和委托类型`D`带有一个自变量类型的`C`。 类具有匹配的静态和实例方法`M1`， `M3`，并`M4`，和类`C`还具有实例方法`M2`不带任何参数。  
  
 名为第三个类`Example`包含创建委托的代码。  
  
-   委托实例创建方法`M1`类型的`C`并键入`F`; 每个已关闭对相应类型的实例。 方法`M1`类型的`C`显示`ID`属性的绑定实例和自变量。  
  
-   方法创建委托`M2`类型的`C`。 这是一个开放的实例的委托，委托自变量表示实例方法的隐藏第一个参数。 该方法具有任何其他参数。 调用，就好像静态方法。  
  
-   为静态方法创建委托`M3`类型的`C`并键入`F`; 这些是打开的静态委托。  
  
-   最后，为静态方法创建委托`M4`类型的`C`并键入`F`; 每个方法具有作为其第一个参数的声明类型和提供的类型的实例，因此委托关闭通过其第一个参数. 方法`M4`类型的`C`显示`ID`属性的绑定实例和自变量。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 无法绑定 <paramref name="method" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">类实例，对其调用 <c>method</c>。</param>
        <param name="method">委托要表示的实例方法的名称。</param>
        <summary>创建指定类型的委托，该委托表示要对指定的类实例调用的指定实例方法。</summary>
        <returns>指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建委托实例仅方法。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`false`有关`ignoreCase`并`true`为`throwOnBindFailure`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="method" /> 不是实例方法。  
  
或 
 无法绑定 <paramref name="method" />，例如因为找不到它。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure">如果无法绑定 <c>method</c> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用针对绑定失败的指定行为，创建用于表示指定静态方法的指定类型的委托。</summary>
        <returns>表示指定静态方法的指定类型的委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的重载可以创建开放的静态方法的委托并打开实例方法委托，公开的隐藏第一个参数的委托，它是实例方法。 有关的详细说明，请参阅更多常规<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载，它允许你创建的打开或关闭委托的所有组合实例或静态方法。  
  
> [!NOTE]
>  此方法应使用重载时委托未关闭通过其第一个参数，因为它在这种情况下是某种程度上更快。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 参数类型和委托的返回类型必须与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。  
  
> [!NOTE]
>  在.NET Framework 1.0 和 1.1 版中，类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示两种类型的委托可以使用此方法的重载来创建： 打开通过实例方法，并通过静态方法。  
  
 第二个代码示例演示了兼容的参数类型和返回类型。  
  
 **示例 1**  
  
 下面的代码示例演示了可以使用此重载创建委托的两种方法<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有两个重载<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，但不是第一个参数; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。 此代码示例使用两个重载。  
  
 此示例声明一个类`C`静态方法一起`M2`和实例方法`M1`，和两个委托类型：`D1`的实例`C`和一个字符串，和`D2`采用一个字符串。  
  
 名为第二个类`Example`包含创建委托的代码。  
  
-   类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。 当调用委托时，必须传递实例。  
  
-   类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **示例 2**  
  
 下面的代码示例演示了兼容性的参数类型和返回类型。  
  
> [!NOTE]
>  此代码示例使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。 使用其他重载采用<xref:System.Reflection.MethodInfo>类似。  
  
 代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。 派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。 代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。  
  
 代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。 该方法可以绑定到委托，因为：  
  
-   委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。  
  
-   返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。  
  
 代码示例会生成任何输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 无法绑定 <paramref name="method" />，且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">表示实现 <c>method</c> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托要表示的静态方法的名称。</param>
        <summary>创建指定类型的委托，该委托表示指定类的指定静态方法。</summary>
        <returns>指定类型的委托，该委托表示指定类的指定静态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建委托只为静态方法。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`false`有关`ignoreCase`并`true`为`throwOnBindFailure`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
或 
 <paramref name="target" /> 为开放式泛型类型。 也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。  
  
或 
 无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">一个 <see cref="T:System.Type" />，表示要创建的委托类型。</param>
        <param name="firstArgument">一个 <see cref="T:System.Object" />，它是委托表示的方法的第一个参数。 对于实例方法，它必须与实例类型兼容。</param>
        <param name="method">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="throwOnBindFailure">如果无法绑定 <c>method</c> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用指定的第一个自变量和针对绑定失败的指定行为，创建表示指定的静态方法或实例方法的指定类型的委托。</summary>
        <returns>表示指定静态方法或实例方法的指定类型的委托；如果 <paramref name="throwOnBindFailure" /> 为 <see langword="false" />，并且委托无法绑定到 <paramref name="method" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的重载和<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法重载，它总是引发绑定失败，提供最灵活的方式来创建委托。 可以使用它们来创建委托的静态或实例方法，无论第一个参数。  
  
> [!NOTE]
>  如果未提供第一个参数，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载，以更好的性能。  
  
 委托类型和方法必须具有兼容返回类型。 返回类型，即`method`必须是可赋值的返回类型为`type`。  
  
 如果`firstArgument`是提供，将它传递到`method`每次调用委托时;`firstArgument`称为绑定到委托，委托是说要关闭通过其第一个参数。 如果`method`是`static`(`Shared`在 Visual Basic 中)，则参数调用委托时提供的列表包括除第一个; 以外的所有参数，如果`method`然后是实例方法，`firstArgument`传递到隐藏的实例参数 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。  
  
 如果`firstArgument`提供，则第一个参数`method`必须是引用类型，和`firstArgument`必须与该类型兼容。  
  
> [!IMPORTANT]
>  如果`method`是`static`(`Shared`在 Visual Basic 中) 且其第一个参数的类型<xref:System.Object>或<xref:System.ValueType>，然后`firstArgument`可以是值类型。 在这种情况下`firstArgument`自动装箱。 自动装箱不会发生的任何其他参数，因为它将在 C# 或 Visual Basic 函数中调用。  
  
 如果`firstArgument`为 null 引用和`method`是实例方法，结果取决于委托类型的签名`type`和`method`:  
  
-   如果签名`type`显式包含的隐藏第一个参数`method`，则委托被称为来表示打开的实例方法。 当调用委托时，参数列表中的第一个参数传递到隐藏的实例参数`method`。  
  
-   如果签名的`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托称为关闭通过空引用。 调用委托就像不是特别有用的办法就的 null 实例上调用实例方法。  
  
 如果`firstArgument`为 null 引用和`method`是静态的结果依赖于委托类型的签名`type`和`method`:  
  
-   如果签名`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托被称为来表示开放的静态方法。 这是最常见的情况对静态方法。 在这种情况下，通过获取性能稍好<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载。  
  
-   如果签名`type`开头的第二个参数`method`和参数类型的其余部分是兼容的设备，然后委托被称为封闭式 null 引用。 调用委托时，将为 null 引用传递到的第一个参数`method`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
## <a name="compatible-parameter-types-and-return-type"></a>兼容的参数类型和返回类型  
 参数类型和委托的返回类型必须与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。  
  
> [!NOTE]
>  .NET Framework 1.0 和 1.1 版中的类型必须完全匹配。  
  
 如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。  
  
 同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。  
  
 例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>确定方法委托可以表示  
 另一个有用方法看作的灵活性方面的此重载的<xref:System.Delegate.CreateDelegate%2A>是任何给定的委托可以表示四个不同的方法签名和方法的类型 （静态和实例） 的组合。 委托类型，请考虑`D`带有一个自变量类型的`C`。 以下介绍的方法`D`可以表示，因为它必须匹配在所有情况下忽略的返回类型：  
  
-   `D` 可以表示有且只有一个参数类型的任何实例方法`C`，无论实例方法属于哪种类型。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`是类型的实例`method`属于，和结果委托所说，通过该实例关闭。 (一般而言，`D`如果还可以通过 null 引用封闭`firstArgument`是`null`。)  
  
-   `D` 可以表示的实例方法`C`不带任何参数。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。 结果委托表示打开的实例方法，并且的实例`C`必须提供每次调用它时。  
  
-   `D` 可以表示采用一种参数类型的静态方法`C`，和方法可以属于任何类型。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。 结果委托表示开放的静态方法，并且的实例`C`必须提供每次调用它时。  
  
-   `D` 可以表示所属类型的静态方法`F`并且有两个参数，类型为`F`并键入`C`。 当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`的一个实例`F`。 生成委托表示静态方法，通过该实例的关闭`F`。 请注意，在这种情况其中`F`和`C`属于同一类型、 静态方法有两个参数为该类型。 (在这种情况下，`D`如果通过 null 引用封闭`firstArgument`是`null`。)  
  
   
  
## Examples  
 本部分包含三个代码示例。 第一个示例演示了四种类型的可创建的委托： 关闭通过实例方法，通过实例方法，打开的静态方法，通过打开和关闭通过静态方法。  
  
 第二个代码示例演示了兼容的参数类型和返回类型。  
  
 第三个代码示例定义一个委托类型，并演示可以表示委托类型的所有方法。  
  
 **示例 1**  
  
 下面的代码示例演示了可以使用此重载创建委托的四个方法<xref:System.Delegate.CreateDelegate%2A>方法。  
  
> [!NOTE]
>  有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。 此代码示例使用两个重载。  
  
 此示例声明一个类`C`使用静态方法`M2`和实例方法`M1`，和三个委托类型：`D1`的实例`C`和一个字符串，`D2`采用一个字符串，并`D3`没有参数。  
  
 名为第二个类`Example`包含创建委托的代码。  
  
-   类型的委托`D2`、 已关闭的实例`C`，为实例方法创建`M1`。 使用不同的字符串，显示的绑定的实例调用`C`始终使用。  
  
-   类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。 当调用委托时，必须传递实例。  
  
-   类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。  
  
-   最后，类型的委托`D3`、 已关闭的字符串上，为静态方法创建`M2`。 调用方法以显示其使用的绑定的字符串。  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **示例 2**  
  
 下面的代码示例演示了兼容性的参数类型和返回类型。  
  
> [!NOTE]
>  此代码示例使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。 使用其他重载采用<xref:System.Reflection.MethodInfo>类似。  
  
 代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。 派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。 代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。  
  
 代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。 该方法可以绑定到委托，因为：  
  
-   委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。  
  
-   返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。  
  
 代码示例会生成任何输出。  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **示例 3**  
  
 下面的代码示例显示了一个委托类型可以表示的所有方法。  
  
> [!NOTE]
>  有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。 此代码示例使用两个重载。  
  
 代码示例定义两个类：`C`并`F`，和委托类型`D`带有一个自变量类型的`C`。 类具有匹配的静态和实例方法`M1`， `M3`，并`M4`，和类`C`还具有实例方法`M2`不带任何参数。  
  
 名为第三个类`Example`包含创建委托的代码。  
  
-   委托实例创建方法`M1`类型的`C`并键入`F`; 每个已关闭对相应类型的实例。 方法`M1`类型的`C`显示`ID`属性的绑定实例和自变量。  
  
-   方法创建委托`M2`类型的`C`。 这是一个开放的实例的委托，委托自变量表示实例方法的隐藏第一个参数。 该方法具有任何其他参数。  
  
-   为静态方法创建委托`M3`类型的`C`并键入`F`; 这些是打开的静态委托。  
  
-   最后，为静态方法创建委托`M4`类型的`C`并键入`F`; 每个方法具有作为其第一个参数的声明类型和提供的类型的实例，因此委托关闭通过其第一个参数. 方法`M4`类型的`C`显示`ID`属性的绑定实例和自变量。  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 无法绑定 <paramref name="method" />，且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">类实例，对其调用 <c>method</c>。</param>
        <param name="method">委托要表示的实例方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <summary>创建指定类型的委托，该委托表示要按指定的大小写敏感度对指定类实例调用的指定实例方法。</summary>
        <returns>指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建委托实例仅方法。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`true`为`throwOnBindFailure`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="method" /> 不是实例方法。  
  
或 
 无法绑定 <paramref name="method" />，例如因为找不到它。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">表示实现 <c>method</c> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托要表示的静态方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <summary>使用用于指定是否区分大小写的值创建指定类型的委托，该委托表示指定类的指定静态方法。</summary>
        <returns>指定类型的委托，该委托表示指定类的指定静态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建委托只为静态方法。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`true`为`throwOnBindFailure`。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
或 
 <paramref name="target" /> 为开放式泛型类型。 也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。  
  
或 
 无法绑定 <paramref name="method" />，例如因为找不到它。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">类实例，对其调用 <c>method</c>。</param>
        <param name="method">委托要表示的实例方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <param name="throwOnBindFailure">如果无法绑定 <c>method</c> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用用于指定是否区分大小写的值和针对绑定失败的指定行为，创建指定类型的委托，该委托表示要对指定类实例调用的指定实例方法。</summary>
        <returns>指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建委托实例仅方法。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="method" /> 不是实例方法。  
  
或 
 无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要创建的委托的 <see cref="T:System.Type" />。</param>
        <param name="target">表示实现 <c>method</c> 的类的 <see cref="T:System.Type" />。</param>
        <param name="method">委托要表示的静态方法的名称。</param>
        <param name="ignoreCase">一个布尔值，它指示在比较方法名称时是否忽略大小写。</param>
        <param name="throwOnBindFailure">如果无法绑定 <c>method</c> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用用于指定是否区分大小写的值和针对绑定失败的指定行为，创建指定类型的委托，该委托表示指定类的指定静态方法。</summary>
        <returns>指定类型的委托，该委托表示指定类的指定静态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建委托只为静态方法。 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。  
  
或 
 <paramref name="target" /> 为 <see langword="null" />。  
  
或 
 <paramref name="method" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。  
  
或 
 <paramref name="type" /> 不是 <see langword="RuntimeType" />。 请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。  
  
或 
 <paramref name="target" /> 不是 <see langword="RuntimeType" />。  
  
或 
 <paramref name="target" /> 为开放式泛型类型。 也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。  
  
或 
 <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。  
  
或 
 无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</exception>
        <exception cref="T:System.MethodAccessException">调用方没有访问 <paramref name="method" /> 所必需的权限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">作为自变量传递给当前委托所表示的方法的对象数组。  
  
或 
 如果当前委托所表示的方法不需要参数，则为 <see langword="null" />。</param>
        <summary>动态调用（后期绑定）由当前委托所表示的方法。</summary>
        <returns>委托所表示的方法返回的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用 <xref:System.Delegate.DynamicInvokeImpl%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。  
  
或 
<paramref name="args" /> 中列出的参数的数目、顺序或类型无效。</exception>
        <exception cref="T:System.ArgumentException">对对象或类调用委托所表示的方法，但该对象或类不支持这种方法。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委托所表示的方法是实例方法，目标对象为 <see langword="null" />。  
  
或 
封装的方法之一引发异常。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">作为自变量传递给当前委托所表示的方法的对象数组。  
  
或 
 如果当前委托所表示的方法不需要参数，则为 <see langword="null" />。</param>
        <summary>动态调用（后期绑定）由当前委托所表示的方法。</summary>
        <returns>委托所表示的方法返回的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现 <xref:System.Delegate.DynamicInvoke%2A> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。  
  
或 
<paramref name="args" /> 中列出的参数的数目、顺序或类型无效。</exception>
        <exception cref="T:System.ArgumentException">对对象或类调用委托所表示的方法，但该对象或类不支持这种方法。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">委托所表示的方法是实例方法，目标对象为 <see langword="null" />。  
  
或 
封装的方法之一引发异常。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前委托进行比较的对象。</param>
        <summary>确定指定的对象和当前委托的类型是否相同，是否共享相同的目标、方法和调用列表。</summary>
        <returns>如果 <paramref name="obj" /> 和当前委托具有相同的目标、方法和调用列表，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个委托不属于同一类型，它们不被视为相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，两个委托已视为好像它们的目标、 方法和调用列表等于，即使委托是不同类型的相等。  
  
 这些方法和目标进行比较的相等性，如下所示：  
  
-   如果所比较的两个方法都是静态并且同一类上的相同方法，这些方法被视为相等，这些目标也被视为相等。  
  
-   如果要比较的两种方法是实例方法，并且同一对象上的相同方法，这些方法被视为相等，这些目标也被视为相等。  
  
-   否则为方法不被视为相等，并且目标也不被视为相等。  
  
 两个调用列表将被视为相同，仅当它们具有相同的顺序，从两个列表的相应元素表示相同的方法和目标。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回委托的哈希代码。</summary>
        <returns>委托的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个原因必须不保留此方法的返回值。 首先，可能会更改类的哈希函数生成更好的分布，使旧的哈希函数中的所有值都无用。 其次，此类的默认实现不保证不同实例将返回相同的值。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回委托的调用列表。</summary>
        <returns>委托构成的数组，表示当前委托的调用列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的每个委托表示一个方法。  
  
 数组中的委托的顺序是在其中为当前委托调用那些委托所表示的方法的相同顺序。  
  
   
  
## Examples  
 下面的示例将三种方法分配给委托。 然后，它调用<xref:System.Delegate.GetInvocationList%2A>方法获取的总计数以相反顺序执行委托并执行其名称不包括子字符串的方法分配给该委托的方法的"文件"。  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前委托所表示的静态方法。</summary>
        <returns>描述当前委托表示的静态方法的 <see cref="T:System.Reflection.MethodInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于当前委托表示静态方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">不支持。</param>
        <param name="context">不支持。</param>
        <summary>不支持。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">不支持此方法。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取委托所表示的方法。</summary>
        <value>描述委托所表示的方法的 <see cref="T:System.Reflection.MethodInfo" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个委托。</param>
        <param name="d2">要比较的第二个委托。</param>
        <summary>确定指定的委托是否相等。</summary>
        <returns>如果 <see langword="true" /> 等于 <paramref name="d1" />，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有相同的目标、 方法和调用列表的相同类型的两个委托被视为相等。  
  
 如果两个委托不属于同一类型，它们不被视为相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，两个委托已视为好像它们的目标、 方法和调用列表等于，即使委托是不同类型的相等。  
  
 这些方法和目标进行比较的相等性，如下所示：  
  
-   如果所比较的两个方法都是静态并且同一类上的相同方法，这些方法被视为相等，这些目标也被视为相等。  
  
-   如果要比较的两种方法是实例方法，并且同一对象上的相同方法，这些方法被视为相等，这些目标也被视为相等。  
  
-   否则为方法不被视为相等，并且目标也不被视为相等。  
  
 如果它们具有相同的顺序，从两个列表的相应元素表示相同的方法和目标，两个调用列表将被视为相同。  
  
 此运算符的等效方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个委托。</param>
        <param name="d2">要比较的第二个委托。</param>
        <summary>确定指定的委托是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等于 <paramref name="d1" />，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个委托被视为不相等如果它们都是不同类型，或具有不同的方法、 不同的目标或不同的调用列表。  
  
 如果两个委托不属于同一类型，它们不被视为相等。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版中，两个委托被视为好像它们的目标、 方法和调用列表等于，即使委托是不同类型的相等。  
  
 这些方法和目标进行比较的相等性，如下所示：  
  
-   如果所比较的两个方法都是静态并且同一类上的相同方法，这些方法被视为相等，这些目标也被视为相等。  
  
-   如果要比较的两种方法是实例方法，并且同一对象上的相同方法，这些方法被视为相等，这些目标也被视为相等。  
  
-   否则为方法不被视为相等，并且目标也不被视为相等。  
  
 两个调用列表不相等，如果它们具有不同的大小，如果它们的顺序不同，或者从一个列表中至少一个元素表示的方法或不同于由其他列表中的对应元素的目标。  
  
 此运算符的等效方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委托，将从中移除 <c>value</c> 的调用列表。</param>
        <param name="value">委托，它提供从 <c>source</c> 调用列表中移除的调用列表。</param>
        <summary>从一个委托的调用列表中移除另一个委托的最后一个调用列表。</summary>
        <returns>一个新委托，其调用列表的构成方法为：获取 <paramref name="source" /> 的调用列表，如果在 <paramref name="value" /> 的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="source" /> 的最后一个调用列表。 如果 <paramref name="source" /> 为 <see langword="null" />，或在 <paramref name="value" /> 的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回 <paramref name="source" />。 如果 <paramref name="value" /> 的调用列表等于 <paramref name="source" /> 的调用列表，或 <paramref name="source" /> 为空引用，则返回空引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的调用列表`value`匹配一组相邻的调用列表中的元素`source`，然后调用列表`value`说过的调用列表中出现`source`。 如果调用列表`value`的调用列表中出现多次`source`，删除最后一个匹配项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <exception cref="T:System.ArgumentException">委托类型不匹配。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">委托，将从中移除 <c>value</c> 的调用列表。</param>
        <param name="value">委托，它提供从 <c>source</c> 调用列表中移除的调用列表。</param>
        <summary>从一个委托的调用列表中移除另一个委托的所有调用列表。</summary>
        <returns>一个新委托，其调用列表的构成方法为：获取 <paramref name="source" /> 的调用列表，如果在 <paramref name="value" /> 的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="source" /> 的所有调用列表。 如果 <paramref name="source" /> 为 <see langword="null" />，或在 <paramref name="value" /> 的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回 <paramref name="source" />。 如果 <paramref name="value" /> 的调用列表等于 <paramref name="source" /> 的调用列表，如果 <paramref name="source" /> 只包含等于 <paramref name="value" /> 的调用列表的一系列调用列表，或者如果 <paramref name="source" /> 为空引用，则返回空引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果的调用列表`value`匹配一组相邻的调用列表中的元素`source`，然后调用列表`value`说过的调用列表中出现`source`。 如果调用列表`value`的调用列表中出现多次`source`，删除所有匹配项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <exception cref="T:System.ArgumentException">委托类型不匹配。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">委托，它提供要从当前委托的调用列表中移除的调用列表。</param>
        <summary>从一个委托的调用列表中移除另一个委托的调用列表。</summary>
        <returns>一个新委托，其调用列表的构成方法为：获取当前委托的调用列表，如果在当前委托的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="value" /> 的调用列表。 如果 <paramref name="value" /> 为 <see langword="null" />，或者在当前委托的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回当前委托。 如果 <paramref name="value" /> 的调用列表等于当前委托的调用列表，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用列表`value`匹配一组相邻的当前委托的调用列表，然后调用列表中的元素`value`说发生在当前委托的调用列表中。 如果调用列表的`value`出现不止一次当前委托的调用列表中删除最后一个匹配项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类实例，当前委托将对其调用实例方法。</summary>
        <value>如果委托表示实例方法，则为当前委托对其调用实例方法的对象；如果委托表示静态方法，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。  
  
 如果该委托调用一个或多个实例方法，此属性将返回目标的最后一个实例方法的调用列表中。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>