<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ce2dd9dae650b2db7becf99d7b15033ce8e2860a" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49158780" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>控制系统垃圾回收器（一种自动回收未使用内存的服务）。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 垃圾回收器是公共语言运行时组件，用于控制分配和释放的托管内存。 对某个对象并释放由对象分配的资源执行垃圾回收时，会影响此类中的方法。 此类中的属性系统和年龄类别或生成，分配给对象的内存中提供信息的总可用内存量。  
  
 垃圾回收器跟踪并回收托管内存中分配的对象。 我们会定期垃圾回收器执行垃圾回收来回收内存分配给对象没有有效的引用。 不能满足内存要求，使用可用的可用内存时自动发生垃圾回收。 或者，应用程序可以强制垃圾收集使用<xref:System.GC.Collect%2A>方法。  
  
 垃圾回收包括以下步骤：  
  
1.  垃圾回收器将搜索在托管代码中引用的托管对象。  
  
2.  垃圾回收器尝试完成未引用的对象。  
  
3.  垃圾回收器释放未引用的对象并回收其内存。  
  
 本主题包括以下部分：  
  
 [垃圾回收器和非托管的资源](#unmanaged)   
 [对象老化和生成](#generations)   
 [不允许垃圾回收](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>垃圾回收器和非托管的资源  
 在回收中，垃圾回收器将不会释放对象如果在托管代码中找到该对象的一个或多个引用。 但是，垃圾回收器不能识别从非托管代码引用的对象，并且可能会释放正在使用非托管代码中以独占方式除非明确禁止执行此操作的对象。 <xref:System.GC.KeepAlive%2A>方法提供了一种机制，可防止垃圾回收器收集非托管代码中仍在使用的对象。  
  
 除了托管的内存分配，垃圾回收器的实现不维护有关资源持有的对象，如文件句柄或数据库连接的信息。 当类型使用该类型的实例将被回收之前，必须释放的非托管的资源时，该类型可以实现终结器。  
  
 在大多数情况下，终结器实现通过重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法; 但是，C# 或 c + + 编写的类型实现的编译器将转换为的重写的析构函数<xref:System.Object.Finalize%2A?displayProperty=nameWithType>。 在大多数情况下，如果对象具有一个终结器，垃圾回收器会调用它之前释放对象。 但是，垃圾回收器不需要在所有情况下; 调用终结器例如，<xref:System.GC.SuppressFinalize%2A>方法显式会被调用对象的终结器。 此外，垃圾回收器不需要使用特定的线程来完成对象，或保证的相互引用，但适用于垃圾回收的对象调用终结器的顺序。  
  
 在其中必须在特定时间释放资源的情况下，类可以实现<xref:System.IDisposable>接口，其中包含<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>执行资源管理和清理任务的方法。 类实现<xref:System.IDisposable.Dispose%2A>必须指定，作为它们的类协定中，如果类使用者调用方法来清理对象。 垃圾回收器不会默认情况下，调用<xref:System.IDisposable.Dispose%2A>方法; 但是，实现<xref:System.IDisposable.Dispose%2A>方法调用中方法<xref:System.GC>类自定义的垃圾回收器终止行为。  
  
 有关准备对象终止和 dispose 模式的详细信息，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>对象老化和生成  
 公共语言运行时中的垃圾收集器支持使用代对象老化。 生成是内存中对象的相对存在时间度量单位。 生成编号和年龄，对象的表示对象所属的代。 创建多个对象最近是的较新的生成，并具有较低的生成数字不是对象前面部分创建应用程序生命周期。 第 0 代中是最新代中的对象。 垃圾回收器的此实现支持三代的对象、 0、 1 和 2 代。 可以检索的值<xref:System.GC.MaxGeneration%2A>属性来确定系统支持的最大代数。  
  
 对象老化允许在一组特定的生成，而无需计算所有代垃圾回收器回收应用程序。 重载<xref:System.GC.Collect%2A>方法，包括`generation`参数可用于指定最后一代进行垃圾回收。  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>不允许垃圾回收  
 从开始[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，垃圾回收器支持无 GC 区域延迟模式，可以在垃圾收集会影响应用程序的性能的关键路径执行期间使用。 无 GC 区域延迟模式要求您指定的可以不受干扰地从垃圾回收器分配的内存量。 如果在运行时可以分配内存，运行时代码中的关键路径执行时将执行垃圾回收。  
  
 通过调用的重载之一定义的无 GC 区域的关键路径开头<xref:System.GC.TryStartNoGCRegion%2A>。 通过调用指定其关键路径的末尾<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。 换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
   
  
## Examples  
 以下示例使用多个 GC 方法以获取生成和内存块未使用的对象有关的信息并将其打印到控制台。 然后收集未使用的对象，并显示结果的内存总量。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">垃圾回收</related>
    <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">垃圾回收的基础</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">已分配的非托管内存的增量。</param>
        <summary>通知运行时在安排垃圾回收时应考虑分配大量的非托管内存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在确定何时安排垃圾回收时，运行时将考虑分配托管的内存量。 一个小的托管的对象分配大量的非托管内存，如果运行时将考虑仅托管的内存，并从而低估安排垃圾回收的紧急性。 <xref:System.GC.AddMemoryPressure%2A>方法将通知此附加系统内存不足的运行时。  
  
 在最简单的使用情况模式中，托管的对象的构造函数中的非托管的内存分配和中释放它`Dispose`或`Finalize`方法。 调用<xref:System.GC.AddMemoryPressure%2A>方法之后分配非托管的内存，并调用<xref:System.GC.RemoveMemoryPressure%2A>方法之后释放它。  
  
 在更复杂的方案，其中的非托管的内存分配非常大的变化的托管对象的生存期内，可以调用<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>方法进行通信，运行时对这些增量更改。  
  
> [!CAUTION]
>  您必须确保删除完全您添加的压力量。 如果不这样做可以会在长时间运行的应用程序中的系统性能产生负面影响。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> 小于或等于 0。  
  
或 
在 32 位的计算机上，<paramref name="bytesAllocated" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示操作垃圾回收优先级时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消注册垃圾回收通知。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法取消使用注册垃圾回收通知<xref:System.GC.RegisterForFullGCNotification%2A>方法。 不需要调整阈值参数值在后续调用之前调用此方法<xref:System.GC.RegisterForFullGCNotification%2A>方法。  
  
   
  
## Examples  
 以下示例取消垃圾回收注册。 此示例摘自一个更大的示例为提供[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此成员在启用并发垃圾回收时不可用。 若要了解如何禁用并发垃圾回收，请参阅 [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 运行时设置。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">垃圾回收通知</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>强制进行垃圾回收。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>强制对所有代进行即时垃圾回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法尝试回收无法访问的所有内存。 它执行所有生成阻碍性垃圾的回收。  
  
 所有对象，而不考虑时间已在内存中，被都视为集合;但是，不会收集在托管代码中引用的对象。 使用此方法强制系统尝试回收的最大可用内存量。  
  
 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，您可以通过设置压缩大型对象堆 (LOH)<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>之前，调用<xref:System.GC.Collect%2A>方法，如下面的示例说明了。  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.GC.Collect%2A>方法在每一代的内存上执行回收。 代码生成的多个未使用的对象，然后调用<xref:System.GC.Collect%2A>方法以其从内存中清除。  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">被动回收</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">最后一代进行垃圾回收次数。</param>
        <summary>强制对 0 代到指定代进行即时垃圾回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法尝试回收无法访问的内存。 但是，使用此方法不保证回收指定的代中的所有无法访问内存。  
  
 如果实现对象老化，垃圾回收器不会收集对象使用生成号大于指定的代。 如果未实现对象老化，垃圾回收器会在垃圾回收期间考虑的所有对象。  
  
 使用<xref:System.GC.MaxGeneration%2A>属性来确定有效的最大值`generation`参数。  
  
 若要让垃圾回收器考虑而不考虑其生成的所有对象，使用此方法不带参数的版本。 具有垃圾回收器回收对象基于<xref:System.GCCollectionMode>设置，请使用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>方法重载。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.GC.Collect%2A>方法执行回收内存的各个层级上。 代码生成的多个未使用的对象，然后调用<xref:System.GC.Collect%2A>方法以其从内存中清除。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> 无效。</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">被动回收</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">最后一代进行垃圾回收次数。</param>
        <param name="mode">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</param>
        <summary>强制在 <see cref="T:System.GCCollectionMode" /> 值所指定的时间对 0 代到指定代进行垃圾回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`mode`参数来指定是否应该进行垃圾回收立即或仅时间是否将回收对象的最佳选择。 使用此方法不保证回收指定的代中的所有无法访问内存。  
  
 若要调整的应用程序中的重要期间垃圾回收侵入性，请设置<xref:System.Runtime.GCSettings.LatencyMode%2A>属性。  
  
 垃圾回收器不会收集与生成号大于指定的对象`generation`参数。 使用<xref:System.GC.MaxGeneration%2A>属性来确定有效的最大值`generation`。  
  
 若要让垃圾回收器考虑而不考虑其生成的所有对象，使用此方法不带参数的版本。  
  
 若要有垃圾回收器回收对象最多指定的代的对象，请使用<xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>方法重载。 当指定的最大生成时，收集的所有对象。  
  
   
  
## Examples  
 下面的示例强制的第 2 代对象进行垃圾回收<xref:System.GCCollectionMode.Optimized>设置。  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> 无效。  
  
或 
 <paramref name="mode" /> 不是 <see cref="T:System.GCCollectionMode" /> 值之一。</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">被动回收</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">最后一代进行垃圾回收次数。</param>
        <param name="mode">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</param>
        <param name="blocking">
          <see langword="true" /> 执行阻碍性垃圾回收；<see langword="false" /> 在可能的情况下执行后台垃圾回收。</param>
        <summary>在由 <see cref="T:System.GCCollectionMode" /> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收是否应该为阻碍性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表总结了的交互`mode`和`blocking`参数：  
  
|`mode`|`blocking` 为 `true`|`blocking` 为 `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> 或 <xref:System.GCCollectionMode.Default>|尽快执行阻塞回收。 如果后台回收正在进行中以及`generation`为 0 或 1，<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法立即触发阻塞回收，并返回集合完成。 如果后台回收正在进行中和`generation`为 2，方法会等到后台回收完成，触发阻塞第 2 代回收，，然后返回。|尽快执行回收。 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。 如果后台回收正在进行，该方法将立即返回。|  
|<xref:System.GCCollectionMode.Optimized>|可能会执行阻止式回收，具体视垃圾回收器的状态和 `generation` 参数而定。 垃圾回收器会尽量提供最佳性能。|根据垃圾回收器的状态，有时可执行回收。 <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。 垃圾回收器会尽量提供最佳性能。 如果后台回收正在进行，该方法将立即返回。|  
  
 如果调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法执行完整的阻碍性垃圾回收时，您还可以通过设置压缩大型对象堆<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>之前，调用<xref:System.GC.Collect%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> 无效。  
  
或 
 <paramref name="mode" /> 不是 <see cref="T:System.GCCollectionMode" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">最后一代进行垃圾回收次数。</param>
        <param name="mode">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</param>
        <param name="blocking">
          <see langword="true" /> 执行阻碍性垃圾回收；<see langword="false" /> 在可能的情况下执行后台垃圾回收。</param>
        <param name="compacting">
          <see langword="true" /> 表示压缩小对象堆；<see langword="false" /> 表示仅进行清理。</param>
        <summary>在由 <see cref="T:System.GCCollectionMode" /> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收应该为阻碍性还是压缩性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`blocking`是`false`，GC 决定是否要执行后台任务或阻碍性垃圾回收。 如果`compacting`是`true`，它执行阻碍性垃圾回收。  
  
 如果`compacting`是`true`，运行时将压缩小对象堆 (SOH)。 不会压缩大型对象堆 (LOH)，除非<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>。 请注意，这包括所有阻止垃圾回收，不只是完全阻止垃圾收集。  
  
 您可以调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法来减少托管的堆大小可能的最小，如下面的代码段所示。  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 指定`true`为`compacting`参数可保证压缩、 完整的阻碍性垃圾回收。 设置<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>可确保将压缩 LOH 和 SOH。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">对象的代，将针对此代确定垃圾回收计数。</param>
        <summary>返回已经对对象的指定代进行的垃圾回收次数。</summary>
        <returns>自启动进程以来已经对指定代进行的垃圾回收次数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您实现您自己的资源管理，可能需要通过调用定期强制进行垃圾回收<xref:System.GC.Collect%2A>方法。 由于这是代价高昂的操作，可以通过最近发生垃圾回收时跳过调用来提高性能。 保存返回的值<xref:System.GC.CollectionCount%2A>后立即调用<xref:System.GC.Collect%2A>。 您需要调用下一次<xref:System.GC.Collect%2A>，返回的当前值进行比较<xref:System.GC.CollectionCount%2A>到保存的值。 如果两个值相等，没有任何集合出现在此期间，它是合乎调用<xref:System.GC.Collect%2A>试。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> 小于 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束无 GC 区域延迟模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A>方法会抛出<xref:System.InvalidOperationException>如果垃圾回收器不处于无 GC 区域延迟模式。 任何以下情况下发生这种情况：  
  
-   <xref:System.GC.TryStartNoGCRegion%2A>以前未调用方法。  
  
-   在调用<xref:System.GC.TryStartNoGCRegion%2A>方法返回`false`。  
  
-   对调用<xref:System.GC.TryStartNoGCRegion%2A>方法引发了异常。  
  
 通过使用类似以下的代码，可以为以下任一原因防止异常：  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">垃圾回收器不处于无 GC 区域延迟模式。  
  
或 
无 GC 区域延迟模式已结束，可能是因为已引发垃圾回收。  
  
或 
内存分配超过了 <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> 方法调用中指定的量。</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">滞后时间模式</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回对象的当前代数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">检索其代信息的对象。</param>
        <summary>返回指定对象的当前代数。</summary>
        <returns>
          <paramref name="obj" /> 的当前代数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来确定对象的年龄，然后使用该信息与<xref:System.GC.Collect%2A>在同一个生成对象的方法，以强制垃圾回收器收集。 例如，使用此方法时有一组对象作为一个组创建的并在同一时间变为不可访问。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.GC.GetGeneration%2A>方法来确定对象的年龄。 此示例将执行垃圾回收来清理内存并进行比较 pre 和 post 集合在控制台中的内存总量。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">引用要确定其代数的目标对象的 <see cref="T:System.WeakReference" />。</param>
        <summary>返回指定弱引用的目标的当前代数。</summary>
        <returns>
          <paramref name="wo" /> 的目标的当前代数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何将<xref:System.GC.GetGeneration%2A>方法，以确定弱引用对象的年龄。  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已经对 <paramref name="wo" /> 执行了垃圾回收。</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">如果此方法可以在返回之前等待垃圾回收发生，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>检索当前认为要分配的字节数。 一个参数，指示此方法是否可以等待较短间隔再返回，以便系统回收垃圾和终结对象。</summary>
        <returns>一个数字，它是托管内存中当前所分配字节数的可用的最佳近似值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`forceFullCollection`参数是`true`，此方法在时系统回收垃圾和完成对象返回前等待短的时间间隔。 间隔的持续时间为内部指定的限制由已完成的垃圾回收周期的数量和恢复周期之间的内存量的更改。 垃圾回收器不保证收集所有不可访问的内存。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.GC.GetTotalMemory%2A>方法以获取并显示当前分配的托管内存的字节数。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要引用的对象。</param>
        <summary>引用指定对象，使其从当前例程开始到调用此方法的那一刻为止均不符合进行垃圾回收的条件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用途<xref:System.GC.KeepAlive%2A>方法是确保对面临风险的过早地被垃圾回收器回收对象的引用是否存在。 常见的方案可能会发生这种情况是在托管的代码或数据，在存在对该对象不引用，但仍在使用该对象处于非托管代码如 Win32 Api，非托管 Dll，或使用 COM 的方法  
  
 此方法引用`obj`参数，从而使该对象进行垃圾回收不符合条件从例程开始到点，按执行顺序，调用此方法。 在结束时，不，范围的起始处的说明此方法的代码位置`obj`必须可用。  
  
 <xref:System.GC.KeepAlive%2A>方法会执行任何操作，并生成扩展中作为参数传递的对象的生存期以外没有副作用。  
  
   
  
## Examples  
 下面的代码示例的开始处创建一个对象及其`Main`方法并不是指对象结束时，直到再次时<xref:System.GC.KeepAlive%2A>调用方法。 该对象仍然存在 30 秒持续时间内`Main`方法，即使调用<xref:System.GC.Collect%2A>和<xref:System.GC.WaitForPendingFinalizers%2A>方法。  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统当前支持的最大代数。</summary>
        <value>从零到所支持的最大代数间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生成编号或年龄，对象的对象的生命周期的实现定义的相对度量。 最近创建的对象是在第 0 代和最旧的对象是否小于或等于生成返回的生成中<xref:System.GC.MaxGeneration%2A>属性。  
  
 垃圾回收器假定较新的内存更有可能有资格获得比旧内存垃圾回收。 因此，垃圾回收器通过调整回收内存，每次生成数字来提高其性能和<xref:System.GC.MaxGeneration%2A>属性值可以随时间增长而增加。  
  
 如果实现对象老化，<xref:System.GC.MaxGeneration%2A>属性返回由系统使用的最大代数; 否则，此属性返回零。  
  
   
  
## Examples  
 下面的示例演示如何使用 MaxGeneration 属性中使用当前显示的最大代数。  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>有关此实现中，返回的值<see cref="P:System.GC.MaxGeneration" />保证属性执行的应用程序的生存期内保持不变。  
  
使用<see cref="P:System.GC.MaxGeneration" />属性来确定最大值时调用，可以指定<see cref="M:System.GC.Collect(System.Int32)" />采用 generation 参数的方法。</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">一个介于 1 和 99 之间的数字，指定根据在第 2 代中分配的对象，应何时引发通知。</param>
        <param name="largeObjectHeapThreshold">一个介于 1 和 99 之间的数字，指定根据大对象堆中分配的对象，应何时引发通知。</param>
        <summary>指定当条件支持完整垃圾回收以及回收完成时，应引发垃圾回收通知。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为每一代垃圾回收器设置分配到该代的阈值。 当分配的大小超过此阈值时，在该代触发垃圾回收。 有关示例中，如果第 2 的代的阈值为 20 MB （这意味着 20 MB 可以幸存，但第 1 代集合和提升到第 2 代），超过 20 MB 了保留第 1 代和第 2 代入系统会提示，将尝试下一个垃圾回收作为第 2 代集合。 同样，如果大型对象堆 (LOH) 的阈值为 20 MB 和您的应用程序已经分配了超过 20 MB 的大型对象下, 一次垃圾回收将还尝试为第 2 代集合 （由于仅在第 2 代垃圾回收中收集 LOH）。  
  
 `maxGenerationThreshold`和`largeObjectHeapThreshold`阈值控制完全垃圾回收发生前收到通知多少提前。 阈值越大，通知下一次完整的垃圾回收之间可能发生的多个分配。  
  
 如果公共语言运行时完全垃圾回收会对应用程序的性能产生负面影响的情况下，你可以要求在运行时即将执行完全垃圾回收和绕过该集合时得到通知自行引发集合 (使用<xref:System.GC.Collect%2A>方法) 仍有利条件时。 除了更改自己的垃圾收集计划，完整 GC 通知适合以下方案中：  
  
-   有关完整的垃圾回收的方法监视和时，将收到通知，即将，减少实时数据大小 （例如，通过释放某些缓存条目）。 因此，当垃圾回收发生时，它便可以回收更多的内存。  
  
-   监视完整的垃圾回收完成，这样可以收集一些统计信息。  例如，你可能想要度量在 GC 完成时堆的大小，以便您知道实时数据的大小。 （完整 GC 堆后在其最小大小。）  
  
 表示完整的垃圾回收的内容的详细信息，请参阅[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)。  
  
 当你注册垃圾回收通知时，可以时完全垃圾回收的开始时间和完成后通知您。 此模式类似于操作系统如何监视内存不足通知。  
  
 使用以下准则来指定`maxGenerationThreshold`和`largeObjectHeapThreshold`参数：  
  
-   阈值值越大，更多的分配将通知与完全垃圾回收之间发生。  
  
     更大的阈值值提供了更多的运行时检查临近的回收机会。 这会增加，将会通知的可能性。 但是，因为之前运行时引入下一次回收产生更多分配，不应设置过高的阈值。  
  
     当您自行诱导回收使用高阈值的通知时，不是运行时的下一次回收将回收将被回收更少的对象。  
  
-   阈值越小，较少的分配通知与完全垃圾回收之间。  
  
   
  
## Examples  
 下面的示例演示如何注册垃圾回收通知并启动一个线程来监视垃圾回收通知的状态。 此代码示例是为提供一个更大示例的一部分[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxGenerationThreshold" /> 或 <paramref name="largeObjectHeapThreshold" /> 不在 1 和 99 之间。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">垃圾回收通知</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">已释放的非托管内存量。</param>
        <summary>通知运行时已释放非托管内存，在安排垃圾回收时不需要再考虑它。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在确定何时安排垃圾回收时，运行时将考虑分配托管的内存量。 一个小的托管的对象分配大量的非托管内存，如果运行时将考虑仅托管的内存，并从而低估安排垃圾回收的紧急性。 <xref:System.GC.AddMemoryPressure%2A>方法将通知此附加系统内存不足的运行时和<xref:System.GC.RemoveMemoryPressure%2A>方法将通知运行时已释放额外的压力。  
  
 在最简单的使用情况模式中，托管的对象的构造函数中的非托管的内存分配和中释放它`Dispose`或`Finalize`方法。 调用<xref:System.GC.AddMemoryPressure%2A>方法之后分配非托管的内存，并调用<xref:System.GC.RemoveMemoryPressure%2A>方法之后释放它。  
  
 在更复杂的方案，其中的非托管的内存分配非常大的变化的托管对象的生存期内，可以调用<xref:System.GC.AddMemoryPressure%2A>和<xref:System.GC.RemoveMemoryPressure%2A>方法进行通信，运行时对这些增量更改。  
  
> [!CAUTION]
>  您必须确保删除完全您添加的压力量。 如果不这样做可以会在长时间运行的应用程序中的系统性能产生负面影响。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> 小于或等于 0。  
  
或 
在 32 位的计算机上，<paramref name="bytesAllocated" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示操作垃圾回收优先级时调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">必须为其调用终结器的对象。</param>
        <summary>请求系统调用指定对象的终结器，此前已为该对象调用 <see cref="M:System.GC.SuppressFinalize(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A>方法将添加`obj`参数的垃圾回收器释放对象前会请求终止的对象的列表。 `obj`参数必须是此方法的调用方。  
  
 调用<xref:System.GC.ReRegisterForFinalize%2A>方法不保证垃圾回收器将调用对象的终结器。  
  
 默认情况下，实现终结器的所有对象都添加到需要终止; 的对象的列表但是，对象可能已被终结，或可能已禁用通过调用的定案<xref:System.GC.SuppressFinalize%2A>方法。  
  
 终结器可以使用此方法来继续研究下去自己或它所引用的对象。  
  
   
  
## Examples  
 下面的示例演示如何使用 ReRegisterForFinalize 方法来完成第二个对象垃圾回收后的时间。  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">不得执行其终结器的对象。</param>
        <summary>请求公共语言运行时不要调用指定对象的终结器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的对象标头中设置有点`obj`，在调用终结器时将运行时检查。 终结器，由表示<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法，用于对象进行垃圾回收之前释放非托管的资源。 如果`obj`不具有终结器中，调用<xref:System.GC.SuppressFinalize%2A>方法不起作用。  
  
 对象实现<xref:System.IDisposable>接口可以从该对象的调用此方法<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现，以防止垃圾回收器调用<xref:System.Object.Finalize%2A?displayProperty=nameWithType>上不需要的对象。 通常情况下，这样做是为了防止终结器释放非托管的资源，已释放由<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.GC.SuppressFinalize%2A>中的资源类，以防止冗余垃圾回收被调用的方法。 该示例使用[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)若要同时释放托管资源 (即对象实现<xref:System.IDisposable>) 和非托管资源。  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="http://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">释放模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在关键路径执行期间尝试禁止垃圾回收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。 换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。 它必须小于或等于临时段的大小。 有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</param>
        <summary>如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收。</summary>
        <returns>如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。  如果运行时无法最初分配所需的内存，垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收。 垃圾回收器进入无 GC 区域延迟模式，如果能够分配所需的数量的内存，在这种情况下为实际 2 *`totalSize`字节 (它会尝试分配`totalSize`针对小型对象堆字节数和`totalSize`的字节数大型对象堆）。  
  
 `totalSize` 必须足够大，能够处理在关键路径中出现的所有内存分配。 这包括分配的应用程序，以及应用的代表，运行时做出的分配。  
  
> [!IMPORTANT]
>  不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。 换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> 超出了暂时段大小。</exception>
        <exception cref="T:System.InvalidOperationException">进程已进入无 GC 区域延迟模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">垃圾回收的基础</related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">滞后时间模式</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。 它必须小于或等于临时段的大小。 有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> 表示如果垃圾回收器最初无法分配 <c>totalSize</c> 字节，则忽略完整的阻碍性垃圾回收；否则为 <see langword="false" />。</param>
        <summary>如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</summary>
        <returns>如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。  如果运行时无法最初分配请求的内存量和`disallowFullBlockingGC`自变量是`false`，垃圾回收器执行完整的阻碍性垃圾回收中尝试释放更多内存; 否则为分配失败，并且该方法返回`false`。 垃圾回收器进入无 GC 区域延迟模式，如果能够分配所需的数量的内存，在这种情况下为实际 2 * `totalSize` (它会尝试分配`totalSize`针对小型对象堆和`totalSize`大型对象堆）。  
  
 `totalSize` 必须足够大，能够处理在关键路径中出现的所有内存分配。 这包括分配的应用程序，以及应用的代表，运行时做出的分配。  
  
 设置`disallowFullBlockingGC`到`true`以免完整的阻碍性垃圾回收集合最初可没有足够的内存是否是在负载平衡方案中最有用： 一个系统可以调用此方法并报告本身为准备好接受请求，如果它返回`true`，并且具有负载均衡器将请求重定向到其他系统，如果它返回`false`。 它可以进行完整的阻碍性垃圾回收时不处理请求通过调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。  
  
> [!IMPORTANT]
>  不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。 换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> 超出了暂时段大小。</exception>
        <exception cref="T:System.InvalidOperationException">进程已进入无 GC 区域延迟模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">垃圾回收的基础</related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">滞后时间模式</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。 <c>totalSize</c> –<c>lohSize</c> 必须小于或等于暂时段的大小。 有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</param>
        <param name="lohSize">
          <c>totalSize</c> 中用于大对象堆 (LOH) 分配的字节数。</param>
        <summary>如果指定数量的内存可用于大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收。</summary>
        <returns>如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。  如果运行时无法最初分配所需的内存，垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收。 垃圾回收器进入无 GC 区域延迟模式，如果能够分配`lohSize`回收 loh 和`totalSize`–`lohSize`针对小型对象堆 (SOH)。  
  
 `lohSize` 必须足够大，以处理对于 LOH，在关键路径中发生的所有内存分配和`totalSize`–`lohSize`必须足够大，能够都处理的 SOH 在关键路径中发生的所有内存分配。 这包括分配的应用程序，以及应用的代表，运行时做出的分配。  
  
> [!IMPORTANT]
>  不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。 换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> 超出了暂时段大小。</exception>
        <exception cref="T:System.InvalidOperationException">进程已进入无 GC 区域延迟模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">垃圾回收的基础</related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">滞后时间模式</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。 <c>totalSize</c> –<c>lohSize</c> 必须小于或等于暂时段的大小。 有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</param>
        <param name="lohSize">
          <c>totalSize</c> 中用于大对象堆 (LOH) 分配的字节数。</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> 表示如果垃圾回收器初始无法分配小对象堆 (SOH) 和 LOH 上的指定内存，则忽略完整的阻碍性垃圾回收；否则为 <see langword="false" />。</param>
        <summary>如果指定数量的内存可用大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</summary>
        <returns>如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>方法尝试将垃圾回收器放在应用程序执行代码的关键区域时，不允许垃圾回收无 GC 区域延迟模式。  如果运行时无法最初分配请求的内存量和`disallowFullBlockingGC`自变量是`false`，垃圾回收器执行完整的阻碍性垃圾回收中尝试释放更多内存; 否则为分配失败，并且该方法返回`false`。 垃圾回收器进入无 GC 区域延迟模式，如果能够分配`lohSize`回收 loh 和`totalSize`–`lohSize`针对小型对象堆 (SOH)。  
  
 `lohSize` 必须足够大，以处理对于 LOH，在关键路径中发生的所有内存分配和`totalSize`–`lohSize`必须足够大，能够都处理的 SOH 在关键路径中发生的所有内存分配。 这包括分配的应用程序，以及应用的代表，运行时做出的分配。  
  
 设置`disallowFullBlockingGC`到`true`以免完整的阻碍性垃圾回收集合最初可没有足够的内存是否是在负载平衡方案中最有用： 一个系统可以调用此方法并报告本身为准备好接受请求，如果它返回`true`，并且具有负载均衡器将请求重定向到其他系统，如果它返回`false`。 它可以进行完整的阻碍性垃圾回收时不处理请求通过调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法。  
  
> [!IMPORTANT]
>  不能嵌套调用<xref:System.GC.TryStartNoGCRegion%2A>方法，并且你应只调用<xref:System.GC.EndNoGCRegion%2A>方法如果运行时当前处于无 GC 区域延迟模式。 换而言之，不应调用<xref:System.GC.TryStartNoGCRegion%2A>多个时间 （在第一个方法调用后，后续调用将不会成功），并且不应期望调用<xref:System.GC.EndNoGCRegion%2A>成功只是因为第一次调用到<xref:System.GC.TryStartNoGCRegion%2A>成功。  
  
 通过调用退出无 GC 区域延迟模式<xref:System.GC.EndNoGCRegion%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> – <paramref name="lohSize" /> 超出了暂时段大小。</exception>
        <exception cref="T:System.InvalidOperationException">进程已进入无 GC 区域延迟模式。</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">垃圾回收的基础</related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">滞后时间模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</summary>
        <returns>已注册垃圾回收通知的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。 此外可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以确定完整的垃圾回收是否已完成。  
  
 当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如阻止其他对象分配和使用自行引发回收<xref:System.GC.Collect%2A>方法。 请注意通知不保证完整的垃圾回收将实现的只能保证条件已达到阈值，支持完整垃圾回收发生。  
  
 无限期地等待垃圾回收通知，以获取此方法。 如果你想要指定要返回如果无法获得通知的方法的超时期限，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法重载。 如果不指定超时情况下调用此方法，则可以调用<xref:System.GC.CancelFullGCNotification%2A>在等待时间长于首选的方法。  
  
 应遵循此方法通过调用<xref:System.GC.WaitForFullGCComplete%2A>方法以确保您已经完全垃圾回收。 调用此方法只会导致结果不确定。  
  
   
  
## Examples  
 下面的示例演示如何使用此方法来确定是否正在接近完整、 阻碍性垃圾回收。 通知的状态是每当<xref:System.GCNotificationStatus.Succeeded>，将用户方法`OnFullGCApproachNotify`调用以执行操作以响应临近的集合。 此代码示例是为提供一个更大示例的一部分[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">垃圾回收通知</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">在获取通知状态前等待的时间长度。 指定 -1 表示无限期等待。</param>
        <summary>在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</summary>
        <returns>已注册垃圾回收通知的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。 此外可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法，以确定完整的垃圾回收是否已完成。  
  
 请注意，此方法返回时获取垃圾回收通知状态，而不考虑指定的值立即`millisecondsTimeout`。 如果垃圾回收通知状态前未获取`millisecondsTimeout`时间，此方法返回<xref:System.GCNotificationStatus.NotApplicable>。  
  
 当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如阻止其他对象分配和使用自行引发回收<xref:System.GC.Collect%2A>方法。 请注意通知不保证完整的垃圾回收将实现的只能保证条件已达到阈值，支持完整垃圾回收发生。  
  
 您可以调用<xref:System.GC.CancelFullGCNotification%2A>方法时不能等待超时周期结束。  
  
 应遵循此方法通过调用<xref:System.GC.WaitForFullGCComplete%2A>方法以确保您已经完全垃圾回收。 调用此方法只会导致结果不确定。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 必须为非负数，或者小于等于 <see cref="F:System.Int32.MaxValue" /> 或 -1。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">垃圾回收通知</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</summary>
        <returns>已注册垃圾回收通知的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。 此外可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以确定是否即将引发完整垃圾回收。  
  
 当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如继续工作并获取集合计数与<xref:System.GC.CollectionCount%2A>属性。  
  
 无限期地等待垃圾回收通知，以获取此方法。 如果你想要指定要返回如果无法获得通知的方法的超时期限，使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法重载。 如果不指定超时情况下调用此方法，则可以调用<xref:System.GC.CancelFullGCNotification%2A>在等待时间长于首选的方法。  
  
 此方法调用的前面应带有通过调用<xref:System.GC.WaitForFullGCApproach%2A>方法以确保您已经完全垃圾回收。 单独调用此方法可能产生不确定结果。  
  
   
  
## Examples  
 下面的示例演示如何使用此方法来确定是否已完成完整的垃圾回收。 通知的状态是每当<xref:System.GCNotificationStatus.Succeeded>，将用户方法`OnFullGCCompletedNotify`调用以执行操作以响应已完成的集合。 此代码示例是为提供一个更大示例的一部分[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题。  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">垃圾回收通知</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">在获取通知状态前等待的时间长度。 指定 -1 表示无限期等待。</param>
        <summary>在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</summary>
        <returns>已注册垃圾回收通知的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.GCNotificationStatus>返回的此方法以确定当前使用注册的垃圾回收通知的状态的枚举<xref:System.GC.RegisterForFullGCNotification%2A>方法。 此外可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法，以确定是否即将引发完整垃圾回收。  
  
 请注意，此方法返回时获取垃圾回收通知状态，而不考虑指定的值立即`millisecondsTimeout`。 如果垃圾回收通知状态前未获取`millisecondsTimeout`时间，此方法返回<xref:System.GCNotificationStatus.NotApplicable>。  
  
 当枚举返回<xref:System.GCNotificationStatus.Succeeded>，可以执行任务，例如继续工作并获取集合计数与<xref:System.GC.CollectionCount%2A>属性。  
  
 您可以调用<xref:System.GC.CancelFullGCNotification%2A>方法时不能等待超时周期结束。  
  
 此方法调用的前面应带有通过调用<xref:System.GC.WaitForFullGCApproach%2A>方法以确保您已经完全垃圾回收。 单独调用此方法可能产生不确定结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> 必须为非负数，或者小于等于 <see cref="F:System.Int32.MaxValue" /> 或 -1。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">对于直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">垃圾回收通知</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>挂起当前线程，直到处理终结器队列的线程清空该队列为止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当垃圾收集器发现可以回收的对象时，它会检查每个对象，以确定对象的终止要求。 如果对象实现终结器，并且未禁用通过调用终止<xref:System.GC.SuppressFinalize%2A>，该对象放在标记为准备好进行终结的对象的列表。 垃圾回收器调用<xref:System.Object.Finalize%2A>此列表中移除这些项从列表中的对象的方法。 此方法进行阻止，直到所有终结器运行到完成。  
  
 在其运行终结器线程是未指定的因此将终止此方法不能保证。 但是，此线程时的另一个线程会中断<xref:System.GC.WaitForPendingFinalizers%2A>正在进行中。 例如，可以启动另一个线程的等待一段时间内，则中断此线程，如果此线程仍处于挂起状态。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.GC.WaitForPendingFinalizers%2A>方法挂起当前线程，直到最终完成安装所收集的所有对象已完成。  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>