<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c44ea2ff929bf6dbeae3fd1cf36c3b7ff6bc5fa0" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48755249" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>将文本表示为 UTF-16 代码单元的序列。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 字符串是用于表示文本字符的序列集合。 一个<xref:System.String>对象是的有序集合<xref:System.Char?displayProperty=nameWithType>这些对象表示一个字符串;<xref:System.Char?displayProperty=nameWithType>对象对应于 utf-16 代码单元。 值<xref:System.String>对象为的有序集合的内容<xref:System.Char?displayProperty=nameWithType>对象和值是不可变 （即，它是只读的）。 字符串的不可变性的详细信息，请参阅[不变性和 StringBuilder 类](#Immutability)本主题后面的部分。 最大大小<xref:System.String>对象在内存中的为 2 GB 或大约 1 亿个字符。  
  
 本节内容：  
  
 [实例化字符串对象](#Instantiation)   
 [Char 对象和 Unicode 字符](#Characters)   
 [字符串和 Unicode 标准](#Unicode)   
 [字符串和嵌入的 null 字符](#EmbeddedNulls)   
 [字符串和已分区索引](#Indexes)   
 [Null 字符串和空字符串](#Nulls)   
 [不变性和 StringBuilder 类](#Immutability)   
 [区分区域性的操作与序号](#CultureSensitive)   
 [规范化](#Normalization)   
 [按类别的字符串操作](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>实例化字符串对象  
 可以实例化<xref:System.String>对象中的以下方法：  
  
-   通过将分配一个字符串赋给<xref:System.String>变量。 这是用于创建一个字符串，最常使用的方法。 下面的示例使用分配来创建多个字符串。 请注意，在 C# 中，因为反斜杠 (\\) 是转义的字符，在字符串中的文本反斜杠必须进行转义或者整个字符串必须是@-quoted。  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   通过调用<xref:System.String>类构造函数。 下面的示例通过调用多个类构造函数实例化字符串。 请注意，一些构造函数包含指向字符数组或作为参数的有符号的字节数组的指针。 Visual Basic 不支持对这些构造函数的调用。 有关详细信息<xref:System.String>构造函数，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   通过使用字符串串联运算符 (+ C# 中和 （& a) 或 + 在 Visual Basic 中) 中的任意组合创建单个字符串<xref:System.String>实例和字符串文本。 下面的示例演示如何使用字符串串联运算符。  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   通过检索属性或调用返回的字符串的方法。 下面的示例使用的方法<xref:System.String>类，以从更大的字符串中提取子字符串。  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   通过调用将的值或对象转换为其字符串表示形式的格式设置方法。 下面的示例使用[复合格式设置](~/docs/standard/base-types/composite-formatting.md)功能嵌入的两个对象的字符串表示形式转换为字符串。  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char 对象和 Unicode 字符  
 在字符串中的每个字符由 Unicode 标量值，也称为 Unicode 码位或序号 （数字） 值的 Unicode 字符的定义。 每个码位编码使用 utf-16 编码，并且由表示编码的每个元素的数值<xref:System.Char>对象。  
  
> [!NOTE]
>  注意，因为<xref:System.String>实例都包含 utf-16 代码单元的有序集合，可以将创建<xref:System.String>不是格式正确的 Unicode 字符串的对象。 例如，就可以创建具有低代理项而无需相应的高代理项的字符串。 尽管某些方法，如编码和解码中的对象的方法<xref:System.Text>命名空间，可能会执行检查，以确保字符串格式不正确，<xref:System.String>类成员不能确保字符串是格式正确。  
  
 将单个<xref:System.Char>对象通常表示单个码位; 也就是说的数值<xref:System.Char>等于码位。 例如，码位的字符"a"为 U + 0061。 但是，代码点可能需要多个编码的元素 (多个<xref:System.Char>对象)。 Unicode 标准定义了两种类型的相对应的字符到多个<xref:System.Char>对象： graphemes，并对应于在 Unicode 辅助平面字符的 Unicode 补充码位。  
  
-   表示基字符后跟一个或多个组合字符字形。 例如，由一个表示字符 ä<xref:System.Char>对象，其代码点为 U + 0061 跟一个<xref:System.Char>对象，其代码点为 U + 0308年。 此字符也可以定义由单个<xref:System.Char>具有码位 U + 00E4 的对象。 如下面的示例所示，需要区分区域性的比较相等性指示这两种表示相等，尽管普通的序号比较则不然。 但是，如果两个字符串进行规范化，序号比较还指示它们是否相等。 (有关规范化字符串的详细信息，请参阅[规范化](#Normalization)部分。)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   补充码位 （代理项对） 表示的 Unicode<xref:System.Char>对象，其码位是一个高代理项跟<xref:System.Char>对象，其码位是一个低代理项。 高代理项范围从 u+d800 到 U + DBFF 代码单元。 低代理项范围是从 U+DC00 到 U + DFFF 代码单元。 代理项对用于表示中 16 Unicode 辅助平面字符。 以下示例创建一个代理项字符并将其传递给<xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>方法以确定它是否是代理项对。  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>字符串和 Unicode 标准  
 字符串中的字符都是 utf-16 编码代码单元，它们分别对应于<xref:System.Char>值。  
  
 在字符串中的每个字符包含在.NET 中的关联的 Unicode 字符类别<xref:System.Globalization.UnicodeCategory>枚举。 可通过调用确定的字符或代理项对类别<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>方法。  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 此外，.NET 支持的字符串比较和排序基于 Unicode 标准。 通过.NET Framework 的版本中[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，.NET Framework 维护自己的字符串数据的表。 这也是如此的开头的.NET framework 版本[!INCLUDE[net_v45](~/includes/net-v45-md.md)]Windows 7 上运行。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]Window 8 和更高版本的 Windows 操作系统上运行，运行时委托字符串比较和排序操作对操作系统。 在.NET Core 上的字符串比较和排序信息将由[International Components for Unicode](http://site.icu-project.org/)库。下表列出了版本的.NET 和 Unicode 标准的字符的比较和排序所基于的版本。  
  
|.NET 版本|Unicode 标准版本|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Unicode 标准版本 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Unicode 标准，5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Unicode 标准，5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Unicode 标准，5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 和更高版本在 Windows 7|[Unicode 标准，5.0.0 版](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 和更高版本在 Windows 8 和更高版本的 Windows 操作系统|[Unicode 标准 6.3.0 版](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET core （所有版本）|取决于基础操作系统支持的 Unicode 标准版本。|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>字符串和嵌入的 null 字符  
 在.NET 中，<xref:System.String>对象可以包含嵌入的 null 字符，作为字符串的长度的一部分进行计数。 但是，在某些语言如 C 和 c + + 中，null 字符指示字符串; 的末尾它不被视为字符串的一部分，并不计为字符串的长度的一部分。 这意味着 C 和 c + + 程序员提供的或用 C 或 c + + 编写的库可能会使有关字符串的以下常见假设不一定是有效时应用于<xref:System.String>对象：  
  
-   返回的值`strlen`或`wcslen`函数不一定等于<xref:System.String.Length%2A?displayProperty=nameWithType>。  
  
-   由创建的字符串`strcpy_s`或`wcscpy_s`函数不是由创建的字符串一定要完全相同<xref:System.String.Copy%2A?displayProperty=nameWithType>方法。  
  
 您应该确保实例化该本机 C 和 c + + 代码<xref:System.String>对象和代码传递<xref:System.String>对象通过平台调用，请不要认为嵌入的 null 字符标记字符串的末尾。  
  
 排序 （或比较） 一个字符串，以及搜索字符串时，还会区别处理字符串中嵌入的 null 字符。 执行区分区域性的比较两个字符串，包括使用固定区域性的比较时，将忽略 null 字符。 它们被视为仅为序号或不区分大小写的序号比较。 另一方面，嵌入的 null 字符始终被认为是使用方法，如搜索字符串时<xref:System.String.Contains%2A>， <xref:System.String.StartsWith%2A>，和<xref:System.String.IndexOf%2A>。  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>字符串和已分区索引  
 索引是的位置<xref:System.Char>中的对象 （而不是 Unicode 字符） <xref:System.String>。 索引是从零的字符串中的第一个位置开始的从零开始的、 非负数字。 很多的搜索方法，如<xref:System.String.IndexOf%2A>和<xref:System.String.LastIndexOf%2A>，返回其索引的一个字符或子字符串的字符串实例中。  
  
 <xref:System.String.Chars%2A>属性，可以访问单个<xref:System.Char>按其索引位置的字符串中的对象。 因为<xref:System.String.Chars%2A>属性为默认属性 （在 Visual Basic 中) 或索引器 （在 C# 中)，可以访问单个<xref:System.Char>使用如下所示的代码的字符串中的对象。 此代码将查找空格或标点字符在字符串以确定该字符串包含的单词数。  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 因为<xref:System.String>类实现<xref:System.Collections.IEnumerable>接口，您还可以循环<xref:System.Char>中使用的字符串对象`foreach`构造，如以下示例所示。  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 连续的索引值可能不对应于连续的 Unicode 字符，因为的 Unicode 字符可能是编码为多个<xref:System.Char>对象。 具体而言，一个字符串可能包含多字符的文本单位形成基字符后跟一个或多个组合字符或代理项对的。 若要使用而不是 Unicode 字符<xref:System.Char>对象，请使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>和<xref:System.Globalization.TextElementEnumerator>类。 下面的示例说明了处理的代码之间的差异<xref:System.Char>对象和使用 Unicode 字符的代码。 它将进行比较的字符数或每个单词的句子中的文本元素。 该字符串包含两个基字符组合字符后跟的序列。  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 此示例适用于文本元素通过使用<xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>方法和<xref:System.Globalization.TextElementEnumerator>类来枚举字符串中的所有文本元素。 您还可以检索通过调用包含每个文本元素的起始索引的数组<xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>方法。  
  
 详细了解使用的文本而不是单个单元<xref:System.Char>值，请参阅<xref:System.Globalization.StringInfo>类。  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Null 字符串和空字符串  
 已声明但尚未分配值的字符串是`null`。 尝试在该字符串上调用方法将引发<xref:System.NullReferenceException>。 空字符串是空字符串，这是一个字符串，其值从不同""或<xref:System.String.Empty?displayProperty=nameWithType>。 在某些情况下，将 null 字符串或空字符串作为方法调用中的自变量传递引发异常。 例如，传递一个 null 字符串到<xref:System.Int32.Parse%2A?displayProperty=nameWithType>方法会抛出<xref:System.ArgumentNullException>，并传递空字符串，则会引发<xref:System.FormatException>。 在其他情况下，方法自变量可以是空字符串或空字符串。 例如，如果你要提供<xref:System.IFormattable>类实现中的，你想要将 null 字符串和空字符串视为相等与常规 ("G") 格式说明符。  
  
 <xref:System.String>类包括以下两个方便的方法，使您能够测试字符串是否为`null`或为空：  
  
-   <xref:System.String.IsNullOrEmpty%2A>指示字符串是否是任一`null`或等于<xref:System.String.Empty?displayProperty=nameWithType>。 此方法无需使用类似以下的代码：  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>指示字符串是否是`null`，等于<xref:System.String.Empty?displayProperty=nameWithType>，或仅由空白字符组成。 此方法无需使用类似以下的代码：  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 下面的示例使用<xref:System.String.IsNullOrEmpty%2A>中的方法<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>的自定义实现`Temperature`类。 方法支持"G"、"C"、"F"和"K"格式字符串。 如果为空的格式字符串或格式字符串的值是`null`传递给方法，其值更改为"G"格式字符串。  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>不变性和 StringBuilder 类  
 一个<xref:System.String>对象称为不可变 （只读），因为它在创建后不能修改其值。 看起来要修改的方法<xref:System.String>对象实际上返回一个新<xref:System.String>包含修改的对象。  
  
 由于字符串是不可变的执行的字符串操作例程重复添加或删除操作到显示为单个字符串可以精确对显著的性能产生负面影响。 例如，下面的代码使用的随机数生成器来创建具有范围从 0x0001 到 0x052F 中 1000 个字符的字符串。 尽管代码似乎使用字符串串联来将新字符附加到名为的现有字符串，但是`str`，它实际创建一个新<xref:System.String>串联的每个操作的对象。  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 可以使用<xref:System.Text.StringBuilder>类而不是<xref:System.String>类用于对字符串的值进行多个更改的操作。 与不同的实例<xref:System.String>类，<xref:System.Text.StringBuilder>对象是可变的; 当串联、 追加或删除从字符串的子字符串，在单个字符串执行的操作。 当您已完成修改的值<xref:System.Text.StringBuilder>对象，可以调用其<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法将其转换为字符串。 下面的示例将替换<xref:System.String>上一示例中用于连接为 0x0001 与 0x052F 到范围中的 1000 个随机字符<xref:System.Text.StringBuilder>对象。  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>区分区域性的操作与序号  
 成员<xref:System.String>类执行序号或区分区域性 （语言） 操作<xref:System.String>对象。 序号操作将对每个数值<xref:System.Char>对象。 区分区域性的操作作用于的值<xref:System.String>对象，并采用特定于区域性的大小写、 排序、 格式和考虑分析规则。 显式声明的区域性或隐式的当前区域性的上下文中执行区分区域性的操作。 它们执行相同的字符串时，两种类型的操作可以生成完全不同的结果。  
  
.NET 还支持通过使用固定区域性的不区分区域性的语义字符串操作 (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>)，这严格基于独立于区域的英语语言的区域性设置。 与其他不同<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>保证设置，固定区域性的设置保持一致的单个计算机上，从系统到系统，以及跨版本的.NET。 固定区域性可以跨所有区域性是视为一种类型的黑色框，以确保稳定性的字符串比较和排序。  
  
> [!IMPORTANT]
>  如果你的应用程序如文件名的符号标识符做出安全决定或命名管道，或有关持久化数据，如 XML 文件中的基于文本的数据，该操作应使用序号比较，而不是区分区域性的比较。 这是因为区分区域性的比较会有效时，生成不同结果根据区域性而序号比较仅取决于比较的字符的二进制值。  
  
> [!IMPORTANT]
>  执行字符串操作的大多数方法包括具有类型参数的重载<xref:System.StringComparison>，这样您就可以指定是否该方法所执行的序号或区分区域性的操作。 一般情况下，应调用此重载，以调用清除您的方法的意图。 有关最佳实践和使用序号和区分区域性的字符串操作的指导，请参阅[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 操作[大小写](#casing)，[分析和格式设置](#parsing)，[比较和排序](#comparison)，并[为确定相等性测试](#equality)可以是任一序号或区分区域性。 以下各节讨论每个类别的操作。  
  
> [!TIP]
>  应始终调用的方法重载，使调用清除您的方法的意图。 例如，而不是调用<xref:System.String.Compare%28System.String%2CSystem.String%29>要通过使用当前区域性的约定来执行区分区域性的比较两个字符串的方法应调用<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>具有值的方法<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>为`comparisonType`自变量。 有关详细信息，请参阅[有关使用字符串的最佳实践](~/docs/standard/base-types/best-practices-strings.md)。  

您可以下载[排序权重表](https://www.microsoft.com/en-us/download/details.aspx?id=10921)，包含在 Windows 操作系统、 排序和比较操作中使用的字符权重的信息的文本文件的一组和[默认 Unicode排序规则元素表](https://www.unicode.org/Public/UCA/latest/allkeys.txt)，适用于 Linux 和 macOS 的排序权重表。

<a name="casing"></a>   
### <a name="casing"></a>大小写  
 大小写规则确定如何更改大小写的 Unicode 字符;例如，从小写到大写。 通常情况下，字符串比较之前执行的大小写操作。 例如，一个字符串，可能会转换为大写，以便它可以与另一个大写的字符串进行比较。 可以将转换为小写通过调用一个字符串中的字符<xref:System.String.ToLower%2A>或<xref:System.String.ToLowerInvariant%2A>方法，并且你可以将它们转换为大写通过调用<xref:System.String.ToUpper%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 此外，还可以使用<xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType>方法将字符串转换为词首字母大写。  
  
 大小写的操作可以根据当前区域性、 指定的区域性或固定区域性的规则。 因为大小写映射可能会变化，具体取决于所用的区域性，大小写操作的结果可以因区域性。 在大小写的实际差异有三种：  
  
-   中的拉丁语 I 的大写首字母大小写映射的差异 (U + 0049)，拉丁文小写字母 I (U + 0069)，LATIN CAPITAL LETTER I (U + 0130)，上面的点和拉丁文小写字母无点 I (U + 0131)。 TR-TR （土耳其语 （土耳其）） 和 （阿塞拜疆，拉丁语） az-Latn-AZ 文化中，在和中的 tr、 az 和 az Latn 非特定区域性，LATIN CAPITAL LETTER I 的小写等效项是拉丁文小写字母无点 I、 和的拉丁文小写字母 I 的大写等效项是上面带点的拉丁文大写字母 I。 在所有其他文化中，其中包括固定区域性，拉丁文小写字母 I 和 LATIN CAPITAL LETTER 我是小写和大写等效项。  
  
     下面的示例演示如何设计的字符串比较，以防止文件系统访问权限可能会失败是否它依赖于区分区域性的大小写比较。 （固定区域性的大小写约定应该已使用。）  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   大小写映射中固定区域性和所有其他区域性之间的差异。 在这些情况下，使用固定区域性的大小写规则更改为大写或小写字符返回的相同字符。 对于所有其他区域性，它将返回不同的字符。 下表列出了一些受影响的字符。  
  
    |字符|如果更改为|返回|  
    |---------------|-------------------|-------------|  
    |微米登录 (U + 00B5)|大写|希腊文大写字母 MU (U +-39 C)|  
    |拉丁文大写字母 I 带点上方 (U + 0130)|小写|拉丁文小写字母 I (U + 0069)|  
    |拉丁文小写字母无点我 (U + 0131)|大写|拉丁文大写字母 I (U + 0049)|  
    |拉丁文小写字母长 S (U + 017F)|大写|拉丁文大写字母 S (U + 0053)|  
    |小写字母 Z 带抑扬符拉丁文大写字母 D (U + 01C 5)|小写|拉丁文小写字母 DZ 带抑扬符 (U + 01C 6)|  
    |组合希腊语 YPOGEGRAMMENI (U + 0345)|大写|希腊文大写字母 IOTA (U + 0399)|  
  
-   ASCII 字符范围中的两个字母大小写混合的对的大小写映射之间的差异。 在大多数文化中，两个字母大小写混合的对等于等效的双字母大写或小写字母对。 这是不为以下区域中的以下两个字母对，则返回 true，因为每种情况下它们不同于二合字母：  
  
    -   "lJ"和"nJ"HR-HR （克罗地亚语 （克罗地亚）） 区域性中。  
  
    -   "cH"cs CZ （捷克语 （捷克共和国）） 和 sk-SK （斯洛伐克语 （斯洛伐克）） 文化中。  
  
    -   "aA"DA-DK （丹麦语 （丹麦）） 区域性中。  
  
    -   "cS"、"dZ"、"dZS"、"nY"、"sZ"、"tY"和"zS"HU-HU （匈牙利语 （匈牙利）） 区域性中。  
  
    -   "cH"和"lL"es ES_tradnl （西班牙语 （西班牙，传统风格）） 区域性中。  
  
    -   "cH"、"gI"、"kH"、"nG""nH"、"pH"，"qU，"tH"和"tR"vi VN （越南语 （越南）） 区域性中的。  
  
     但是，很少会遇到的情况下，这些对区分区域性的比较在其中创建问题，因为这些对很少出现在固定的字符串或标识符。  
  
 下面的示例说明了一些在大小写规则区域性将字符串转换为大写时之间的差异。  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>分析和格式设置  
 格式设置和分析为反向操作。 格式设置规则确定如何将一个值，如日期和时间或数字转换为其字符串表示形式，而分析规则确定如何将字符串表示形式转换为一个值，例如日期和时间。 格式化和分析规则都依赖于区域性的约定。 下面的示例演示解释特定于区域性的日期字符串时，可能会出现多义性。 如果不知道用于生成的日期字符串的区域性的约定，不可能知道 2011-03-01、 2011 年 3 月 1 日和 2011-03/01-表示 2011 年 1 月 3 日或 2011 年 3 月 1 日。  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 同样，如下面的示例所示，单个字符串可以生成不同的日期，具体取决于在分析操作中使用的约定的区域性。  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>字符串比较和排序  
 用于比较和排序字符串的约定因因区域性而异。 例如，排序顺序可能基于拼音或基于字符的可视表示形式。 在东亚语言中，按文字的笔画和部首对字符进行排序。 排序也取决于字母表使用的排序语言和区域性。 例如，丹麦语中有“Æ”字符，它在字母表中排在“Z”之后。 此外，比较可以区分大小写或不区分大小写，并且在某些情况下的大小写规则也因区域性而异。 序号比较，但是，使用时比较和排序字符串的字符串中的单个字符的 Unicode 码位。  
  
 排序规则用于确定与每个其他 Unicode 字符的字母顺序和如何两个字符串进行比较。 例如，<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法比较两个字符串基于<xref:System.StringComparison>参数。 如果参数值<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>，该方法执行使用当前区域性的约定的语义比较，如果参数值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>，该方法执行序号比较。 因此，如以下示例所示，如果当前区域性为美国英语，在首次调用<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法 （使用区分区域性的比较） 将视为"a"小于"A"，但第二个调用同一方法 （使用序号比较） 将视为"a"大于"A"。  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET 支持 word、 字符串和序号排序规则：  
  
-   单词排序在其中某些非字母数字 Unicode 字符可能会有特殊的权重分配给他们执行区分区域性的比较的字符串。 例如，连字符 （-） 可能很小的权重分配给它，以便"coop"和"co-op"显示彼此排序列表中。 有关一系列<xref:System.String>方法比较两个字符串使用单词排序规则，请参阅[按类别的字符串操作](#ByCategory)部分。  
  
-   字符串排序还执行区分区域性的比较。 它相当于单词排序，只不过有任何特殊的情况下，并且所有的非字母数字符号放在所有字母数字 Unicode 字符之前。 可以通过调用通过使用字符串排序规则比较两个字符串<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>具有的方法重载`options`为参数提供的值为<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>。 请注意，这是.NET 提供的用于比较两个字符串使用字符串排序规则的唯一方法。  
  
-   序号排序对基于每个数值的字符串进行比较<xref:System.Char>字符串中的对象。 序号比较是自动区分大小写，因为一个字符的大写和小写版本具有不同的码位。 但是，如果用例并不重要，可以指定不区分大小写的序号比较。 这相当于将字符串转换为大写的通过使用固定区域性，然后对结果执行序号比较。 有关一系列<xref:System.String>方法比较两个字符串使用序号排序规则，请参阅[按类别的字符串操作](#ByCategory)部分。  
  
 区分区域性的比较是显式或隐式使用任何比较<xref:System.Globalization.CultureInfo>对象，包括由指定的固定区域性<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>属性。 隐式区域性是由指定的当前区域性<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性。 没有相当大的字母字符在排序顺序中的变体 (即，其字符<xref:System.Char.IsLetter%2A?displayProperty=nameWithType>属性返回`true`) 跨区域性。 可以指定通过提供使用特定区域性的约定的区分区域性的比较<xref:System.Globalization.CultureInfo>对象传递给字符串比较方法，如<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>。 可以指定使用当前区域性的约定，通过提供区分区域性的比较<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>，或任何成员<xref:System.Globalization.CompareOptions>以外的其他枚举<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>或<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>到相应重载的<xref:System.String.Compare%2A>方法。 一般适合用于排序而不是序号比较是区分区域性的比较。 序号比较是一般适合用于确定两个字符串是否相等 (即，用于确定标识) 而不是区分区域性的比较。  
  
 下面的示例说明了区域性敏感型和序号比较之间的差异。 该示例计算结果的三个字符串、"Apple"、"Æble"和"AEble"，以使用序号比较和 DA-DK 并 EN-US 区域性的约定 (其中每个为时的默认区域性<xref:System.String.Compare%2A>调用方法)。 因为丹麦语语言字符"存储"视为单个字母，并对其进行排序后"Z"字母表中，字符串"Æble"大于"Apple"。 但是，"Æble"是不被视为等效于"AEble"，因此"Æble"也是晚于"AEble"。 EN-US 区域性不包括字母"存储"，但将其视为等效于"AE"，解释了为什么"Æble"小于"Apple"但等于"AEble"。 序号比较，但是，将视为"Apple"小于"Æble"和"Æble"必须晚于"AEble"。  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 使用以下常规准则来选择适当的排序或字符串比较方法：  
  
-   如果您希望根据用户的区域性的字符串进行排序，您应该对它们基于当前区域性的约定进行排序。 如果用户的区域性发生更改，也将相应地更改排序字符串的顺序。 例如，同义词库应用程序应始终进行排序基于用户的区域性的单词。  
  
-   如果你想要进行排序的字符串根据特定区域性的约定，则应通过提供订购它们<xref:System.Globalization.CultureInfo>对象，表示该区域性的比较方法。 例如，教授学生特定语言设计的应用程序，在你希望字符串进行排序根据使用该语言的区域性之一的约定。  
  
-   如果您希望字符串的顺序，以跨区域性将保持不变，应基于固定区域性的约定也可以使用序号比较。 例如，您将使用序号排序来组织的文件、 进程、 互斥体的名称或命名管道。  
  
-   有关涉及安全决策 （例如用户名是否有效） 的比较，您始终应执行序号为确定相等性测试通过调用的重载<xref:System.String.Equals%2A>方法。  
  
> [!NOTE]
>  区分区域性的排序和大小写的字符串比较中使用的规则取决于版本的.NET。 在.NET Framework 4.5 和更高版本上运行[!INCLUDE[win8](~/includes/win8-md.md)]操作系统系统、 排序、 大小写、 规范化和 Unicode 字符信息是否符合 Unicode 6.0 标准。 在其他 Windows 操作系统的系统，它符合 Unicode 5.0 标准。 在.NET Core，这取决于基础操作系统支持的 Unicode 标准版本。 
  
 有关 word、 字符串和序号排序规则的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>主题。 有关何时使用每个规则的其他建议，请参阅[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)。  
  
 通常，不要调用比较方法，如字符串<xref:System.String.Compare%2A>直接以确定字符串的排序顺序。 相反，如排序方法通过调用比较方法<xref:System.Array.Sort%2A?displayProperty=nameWithType>或<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>。 下面的示例执行四个不同的排序操作 （使用当前区域性，使用固定区域性的单词排序、 序号排序和使用固定区域性的字符串排序单词排序），无需显式调用的字符串比较方法，尽管它们指定要使用的比较类型。 请注意，每种类型的排序将生成其数组中的字符串的唯一排序。  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  在内部，.NET 使用排序关键字支持区分区域性的字符串比较。 对于字符串中的每个字符，都赋予若干类排序权重，包括字母、大小写和变音符。 排序键，由表示<xref:System.Globalization.SortKey>类中，为特定字符串提供这些权重的库。 如果您的应用程序执行大量的搜索或排序对一组相同的字符串的操作，可以通过生成并存储它使用的所有字符串的排序键来提高其性能。 当需要进行排序或比较操作时，您将使用排序键，而不是字符串。 有关更多信息，请参见 <xref:System.Globalization.SortKey> 类。  
  
 如果未指定的字符串比较约定，如排序方法<xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>对字符串执行区分区域性的、 区分大小写的排序。 下面的示例演示如何更改当前区域性会影响排序字符串数组中的顺序。 它创建三个字符串的数组。 首先，它将 `System.Threading.Thread.CurrentThread.CurrentCulture` 属性设置为 en-US，并调用 <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> 方法。 结果的排序顺序基于排序为英语 （美国） 区域性的约定。 接着，此示例将 `System.Threading.Thread.CurrentThread.CurrentCulture` 属性设置为 da-DK 并再次调用 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法。 请注意，最终排序顺序与使用 en-US 时的结果不一样，因为这次使用的是针对丹麦语（丹麦）的排序约定。  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  如果你在比较字符串的主要用途是确定它们是否相等，则应调用<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。 通常情况下，应使用<xref:System.String.Equals%2A>要执行序号比较。 <xref:System.String.Compare%2A?displayProperty=nameWithType>方法主要用于对字符串进行排序。  
  
 字符串搜索方法，如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，还可以执行区分区域性的或序号字符串比较。 下面的示例演示使用序号和区分区域性的比较之间的差异<xref:System.String.IndexOf%2A>方法。 在其中的当前区域性为英语 （美国） 的区分区域性的搜索将视为"oe"以匹配连字"œ"的子字符串。 因为软连字符 (U + 00AD) 是零宽字符，则搜索将软连字符视为等效于<xref:System.String.Empty>和字符串的开头处找到的匹配项。 序号搜索，但是，找不到匹配项在任一情况下。  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>搜索字符串  
 字符串搜索方法，如<xref:System.String.StartsWith%2A?displayProperty=nameWithType>和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>，还可以执行区分区域性的或在指定的字符串中找到的序号字符串比较，以确定是否有字符或子字符串。  
  
 中的搜索方法<xref:System.String>类的单个字符，如搜索<xref:System.String.IndexOf%2A>方法或一组字符，如<xref:System.String.IndexOfAny%2A>方法中，所有执行序号搜索。 若要执行区分区域性的搜索的字符，必须调用<xref:System.Globalization.CompareInfo>等方法<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>或<xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>。 请注意，可以非常不同的搜索的字符使用序号和区分区域性的比较结果。 例如，如连字"存储"的预构成 Unicode 字符 (U + 00 C 6) 的搜索可能匹配正确的顺序，如 AE 及其组件的任何匹配项 （U + 041U + 0045），根据区域性。 下面的示例说明了之间的差异<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType>和<xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>方法搜索的单个字符时。 连字"存储"(U + 00E6) 是在字符串中找到"空中"时使用 EN-US 区域性的约定，但不是使用 DA-DK 区域性的约定时或执行序号比较时。  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 但是，<xref:System.String>类搜索字符串，而不是一个字符执行区分区域性的搜索，如果搜索选项未显式指定的类型参数的方法<xref:System.StringComparison>。 唯一的例外是<xref:System.String.Contains%2A>，该文件将执行序号搜索。  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>为确定相等性测试  
 使用<xref:System.String.Compare%2A?displayProperty=nameWithType>方法来确定两个字符串在排序顺序中的关系。 通常情况下，这是区分区域性的操作。 与此相反，调用<xref:System.String.Equals%2A?displayProperty=nameWithType>方法来测试相等性。 为确定相等性测试通常比较用户输入与某个已知的字符串，例如有效的用户名、 密码或文件系统路径，因为它通常是一个序号操作。  
  
> [!WARNING]
>  可以通过调用测试相等性<xref:System.String.Compare%2A?displayProperty=nameWithType>方法，并确定返回值是否为零。 但是，不建议这样做。 若要确定两个字符串，应调用的重载之一<xref:System.String.Equals%2A?displayProperty=nameWithType>方法。 若要调用的首选的重载为实例<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法或静态<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，因为这两种方法包括<xref:System.StringComparison?displayProperty=nameWithType>显式指定的比较类型的参数。  
  
 下面的示例说明了执行区分区域性的比较相等时应改为使用一个序号。 在这种情况下，代码的目的是通过执行不区分大小写比较的字符串"FILE://"与 URL 开头"FILE://"或"file://"开头的 Url 从禁止文件系统访问权限。 但是，如果以"file://"开头的 URL 上使用土耳其语 （土耳其） 区域性执行区分区域性的比较，则为确定相等性比较失败，因为小写"i"的土耳其语的大写等效项为"i"而不是"I"。 因此，无意中允许的文件系统访问。 但是，如果执行序号比较，则为确定相等性比较成功，并拒绝文件系统访问。  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>标准化  
 某些 Unicode 字符具有多种表示形式。 例如，下面的代码点的任何可表示字母"ắ":  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 单个字符的多种表示形式使搜索、 排序、 匹配和其他字符串操作变得复杂。  
  
 Unicode 标准定义了名为返回一个 Unicode 字符的任何其等效的二进制表示形式的二进制表示形式的规范化的过程。 规范化可以使用多种算法，调用下列不同的规则的规范化形式。 .NET 支持 Unicode 范式 C、 D、 KC 和 KD。 当字符串被正常化为相同的范式时，它们可以通过使用序号比较进行比较。  
  
 序号比较是对应的 Unicode 标量值的二进制比较<xref:System.Char>中每个字符串的对象。 <xref:System.String>类包括许多方法可以执行序号比较，其中包括：  
  
-   任何重载<xref:System.String.Compare%2A>， <xref:System.String.Equals%2A>， <xref:System.String.StartsWith%2A>， <xref:System.String.EndsWith%2A>， <xref:System.String.IndexOf%2A>，并且<xref:System.String.LastIndexOf%2A>方法包括<xref:System.StringComparison>参数。 如果提供的值，该方法执行序号比较<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase>为此参数。  
  
-   重载<xref:System.String.CompareOrdinal%2A>方法。  
  
-   默认情况下，如使用序号比较的方法<xref:System.String.Contains%2A>， <xref:System.String.Replace%2A>，和<xref:System.String.Split%2A>。  
  
-   搜索的方法<xref:System.Char>值或中的元素<xref:System.Char>字符串实例中的数组。 此类方法包括<xref:System.String.IndexOf%28System.Char%29>和<xref:System.String.Split%28System.Char%5B%5D%29>。  
  
 您可以确定一个字符串，指示是否被规范化为范式 C 通过调用<xref:System.String.IsNormalized?displayProperty=nameWithType>方法，或者可以调用<xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法，以确定是否将字符串规范化为指定的范式。 您还可以调用<xref:System.String.Normalize?displayProperty=nameWithType>方法将字符串转换到范式 C，也可以调用<xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType>方法将字符串转换为指定的范式。 有关规范化和比较字符串的分步信息，请参阅<xref:System.String.Normalize>和<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法。  
  
 下面的简单示例说明了字符串标准化。 它在三个不同字符串中的三种不同方式定义了字母"ố"，并使用序号比较相等来确定每个字符串不同于其他两个字符串。 它然后将每个字符串转换为受支持的规范化窗体，并再次执行序号比较每个字符串中指定的范式。 在每种情况下，第二个相等性测试显示字符串相等。  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 有关规范化和规范化窗体的详细信息，请参阅<xref:System.Text.NormalizationForm?displayProperty=nameWithType>，以及[Unicode 标准附录 #15: Unicode 范式](https://unicode.org/reports/tr15/)并且[规范化常见问题解答](https://www.unicode.org/faq/normalization.html)上unicode.org 网站。  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>按类别的字符串操作  
 <xref:System.String>类提供用于比较字符串，测试字符串是否相等，查找字符或字符串，修改字符串，提取字符串的组合字符串，格式化值，复制字符串的字符串中子字符串的成员和规范化字符串。  
  
### <a name="comparing-strings"></a>比较字符串  
 您可以比较字符串来确定二者在排序顺序中的相对位置通过使用以下<xref:System.String>方法：  
  
-   <xref:System.String.Compare%2A> 返回一个整数，指示一个字符串在排序顺序中第二个字符串的关系。  
  
-   <xref:System.String.CompareOrdinal%2A> 返回一个整数，指示一个根据其码位比较的第二个字符串的字符串的关系。  
  
-   <xref:System.String.CompareTo%2A> 返回一个整数，指示当前的字符串实例与第二个字符串在排序顺序中的关系。 <xref:System.String.CompareTo%28System.String%29>方法提供<xref:System.IComparable>并<xref:System.IComparable%601>实现<xref:System.String>类。  
  
### <a name="testing-strings-for-equality"></a>测试字符串相等  
 在调用<xref:System.String.Equals%2A>方法来确定两个字符串是否相等。 实例<xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>和静态<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>重载允许您指定比较是否区分区域性的或序号，以及是否考虑或忽略大小写。 为确定相等性的大多数测试是序号，并确定为系统资源 （如文件系统对象） 的访问权限为确定相等性比较应始终为序号。  
  
### <a name="finding-characters-in-a-string"></a>查找字符串中的字符  
 <xref:System.String>类包括两种类型的搜索方法：  
  
-   返回的方法<xref:System.Boolean>值，以指示特定的子字符串中是否存在字符串实例。 其中包括<xref:System.String.Contains%2A>， <xref:System.String.EndsWith%2A>，和<xref:System.String.StartsWith%2A>方法。  
  
-   指示子字符串的字符串实例中的起始位置的方法。 其中包括<xref:System.String.IndexOf%2A>， <xref:System.String.IndexOfAny%2A>， <xref:System.String.LastIndexOf%2A>，和<xref:System.String.LastIndexOfAny%2A>方法。  
  
> [!WARNING]
>  如果你想要搜索字符串中的特定模式而不是特定的子字符串，则应使用正则表达式。 有关详细信息，请参阅[.NET 正则表达式](~/docs/standard/base-types/regular-expressions.md)。  
  
### <a name="modifying-a-string"></a>修改字符串  
 <xref:System.String>类包括以下方法看起来要修改字符串的值：  
  
-   <xref:System.String.Insert%2A> 将字符串插入到当前<xref:System.String>实例。  
  
-   <xref:System.String.PadLeft%2A> 字符串的开头处插入指定字符的一个或多个匹配项。  
  
-   <xref:System.String.PadRight%2A> 字符串的末尾处插入指定字符的一个或多个匹配项。  
  
-   <xref:System.String.Remove%2A> 删除从当前的子字符串<xref:System.String>实例。  
  
-   <xref:System.String.Replace%2A> 子字符串替换为另一个子字符串在当前<xref:System.String>实例。  
  
-   <xref:System.String.ToLower%2A> 和<xref:System.String.ToLowerInvariant%2A>字符串中的所有字符都转换为小写。  
  
-   <xref:System.String.ToUpper%2A> 和<xref:System.String.ToUpperInvariant%2A>将字符串中的所有字符都转换为大写。  
  
-   <xref:System.String.Trim%2A> 开始位置和字符串的末尾移除所有空白字符。  
  
-   <xref:System.String.TrimEnd%2A> 删除字符串的末尾出现的所有字符。  
  
-   <xref:System.String.TrimStart%2A> 从字符串的开头移除所有空白字符。  
  
> [!IMPORTANT]
>  所有字符串修改方法都返回一个新<xref:System.String>对象。 它们不会修改当前实例的值。  
  
### <a name="extracting-substrings-from-a-string"></a>从字符串中提取子字符串  
 <xref:System.String.Split%2A?displayProperty=nameWithType>方法将单个字符串拆分为多个字符串。 该方法的重载，可以指定多个分隔符，以确定最大数量的子字符串中提取方法，并确定是否包括在返回的字符串为空字符串 （它是相邻的分隔符时发生）。  
  
### <a name="combining-strings"></a>组合字符串  
 以下<xref:System.String>方法可用来进行字符串串联：  
  
-   <xref:System.String.Concat%2A> 将合并成单个字符串的一个或多个子字符串。  
  
-   <xref:System.String.Join%2A> 将一个或多个到单个元素的子字符串连接在一起，并添加每个子字符串之间的分隔符。  
  
### <a name="formatting-values"></a>设置值的格式  
 <xref:System.String.Format%2A?displayProperty=nameWithType>方法使用复合格式设置功能来在字符串中的一个或多个占位符替换为某些对象或值的字符串表示形式。 <xref:System.String.Format%2A>方法通常用于执行以下操作：  
  
-   若要在字符串中嵌入的数字值的字符串表示形式。  
  
-   若要在字符串中嵌入的日期和时间值的字符串表示形式。  
  
-   若要在字符串中嵌入一个枚举值的字符串表示形式。  
  
-   若要嵌入支持某些对象的字符串表示形式<xref:System.IFormattable>字符串中的接口。  
  
-   若要从右对齐或左对齐更大的字符串中的字段中的子字符串。  
  
 有关格式设置操作和示例的详细信息，请参阅<xref:System.String.Format%2A>重载摘要。  
  
### <a name="copying-a-string"></a>复制字符串  
 您可以通过调用以下<xref:System.String>方法，以便可以字符串的副本：  
  
-   <xref:System.String.Clone%2A> 返回对现有的引用<xref:System.String>对象。  
  
-   <xref:System.String.Copy%2A> 创建现有字符串的副本。  
  
-   <xref:System.String.CopyTo%2A> 将字符串的一部分复制到字符数组。  
  
### <a name="normalizing-a-string"></a>规范化字符串  
 Unicode 字符，单个字符可具有多个代码点。 规范化将相同的二进制表示形式转换为这些等效字符。 <xref:System.String.Normalize%2A?displayProperty=nameWithType>方法执行规范化和<xref:System.String.IsNormalized%2A?displayProperty=nameWithType>方法确定是否规范化字符串。  
  
 有关详细信息和示例，请参阅[规范化](#Normalization)本主题前面的部分。  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">排序权重表为 Windows 操作系统</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">默认 Unicode 排序规则 Elemeent 表，适用于 Linux 和 macOS</related>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
    <related type="Article" href="http://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">在 .NET Framework 中使用字符串的最佳做法</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.String" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本节内容：  
  
 [重载的构造函数语法](#Syntax)   
 [参数](#Params)   
 [异常](#Exceptions)   
 [我调用哪个方法？](#Tasks)   
 [创建字符串](#Creating_Strings)   
 [处理重复字符串](#Repetitive)   
 实例化字符串的示例：   
 [使用字符串赋值](#Ctor1_Example)  
 [使用的字符数组](#Ctor2_Example)  
 [使用字符数组的一部分并重复单个字符](#Ctor3_Example)  
 [使用指向字符数组的指针](#Ctor4_Example)  
 [使用指针和数组的范围](#Ctor5_Example)  
 [使用指向有符号的字节数组的指针](#Ctor6_Example)  
[版本信息](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>重载的构造函数语法  
 字符串构造函数分为两类： 不带指针参数，以及使用指针参数。 使用指针的构造函数不符合 CLS 規格。 此外，Visual Basic 不支持使用指针，并且 C# 要求使用指针不安全的上下文中运行的代码。 有关详细信息，请参阅 [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md)。  
  
 选择重载方法的其他指导，请参阅[我调用哪个方法？](#Tasks)  
  
 `String(Char[] value)`  
 初始化为由 Unicode 字符数组的值的新实例。 此构造函数复制 Unicode 字符 ([示例](#Ctor2_Example))。  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 初始化为由 Unicode 字符，该数组和一个长度内的起始字符位置的数组的值的新实例 ([示例](#Ctor3_Example))。  
  
 `String(Char c, Int32 count)`  
 由指定的 Unicode 字符指示的值的新实例的初始化重复指定的次数的 ([示例](#Ctor3_Example))。  
  
 `String(char* value)`  
 **(不符合 cls 的)** 初始化为由指向 null 字符终止的 Unicode 字符数组指示的值的新实例 (U + 0000 或 \0)。 ([示例](#Ctor4_Example))。  
  
 权限： <xref:System.Security.SecurityCriticalAttribute>，直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(不符合 cls 的)** 初始化为由指向 Unicode 字符，该数组和一个长度内的起始字符位置的数组的指示的值的新实例。 构造函数复制中的 Unicode 字符`value`从索引处开始`startIndex`和结束索引处`startIndex`  +  `length` – 1 ([示例](#Ctor5_Example))。  
  
 权限： <xref:System.Security.SecurityCriticalAttribute>，直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。  
  
 `String(SByte* value)`  
 **(不符合 cls 的)** 初始化为由指向 8 位有符号整数的数组的指示的值的新实例。 假定数组来表示使用当前系统代码页编码的字符串 (即指定的编码<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。 构造函数处理中的字符`value`从指定的指针，直到达到 null 字符 (0x00) 位置 ([示例](#Ctor6_Example))。  
  
 权限： <xref:System.Security.SecurityCriticalAttribute>，直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(不符合 cls 的)** 初始化为由指向 8 位有符号的整数，该数组和一个长度内的起始位置的数组的指示的值的新实例。  假定数组来表示使用当前系统代码页编码的字符串 (即指定的编码<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>)。 构造函数处理从值开始的字符`startIndex`结束时间`startIndex`  +  `length` – 1 ([示例](#Ctor6_Example))。  
  
 权限： <xref:System.Security.SecurityCriticalAttribute>，直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(不符合 cls 的)** 初始化为由指向 8 位有符号整数，该数组长度内的起始位置的数组的指示的值的新实例和一个<xref:System.Text.Encoding>对象。  
  
 权限： <xref:System.Security.SecurityCriticalAttribute>，直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。  
  
<a name="Params"></a>   
## <a name="parameters"></a>参数  
 下面是使用参数的完整列表<xref:System.String>不包括指针参数的构造函数。 使用每个重载的参数，请参阅上述重载语法。  
  
|参数|类型|描述|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Unicode 字符的数组。|  
|`c`|<xref:System.Char>|一个 Unicode 字符。|  
|`startIndex`|<xref:System.Int32>|中的起始位置`value`的新字符串中的第一个字符。<br /><br /> 默认值： 0|  
|`length`|<xref:System.Int32>|中的字符数`value`要包括在新的字符串中。<br /><br /> 默认值： <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|数乘以字符`c`重复新的字符串中。 如果`count`为零，新对象的值是<xref:System.String.Empty?displayProperty=nameWithType>。|  
  
 下面是使用参数的完整列表<xref:System.String>包括指针参数的构造函数。 使用每个重载的参数，请参阅上述重载语法。  
  
|参数|类型|描述|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> 或<br /><br /> <xref:System.SByte>\*|指向以 null 结尾的 Unicode 字符数组或 8 位有符号整数的数组的指针。 如果`value`是`null`或空数组的新字符串的值为<xref:System.String.Empty?displayProperty=nameWithType>。|  
|`startIndex`|<xref:System.Int32>|新的字符串中定义的第一个字符的数组元素的索引。<br /><br /> 默认值： 0|  
|`length`|<xref:System.Int32>|要用于创建新的字符串的数组元素数。 如果长度为零，该构造函数创建一个字符串，其值<xref:System.String.Empty?displayProperty=nameWithType>。<br /><br /> 默认值： <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|一个对象，指定如何`value`数组进行编码。<br /><br /> 默认值： <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>，或系统的当前 ANSI 代码页|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>异常  
 下面是由不包括指针参数的构造函数引发的异常的列表。  
  
|例外|条件|引发的|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` 为 `null`。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex``length`，或`count`小于零。<br /><br /> 或<br /><br /> `startIndex` 和 `length` 之和大于 `value` 中的元素数。<br /><br /> 或<br /><br /> `count` 小于零。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 下面是由包含指针参数的构造函数引发的异常的列表。  
  
|例外|条件|引发的|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` 指定包含无效的 Unicode 字符的数组。<br /><br /> 或<br /><br /> `value` 或`value`  +  `startIndex`指定的地址小于 64k。<br /><br /> 或<br /><br /> 一个新<xref:System.String>无法初始化实例，从`value`字节数组的因为`value`不使用默认代码页编码。|所有构造函数的指针。|  
|<xref:System.ArgumentNullException>|`value` 为 null。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|当前进程不具有对所有通过地址访问的字符的读取访问权限。<br /><br /> 或<br /><br /> `startIndex` 或 `length` 小于零，`value` + `startIndex` 导致指针溢出，或者当前进程不具有对所有寻址字符的读取访问权限。<br /><br /> 或<br /><br /> 新字符串的长度为太大，无法分配。|所有构造函数的指针。|  
|<xref:System.AccessViolationException>|`value`或`value`  +  `startIndex`  +  `length` – 1，指定了无效的地址。|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>我调用哪个方法？  
  
|到|调用或使用|  
|--------|-----------------|  
|创建一个字符串。|从字符串文字或现有字符串的分配 ([示例](#Ctor1_Example))|  
|从整个字符数组创建字符串。|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([示例](#Ctor2_Example))|  
|从字符数组的一部分创建的字符串。|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([示例](#Ctor3_Example))|  
|创建重复多次的同一字符的字符串。|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([示例](#Ctor3_Example))|  
|从指针到 Unicode 或宽字符数组创建字符串。|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|从 Unicode 或宽字符数组的一部分创建一个字符串，使用它的指针。|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|从 c + + 创建字符串`char`数组。|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> 或<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|创建从 ASCII 字符的字符串。|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>创建字符串  
 最常用的方法以编程方式创建字符串是简单的赋值，如中所示[本例](#Ctor1_Example)。 <xref:System.String>类还包括四种类型的构造函数重载，可从以下值创建字符串：  
  
-   从字符数组 （数组的 UTF 16 编码的字符）。 您可以创建一个新<xref:System.String>整个数组或它的一部分中的字符的对象。 <xref:System.String.%23ctor%28System.Char%5B%5D%29>构造函数将所有字符数组中都复制到新的字符串。 <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>索引中的字符复制构造函数`startIndex`到索引`startIndex`  +  `length` – 1 到新的字符串。 如果`length`为零，新的字符串的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
     如果你的代码重复实例化具有相同的值的字符串，可以通过使用创建字符串的替代方法来提高应用程序的性能。 有关详细信息，请参阅[处理重复字符串](#Repetitive)。  
  
-   通过单个字符，这是一个，或更多次使用的重复的零<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>构造函数。 如果`count`为零，新的字符串的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   从指向以 null 结尾的字符数组的指针，通过使用<xref:System.String.%23ctor%28System.Char%2A%29>或<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>构造函数。 整个数组或指定范围内可用于初始化字符串。 构造函数将复制从指定的指针或从指定的指针加上启动的 Unicode 字符序列`startIndex`直到结束数组或为`length`字符。 如果`value`是 null 指针或`length`为零，该构造函数创建一个字符串，其值<xref:System.String.Empty?displayProperty=nameWithType>。 如果复制操作继续到数组末尾，数组不是以 null 结尾的构造函数行为与系统相关。 此类条件可能会导致访问冲突。  
  
     如果数组包含任何嵌入的 null 字符 (U + 0000 或 \0) 和<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>调用重载，字符串实例包含`length`字符包括任何嵌入的 null 值。 下面的示例演示包含两个空字符的 10 个元素数组的指针传递到会发生什么情况<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>方法。 由于地址是数组的开头，并且数组中的所有元素都都要添加到字符串，该构造函数实例化具有 10 个字符，包括两个嵌入的 null 的字符串。 另一方面，如果将相同的数组传递给<xref:System.String.%23ctor%28System.Char%2A%29>构造函数，结果是不包括第一个空字符的四个字符字符串。  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     该数组必须包含 Unicode 字符。 在 c + +，这意味着必须为字符数组定义作为托管<xref:System.Char>[] 类型或非托管`wchar_t`[] 类型。  
  
     如果<xref:System.String.%23ctor%28System.Char%2A%29>调用重载和数组不是以 null 结尾，或者如果<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>调用重载和`startIndex`  +  `length`-1 包括为字符序列，其外部内存分配的范围构造函数的行为是依赖于系统和可能出现访问冲突。 此外，Intel Itanium 处理器上调用<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>构造函数可能会引发<xref:System.DataMisalignedException>异常。 如果发生这种情况，调用<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>相反。  
  
-   从指向一个有符号的字节数组的指针。 整个数组或指定范围内可用于初始化字符串。 可以通过使用默认代码页编码，解释的字节序列的或可以构造函数调用中指定的编码。 如果构造函数会尝试实例化整个数组，它不是以 null 结尾的字符串，或者从数组的范围`value`  +  `startIndex`到`value`  +  `startIndex`  +  `length` -1 表示为数组分配的内存之外，此构造函数的行为是依赖于系统，可能出现访问冲突。  
  
     包括作为参数的有符号的字节数组的三个构造函数主要用于将 c + + 转换`char`数组化为一个字符串，在此示例中所示：  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     如果数组包含值为 0 的任何 null 字符 (\0) 或字节和<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>调用重载，字符串实例包含`length`字符包括任何嵌入的 null 值。 下面的示例演示包含两个空字符的 10 个元素数组的指针传递到会发生什么情况<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>方法。 由于地址是数组的开头，并且数组中的所有元素都都要添加到字符串，该构造函数实例化具有 10 个字符，包括两个嵌入的 null 的字符串。 另一方面，如果将相同的数组传递给<xref:System.String.%23ctor%28System.SByte%2A%29>构造函数，结果是不包括第一个空字符的四个字符字符串。  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     因为<xref:System.String.%23ctor%28System.SByte%2A%29>并<xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>构造函数将解释`value`通过使用默认的 ANSI 代码页，调用这些构造函数的完全相同的字节数组可能创建不同的系统具有不同的值的字符串。  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>处理重复字符串  
 使用应用程序分析或解码的文本流通常<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>构造函数或<xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法以将字符序列转换为字符串。 重复使用相同的值而不是创建和重复使用一个字符串创建新字符串，浪费内存。 如果你很可能会反复创建相同的字符串值，通过调用<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>构造函数，即使您不知道在继续学习这些相同的字符串值可能是，可以改为使用查找表。  
  
 例如，假设您读取和分析从包含 XML 标记和特性的文件的字符流。 当分析流时，反复遇到某些令牌 （即，具有符号的含义的字符序列）。 等效于字符串"0"、"1"、"true"和"false"的令牌会在 XML 流中发生的频率。  
  
 而不是将每个令牌转换成一个新字符串，可以创建<xref:System.Xml.NameTable?displayProperty=nameWithType>对象以保存经常出现的字符串。 <xref:System.Xml.NameTable>对象可以改善性能，因为它无需分配临时内存中检索存储的字符串。 当遇到一个令牌时，使用<xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法以从表中检索令牌。 如果令牌存在，该方法将返回对应的字符串。 如果该令牌不存在，则使用<xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法以向表中插入令牌并获取相应的字符串。  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>示例 1： 使用字符串赋值  
 下面的示例通过将其分配字符串文本创建一个新字符串。 它通过将第一个字符串的值分配给它创建第二个字符串。 这些是实例化一个新的两个最常见方法<xref:System.String>对象。  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>示例 2： 使用的字符数组  
 下面的示例演示如何创建一个新<xref:System.String>字符数组中的对象。  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>示例 3： 使用字符数组的一部分，并重复单个字符  
 下面的示例演示如何创建一个新<xref:System.String>字符数组，以及如何创建一个新的部分中的对象<xref:System.String>包含单个字符的多个匹配项的对象。  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>示例 4： 使用指向字符数组的指针  
 下面的示例演示如何创建一个新<xref:System.String>从指针到字符数组的对象。 必须通过使用编译 C# 示例`/unsafe`编译器开关。  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>示例 5： 实例化的字符串指针和数组的范围  
 下面的示例将检查一段或感叹号字符数组的元素。 如果找到一个对象，它实例化前标点符号的字符数组中的字符串。 如果没有，它实例化的字符串数组的全部内容。 必须使用编译 C# 示例`/unsafe`编译器开关。  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>示例 6： 实例化从指针到带符号的字节数组的字符串  
 下面的示例演示如何创建的实例<xref:System.String>类的<xref:System.String.%23ctor%28System.SByte%2A%29>构造函数。  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>版本信息  
 .NET Framework  
 所有重载都受都支持中： 4.5、 4、 3.5、 3.0、 2.0、 1.1 和 1.0  
  
 .NET Framework Client Profile  
 所有重载都受都支持中： 4、 3.5 SP1  
  
 可移植类库  
 所有重载，而无需<xref:System.SByte>`*`参数支持  
  
 用于 Windows 应用商店应用的 .NET  
 所有重载，而无需<xref:System.SByte>`*`中支持参数： Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">指向以 null 终止的 Unicode 字符数组的指针。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 Unicode 字符数组的指定指针指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">当前进程不具有对所有通过地址访问的字符的读取访问权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 指定了包含无效 Unicode 字符的数组，或者 <paramref name="value" /> 指定了小于 64000 的地址。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字符的数组。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由 Unicode 字符数组指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">一个指针，指向以 null 结尾的 8 位带符号整数数组。 使用当前系统代码页编码（即由 <see cref="P:System.Text.Encoding.Default" /> 指定的编码）来解释整数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 8 位有符号整数数组的指针指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">如果 <paramref name="value" /> 采用 ANSI 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">要初始化的新字符串的长度（该长度由 <paramref name="value" /> 的 null 终止字符确定）太大，无法分配。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> 指定的地址无效。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">一个 Unicode 字符。</param>
        <param name="count">
          <c>c</c> 出现的次数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由重复指定次数的指定 Unicode 字符指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指向 Unicode 字符数组的指针。</param>
        <param name="startIndex">
          <c>value</c> 内的起始位置。</param>
        <param name="length">要使用的 <c>value</c> 内的字符数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 Unicode 字符数组的指定指针指示的值、该数组内的起始字符位置和一个长度指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，<paramref name="value" /> + <paramref name="startIndex" /> 导致指针溢出，或者当前进程不具有对所有寻址字符的读取访问权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 指定的数组包含无效的 Unicode 字符，或 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64000。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Unicode 字符的数组。</param>
        <param name="startIndex">
          <c>value</c> 内的起始位置。</param>
        <param name="length">要使用的 <c>value</c> 内的字符数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由 Unicode 字符数组、该数组内的起始字符位置和一个长度指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
或 
<paramref name="startIndex" /> 和 <paramref name="length" /> 之和大于 <paramref name="value" /> 中的元素数。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指向 8 位带符号整数数组的指针。 使用当前系统代码页编码（即由 <see cref="P:System.Text.Encoding.Default" /> 指定的编码）来解释整数。</param>
        <param name="startIndex">
          <c>value</c> 内的起始位置。</param>
        <param name="length">要使用的 <c>value</c> 内的字符数。</param>
        <summary>将 <see cref="T:System.String" /> 类的新实例初始化为由指向 8 位有符号整数数组的指定指针、该数组内的起始位置和一个长度指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
或 
由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址对于当前平台而言太大；也就是说，此地址计算溢出。  
  
或 
要初始化的新字符串的长度太大，无法分配。</exception>
        <exception cref="T:System.ArgumentException">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64K。  
  
或 
如果 <paramref name="value" /> 采用 ANSI 进行编码，那么无法使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定的地址无效。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">指向 8 位带符号整数数组的指针。</param>
        <param name="startIndex">
          <c>value</c> 内的起始位置。</param>
        <param name="length">要使用的 <c>value</c> 内的字符数。</param>
        <param name="enc">一个对象，用于指定如何对 <c>value</c> 所引用的数组进行编码。 如果 <c>enc</c> 为 <see langword="null" />，则假定以 ANSI 编码。</param>
        <summary>将 <see cref="T:System.String" /> 的新实例初始化为由指向 8 位有符号整数数组的指定指针、该数组内的起始位置、长度以及 <see cref="T:System.Text.Encoding" /> 对象指示的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有关示例和全面的使用情况信息和其他`String`构造函数重载，请参阅<xref:System.String.%23ctor%2A>摘要的构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
或 
由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址对于当前平台而言太大；也就是说，此地址计算溢出。  
  
或 
要初始化的新字符串的长度太大，无法分配。</exception>
        <exception cref="T:System.ArgumentException">由 <paramref name="value" /> + <paramref name="startIndex" /> 指定的地址小于 64K。  
  
或 
未能使用 <paramref name="value" /> 初始化 <see cref="T:System.String" /> 的新实例，假定 <paramref name="value" /> 按照 <paramref name="enc" /> 的指定进行编码。</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />、<paramref name="startIndex" /> 和 <paramref name="length" /> 共同指定的地址无效。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">当前的字符串中的位置。</param>
        <summary>获取当前 <see cref="T:System.Char" /> 对象中位于指定位置的 <see cref="T:System.String" /> 对象。</summary>
        <value>位于 <paramref name="index" /> 位置的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`参数是从零开始。  
  
 此属性返回<xref:System.Char>对象中指定的位置`index`参数。 但是，可能由多个表示 Unicode 字符<xref:System.Char>。 使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>类，以便使用 Unicode 字符而不是<xref:System.Char>对象。 有关详细信息，请参阅中的"Char 对象和 Unicode 字符"一节<xref:System.String>类概述。  
  
 在 C# 中，<xref:System.String.Chars%2A>属性是一个索引器。 在 Visual Basic 中，它是默认属性的<xref:System.String>类。 每个<xref:System.Char>可以通过使用如下所示的代码访问字符串中的对象。  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示如何在例程中使用此索引器来验证字符串。  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 大于或等于此对象的长度或小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回对此 <see cref="T:System.String" /> 实例的引用。</summary>
        <returns>此 <see cref="T:System.String" /> 实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值不是此实例; 的一个独立副本它是只是另一个视图相同的数据。 使用<xref:System.String.Copy%2A>或<xref:System.String.CopyTo%2A>方法来创建一个单独<xref:System.String>使用值与此实例相同的对象。  
  
 因为<xref:System.String.Clone%2A>方法仅返回现有的字符串实例，则几乎不需要直接调用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个指示二者在排序顺序中的相对位置的整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Compare%2A> 方法的所有重载返回一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
|“值”|条件|  
|-----------|---------------|  
|小于零|第一个子字符串在排序顺序中位于第二个的子字符串。|  
|零|子字符串在排序顺序中出现的位置相同或 `length` 为零。|  
|大于零|第一个子字符串在排序顺序中的第二个子字符串之后。|  
  
> [!WARNING]
>  只要有可能，应调用的重载<xref:System.String.Compare%2A>方法，包括<xref:System.StringComparison>参数。 有关详细信息，请参阅[有关使用字符串的最佳实践](~/docs/standard/base-types/best-practices-strings.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">在 .NET Framework 中使用字符串的最佳做法</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个指示二者在排序顺序中的相对位置的整数。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些字符的组合被视为单个字符或大写和小写字符进行比较以特定方式，可以指定区域性或字符的排序顺序取决于前的字符，或在其后。  
  
 使用单词排序规则执行比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  比较字符串时，应调用<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，要求您显式指定该方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](~/docs/standard/base-types/best-practices-strings.md)。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了两个字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，然后其余的字符的字符串被视为更高版本。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 下面的示例调用<xref:System.String.Compare%28System.String%2CSystem.String%29>方法来比较三个集的字符串。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 在以下示例中，`ReverseStringComparer`类演示如何评估使用的两个字符串<xref:System.String.Compare%2A>方法。  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String)" />方法执行区分区域性的比较时不考虑此类字符。 例如，如果运行下面的代码[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，"动物"与"ani 邮件"（使用软连字符或 U + 00AD） 的区分区域性的比较该值指示两个字符串是否相等。  
  
[！ 代码 csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [！ 代码 vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
若要识别的字符串比较中的可忽略字符，调用<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为`comparisonType`参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些字符的组合被视为单个字符或大写和小写字符进行比较以特定方式，可以指定区域性或字符的排序顺序取决于前的字符，或在其后。  
  
 使用单词排序规则执行比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  比较字符串时，应调用<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，要求您显式指定该方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](~/docs/standard/base-types/best-practices-strings.md)。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了两个字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，然后其余的字符的字符串被视为更高版本。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>方法相当于使用<xref:System.String.ToUpper%2A>或<xref:System.String.ToLower%2A>比较字符串时。  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />方法执行区分区域性的比较时不考虑此类字符。 例如，如果运行下面的代码[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，"动物"与"Ani 邮件"（使用软连字符或 U + 00AD） 的区分区域性的、 不区分大小写比较该值指示两个字符串是否相等。  
  
[！ 代码 csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [！ 代码 vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
若要识别的字符串比较中的可忽略字符，调用<see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的规则比较两个指定的 <see cref="T:System.String" /> 对象，并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中的位置相同。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`参数指示是否比较应使用当前或固定区域性，接受或忽略大小写的比较数，或使用 word （区分区域性） 或序号 （不区分区域性的） 排序规则。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了两个字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，其余字符的字符串则认为较大。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 以下示例比较了三个版本的字母"I"。 区域性，是否忽略大小写，和是否执行序号比较的选择会影响结果。  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <see cref="T:System.StringComparison" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />方法执行区分区域性的比较时不考虑此类字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.StringComparison.Ordinal" />或<see cref="F:System.StringComparison.OrdinalIgnoreCase" />为<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">一个对象，提供区域性特定的比较信息。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写，并使用区域性特定的信息干预比较），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较使用`culture`参数来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些字符的组合被视为单个字符或大写和小写字符进行比较以特定方式，可以指定区域性或字符的排序顺序取决于前的字符，或在其后。  
  
 使用单词排序规则执行比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了两个字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，然后其余的字符的字符串被视为更高版本。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 下面的示例演示如何区域性可能会影响比较。 捷克语-捷克共和国区域性，在"ch"是单个字符的最大"d"。 但是，在英语-美国区域性"ch"包含两个字符，并且"c"小于"d"。  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />方法执行区分区域性的比较时不考虑此类字符。 例如，如果运行下面的代码[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，不区分大小写比较的"动物"与"Ani 邮件"（使用软连字符或 U + 00AD） 使用固定区域性指示两个字符串相等。  
  
[！ 代码 csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [！ 代码 vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
若要识别的字符串比较中的可忽略字符，调用<see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <param name="culture">提供区域性特定的比较信息的区域性。</param>
        <param name="options">要在执行比较时使用的选项（如忽略大小写或符号）。</param>
        <summary>对两个指定的 <see cref="T:System.String" /> 对象进行比较，使用指定的比较选项和区域性特定的信息来影响比较，并返回一个整数，该整数指示这两个字符串在排序顺序中的关系。</summary>
        <returns>一个 32 位带符号整数，该整数指示 <paramref name="strA" /> 与 <paramref name="strB" /> 之间的词法关系，如下表所示 
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 在排序顺序中出现的位置相同。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 在排序顺序中位于 <paramref name="strB" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较使用`culture`参数来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些组合字符被视为单个字符、 大写和小写字符进行比较以特定方式，可以指定特定区域性或依赖于字符的字符的排序顺序的前面或后面。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要用于在排序或按字母顺序排列的操作中使用。 其值不应在方法调用的主要用途是确定两个字符串是否相等 （即，当方法调用的目的是要测试其返回值为 0） 时使用。 若要确定两个字符串是否相等，请调用<xref:System.String.Equals%2A>方法。  
  
 可以通过进一步指定比较`options`参数，它包含一个或多个成员的<xref:System.Globalization.CompareOptions>枚举。 但是，此方法的目的是执行区分区域性的字符串比较，因为<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值不起任何作用。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括<xref:System.String.Empty?displayProperty=nameWithType>，比较结果大于 null 引用，且两个 null 的引用比较结果相等的。  
  
 比较终止时发现不相等或已经比较了两个字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，则认为较大的剩余字符的字符串。  
  
   
  
## Examples  
 下面的示例对两个字符串进行比较三个不同的方式： 使用 EN-US 区域性; 语义比较使用 EN-US 区域性; 语言区分大小写的比较并使用序号比较。 它演示了如何比较的三种方法生成三个不同的结果。  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法执行区分区域性的比较时不考虑此类字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA">
          <c>strA</c> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB">
          <c>strB</c> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象的子字符串，并返回一个指示二者在排序顺序中的相对位置的整数。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比较的子字符串在启动`strA`处`indexA`并在`strB`在`indexB`。 这两`indexA`并`indexB`是从零开始; 即中的第一个字符`strA`和`strB`位置为零。 第一个子字符串的长度等于的长度`strA`减去`indexA`加一。 第二个的子字符串的长度等于的长度`strB`减去`indexB`加一。  
  
 要比较的字符数是较小的两个子字符串的长度和`length`。 `indexA`， `indexB`，和`length`参数必须为非负。  
  
 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些字符的组合被视为单个字符或大写和小写字符进行比较以特定方式，可以指定区域性或字符的排序顺序取决于前的字符，或在其后。  
  
 使用单词排序规则执行比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  比较字符串时，应调用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，要求您显式指定该方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](~/docs/standard/base-types/best-practices-strings.md)。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了这两个子字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，然后其余的字符的字符串被视为更高版本。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 下面的示例比较这两个子字符串。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。  
  
或 
<paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，调用<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA">
          <c>strA</c> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB">
          <c>strB</c> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象的子字符串（忽略或考虑其大小写），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比较的子字符串在启动`strA`处`indexA`，然后在`strB`在`indexB`。 这两`indexA`并`indexB`是从零开始; 即中的第一个字符`strA`和`strB`位置为零。 第一个子字符串的长度等于的长度`strA`减去`indexA`加一。 第二个的子字符串的长度等于的长度`strB`减去`indexB`加一。  
  
 要比较的字符数是较小的两个子字符串的长度和`length`。 `indexA`， `indexB`，和`length`参数必须为非负。  
  
 比较使用当前区域性来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些字符的组合被视为单个字符或大写和小写字符进行比较以特定方式，可以指定区域性或字符的排序顺序取决于前的字符，或在其后。  
  
 使用单词排序规则执行比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!WARNING]
>  比较字符串时，应调用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法，要求您显式指定该方法使用的字符串比较的类型。 有关详细信息，请参阅[有关使用字符串的最佳实践](~/docs/standard/base-types/best-practices-strings.md)。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了这两个子字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，然后其余的字符的字符串被视为更高版本。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 路径名称必须以固定的方式进行比较。 若要执行此操作的正确代码如下所示。  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 下面的示例执行两个只不同的子字符串的两个的比较操作中用例。 第一次比较不区分大小写和第二个比较考虑大小写。  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。  
  
或 
<paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，调用<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA">
          <c>strA</c> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB">
          <c>strB</c> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="comparisonType">一个枚举值，用于指定比较中要使用的规则。</param>
        <summary>使用指定的规则比较两个指定的 <see cref="T:System.String" /> 对象的子字符串，并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字符串在排序顺序中出现的位置相同，或 <paramref name="length" /> 参数为零。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 中子字符串的排序顺序后于 <paramref name="strB" /> 中的子字符串。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比较的子字符串在启动`strA`处`indexA`并在`strB`在`indexB`。 这两`indexA`并`indexB`是从零开始; 即中的第一个字符`strA`和`strB`是在位置零，定位一个。 第一个子字符串的长度等于的长度`strA`减去`indexA`加一。 第二个的子字符串的长度等于的长度`strB`减去`indexB`加一。  
  
 要比较的字符数是较小的两个子字符串的长度和`length`。 `indexA`， `indexB`，和`length`参数必须为非负。  
  
 `comparisonType`参数指示是否比较应使用当前或固定区域性，接受或忽略大小写的比较数，或使用 word （区分区域性） 或序号 （不区分区域性的） 排序规则。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了这两个子字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，其余字符的字符串则认为较大。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 下面的示例比较这两个子字符串。  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。  
  
或 
<paramref name="indexA" /> 或 <paramref name="indexB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.StringComparison.Ordinal" />或<see cref="F:System.StringComparison.OrdinalIgnoreCase" />为<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA">
          <c>strA</c> 中子字符串的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB">
          <c>strB</c> 中子字符串的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">一个对象，提供区域性特定的比较信息。</param>
        <summary>比较两个指定的 <see cref="T:System.String" /> 对象（其中忽略或考虑其大小写，并使用区域性特定的信息干预比较），并返回一个整数，指示二者在排序顺序中的相对位置。</summary>
        <returns>一个整数，指示两个比较字之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比较的子字符串在启动`strA`处`indexA`，然后在`strB`在`indexB`。 这两`indexA`并`indexB`是从零开始; 即中的第一个字符`strA`和`strB`是在位置零，定位一个。 第一个子字符串的长度等于的长度`strA`减去`indexA`加一。 第二个的子字符串的长度等于的长度`strB`减去`indexB`加一。  
  
 要比较的字符数是较小的两个子字符串的长度和`length`。 `indexA`， `indexB`，和`length`参数必须为非负。  
  
 比较使用`culture`参数来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些字符的组合被视为单个字符或大写和小写字符进行比较以特定方式，可以指定区域性或字符的排序顺序取决于前的字符，或在其后。  
  
 使用单词排序规则执行比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
 可以是一个或两个比较数`null`。 根据定义，任意字符串，其中包括空字符串 ("")，进行比较，大于 null 的引用;和两个 null 引用的比较结果相等的。  
  
 比较终止时发现不相等或已经比较了这两个子字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，然后其余的字符的字符串被视为更高版本。 返回值为执行的最后一个比较的结果。  
  
 当比较受特定于区域性的大小写规则，会发生意外的结果。 例如，在土耳其语，下面的示例生成错误结果由于土耳其语中的文件系统对字母"i"不使用语言的大小写规则"文件"中。  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 进行比较的路径名称为"file"使用序号比较。 若要执行此操作的正确代码如下所示：  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 下面的示例比较这两个子字符串使用不同的区域性并忽略子字符串的大小写。 区域性的选择会影响字母"I"的方式进行比较。  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。  
  
或 
<paramref name="strA" /> 或 <paramref name="strB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，调用<see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法并提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA">
          <c>strA</c> 中子字符串开始的位置。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB">
          <c>strB</c> 中子字符串开始的位置。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <param name="culture">一个对象，提供区域性特定的比较信息。</param>
        <param name="options">要在执行比较时使用的选项（如忽略大小写或符号）。</param>
        <summary>对两个指定 <see cref="T:System.String" /> 对象的子字符串进行比较，使用指定的比较选项和区域性特定的信息来影响比较，并返回一个整数，该整数指示这两个子字符串在排序顺序中的关系。</summary>
        <returns>一个整数，该整数用于指示两个子字符串之间的词法关系，如下表所示。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之前。  
  
 </description></item><item><term> 零 
 </term><description> 子字符串在排序顺序中出现的位置相同或 <paramref name="length" /> 为零。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 中的子字符串在排序顺序中位于 <paramref name="strB" /> 中的子字符串之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要比较的子字符串在启动`strA`位置处`indexA`并在`strB`位置处`indexB`。 第一个子字符串长度的长度`strA`减去`indexA`。 第二个的子字符串的长度是长度`strB`减去`indexB`。  
  
 要比较的字符数是较小的两个子字符串的长度和`length`。 `indexA`， `indexB`，和`length`参数必须为非负。  
  
 比较使用`culture`参数来获取特定于区域性的信息，如大小写规则和单个字符的字母顺序。 例如，某些组合字符被视为单个字符、 大写和小写字符进行比较以特定方式，可以指定特定区域性或依赖于字符的字符的排序顺序的前面或后面。  
  
> [!CAUTION]
>  <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法主要用于在排序或按字母顺序排列的操作中使用。 其值不应在方法调用的主要用途是确定这两个子字符串是否等效 （即，当方法调用的目的是要测试其返回值为 0） 时使用。 若要确定两个字符串是否相等，请调用<xref:System.String.Equals%2A>方法。  
  
 一个或两个`strA`并`strB`可以是`null`。 根据定义，任意字符串，其中包括<xref:System.String.Empty?displayProperty=nameWithType>，比较结果大于 null 引用，且两个 null 的引用比较结果相等的。  
  
 可以通过进一步指定比较`options`参数，它包含一个或多个成员的<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>枚举。 但是，此方法的目的是执行区分区域性的字符串比较，因为<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>和<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>值不起任何作用。  
  
 比较终止时发现不相等或已经比较了这两个子字符串。 但是，如果两个字符串比较等于一个字符串的末尾，但在其他字符串有个剩余字符，则认为较大的剩余字符的字符串。 返回值为执行的最后一个比较的结果。  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>方法来比较两名人员的姓氏。 然后，列出它们按字母顺序。  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> 大于 <paramref name="strA" /><see langword=".Length" />。  
  
或 
 <paramref name="indexB" /> 大于 <paramref name="strB" /><see langword=".Length" />。  
  
或 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。  
  
或 
<paramref name="strA" /> 或 <paramref name="strB" /> 为 <see langword="null" />，并且 <paramref name="length" /> 大于零。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />方法执行语言性的或区分区域性的比较时不考虑这些字符。 若要识别您的比较中的可忽略字符，提供的值<see cref="F:System.Globalization.CompareOptions.Ordinal" />或<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />为<paramref name="options" />参数。</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通过计算每个字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个 <see cref="T:System.Char" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">要比较的第一个字符串。</param>
        <param name="strB">要比较的第二个字符串。</param>
        <summary>通过计算每个字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个指定的 <see cref="T:System.Char" /> 对象。</summary>
        <returns>一个整数，指示两个比较字之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 小于 <paramref name="strB" />。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="strA" /> 与 <paramref name="strB" /> 相等。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 大于 <paramref name="strB" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行区分大小写的比较使用序号排序规则。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。 若要执行不区分大小写的比较使用序号排序规则，请调用<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法替换`comparisonType`参数设置为<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。  
  
 因为<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是一种静态方法，`strA`并`strB`可以是`null`。 如果两个值均`null`，该方法返回 0 （零），指示`strA`和`strB`是否相等。 如果仅有一个值为`null`，该方法会考虑要更大的非 null 值。  
  
   
  
## Examples  
 下面的示例执行和序号比较两个字符串仅大小写不同。  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">要在比较中使用的第一个字符串。</param>
        <param name="indexA">
          <c>strA</c> 中子字符串的起始索引。</param>
        <param name="strB">要在比较中使用的第二个字符串。</param>
        <param name="indexB">
          <c>strB</c> 中子字符串的起始索引。</param>
        <param name="length">要比较的子字符串中字符的最大数量。</param>
        <summary>通过计算每个子字符串中相应 <see cref="T:System.String" /> 对象的数值来比较两个指定的 <see cref="T:System.Char" /> 对象的子字符串。</summary>
        <returns>一个 32 位带符号整数，指示两个比较数之间的词法关系。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description><paramref name="strA" /> 中的子字符串小于 <paramref name="strB" /> 中的子字符串。  
  
 </description></item><item><term> 零 
 </term><description> 子字符串相等，或者 <paramref name="length" /> 为零。  
  
 </description></item><item><term> 大于零 
 </term><description><paramref name="strA" /> 中的子字符串大于 <paramref name="strB" /> 中的子字符串。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `indexA`， `indexB`，和`length`参数必须为非负。  
  
 比较的字符数是较小的时长`strA`更少`indexA`，时长`strB`较少`indexB`，和`length`。  
  
 此方法执行区分大小写的比较使用序号排序规则。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。 若要执行不区分大小写的比较使用序号排序规则，请调用<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>方法替换`comparisonType`参数设置为<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>。  
  
 因为<xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29>是一种静态方法，`strA`并`strB`可以是`null`。 如果两个值均`null`，该方法返回 0 （零），指示`strA`和`strB`是否相等。 如果仅有一个值为`null`，该方法会考虑要更大的非 null 值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.CompareOrdinal%2A>和<xref:System.String.Compare%2A>使用不同的排序顺序。  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> 不为 <see langword="null" />，且 <paramref name="indexA" /> 大于 <paramref name="strA" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="strB" /> 不为 <see langword="null" />，且 <paramref name="indexB" /> 大于 <paramref name="strB" />.<see cref="P:System.String.Length" />。  
  
或 
 <paramref name="indexA" />、<paramref name="indexB" /> 或 <paramref name="length" /> 为负数。</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例与指定对象或 <see cref="T:System.String" /> 进行比较，并返回一个整数，该整数指示此实例在排序顺序中是位于指定对象或 <see cref="T:System.String" /> 之前、之后还是与其出现在同一位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这两个重载<xref:System.String.CompareTo%2A>方法执行区分区域性且区分大小写的比较。 不能使用此方法来执行不区分区域性的或序号比较。 为了代码清楚起见，我们建议你避免<xref:System.String.CompareTo%2A>方法并调用<xref:System.String.Compare%2A>方法相反。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">一个对象，其计算结果为 <see cref="T:System.String" />。</param>
        <summary>将此实例与指定的 <see cref="T:System.Object" /> 进行比较，并指示此实例在排序顺序中是位于指定的 <see cref="T:System.Object" /> 之前、之后还是与其出现在同一位置。</summary>
        <returns>一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="value" /> 参数之前、之后还是与其出现在同一位置。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例位于 <paramref name="value" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description> 此实例在排序顺序中的位置与 <paramref name="value" /> 相同。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例位于 <paramref name="value" /> 之后。  
  
或 
 <paramref name="value" /> 为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 必须为<xref:System.String>对象。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>方法旨在主要用于在排序或按字母顺序排列的操作中使用。 它应为时不使用方法调用的主要用途是确定两个字符串是否相等。 若要确定两个字符串是否相等，请调用<xref:System.String.Equals%2A>方法。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
 此方法的行为的详细信息，请参阅备注部分的<xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.CompareTo%2A>方法替换<xref:System.Object>。 因为它尝试比较<xref:System.String>实例向`TestClass`对象，该方法将引发<xref:System.ArgumentException>。  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 不是 <see cref="T:System.String" />。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.CompareTo(System.Object)" />方法执行区分区域性的比较时不考虑此类字符。 例如，如果运行下面的代码[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，"动物"与"ani 邮件"（使用软连字符或 U + 00AD） 的比较该值指示两个字符串是否相等。  
  
[！ 代码 csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [！ 代码 vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
若要识别的字符串比较中的可忽略字符，调用<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">要与此实例进行比较的字符串。</param>
        <summary>将此实例与指定的 <see cref="T:System.String" /> 对象进行比较，并指示此实例在排序顺序中是位于指定的字符串之前、之后还是与其出现在同一位置。</summary>
        <returns>一个 32 位带符号整数，该整数指示此实例在排序顺序中是位于 <paramref name="strB" /> 参数之前、之后还是与其出现在同一位置。  
  
 <list type="table"><listheader><term> “值” 
 </term><description> 条件 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例位于 <paramref name="strB" /> 之前。  
  
 </description></item><item><term> 零 
 </term><description> 此实例在排序顺序中的位置与 <paramref name="strB" /> 相同。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例位于 <paramref name="strB" /> 之后。  
  
或 
 <paramref name="strB" /> 为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 比较。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>。  
  
> [!CAUTION]
>  <xref:System.String.CompareTo%2A>方法旨在主要用于在排序或按字母顺序排列的操作中使用。 它应为时不使用方法调用的主要用途是确定两个字符串是否相等。 若要确定两个字符串是否相等，请调用<xref:System.String.Equals%2A>方法。  
  
 此方法的行为的详细信息，请参阅备注部分的<xref:System.String.Compare%28System.String%2CSystem.String%29>方法。  
  
 此方法实现<xref:System.IComparable%601?displayProperty=nameWithType>接口，并且执行略微优于<xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>方法，因为它没有以确定是否`strB`参数是必须进行装箱，可变值类型，不需要强制转换其中的参数<xref:System.Object>到<xref:System.String>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.CompareTo%2A>方法来比较当前字符串实例与另一个字符串。  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 下面的示例演示了针对多个值和引用类型的 CompareTo 方法的泛型和非泛型版本。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符。 <see cref="M:System.String.CompareTo(System.String)" />方法执行区分区域性的比较时不考虑此类字符。 例如，如果运行下面的代码[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，"动物"与"ani 邮件"（使用软连字符或 U + 00AD） 的比较该值指示两个字符串是否相等。  
  
[！ 代码 csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [！ 代码 vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
若要识别的字符串比较中的可忽略字符，调用<see cref="M:System.String.CompareOrdinal(System.String,System.String)" />方法。</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>连接 <see cref="T:System.String" /> 的一个或多个实例，或 <see cref="T:System.String" /> 的一个或多个实例的值的 <see cref="T:System.Object" /> 表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">一个集合对象，该对象实现 <see cref="T:System.Collections.Generic.IEnumerable`1" />，且其泛型类型参数为 <see cref="T:System.String" />。</param>
        <summary>串联类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.String" /> 构造集合的成员。</summary>
        <returns>
          <paramref name="values" /> 中的串联字符串；如果 <paramref name="values" /> 为空 <see langword="IEnumerable(Of String)" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接中的每个对象`values`; 它不会添加任何分隔符。 若要指定的每个成员之间的分隔符`values`，调用<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。  
  
 <xref:System.String.Empty>字符串用来替代中任何 null 元素`values`。  
  
 如果`values`是一个空`IEnumerable(Of String)`，该方法将返回<xref:System.String.Empty?displayProperty=nameWithType>。 如果`values`是`null`，该方法将引发<xref:System.ArgumentNullException>异常。  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是可以串联的每个元素的便捷方法`IEnumerable(Of String)`不必先转换为字符串数组元素的集合。 它是语言集成查询 (LINQ) 查询表达式特别有用。 下面的示例传入`List(Of String)`对象，其中包含为 lambda 表达式的选择是等于或大于特定字母 （即，在示例中，"M"） 的字母字母表中的大写或小写字母。 `IEnumerable(Of String)`返回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法将传递给<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法以将结果显示为单个字符串。  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 以下示例使用埃拉托色的尼斯筛法算法来计算小于或等于 100 的质数。 它会将结果发送到将分配<xref:System.Collections.Generic.List%601>类型的对象<xref:System.String>，然后将其传递到<xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要表示的对象，或 <see langword="null" />。</param>
        <summary>创建指定对象的字符串表示形式。</summary>
        <returns>
          <paramref name="arg0" /> 的值的字符串表示形式，如果 <see cref="F:System.String.Empty" /> 为 <paramref name="arg0" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Concat%28System.Object%29>方法表示`arg0`通过调用其无参数的字符串作为`ToString`方法。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Concat%2A>方法。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">一个对象数组，其中包含要连接的元素。</param>
        <summary>连接指定 <see cref="T:System.Object" /> 数组中的元素的字符串表示形式。</summary>
        <returns>
          <paramref name="args" /> 中元素的值的串联字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将在每个对象连接在一起`args`通过调用无参数`ToString`该对象; 方法不会添加任何分隔符。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 将代替数组中的任何 null 对象。  
  
   
  
## Examples  
 下面的示例演示如何将<xref:System.String.Concat%2A>方法替换<xref:System.Object>数组。  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <block subset="none" type="usage">
          <para>C + + 代码不调用此方法。 C + + 编译器将解析调用<see cref="Overload:System.String.Concat" />与调用具有四个或多个对象参数<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />。</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">字符串实例的数组。</param>
        <summary>连接指定的 <see cref="T:System.String" /> 数组的元素。</summary>
        <returns>
          <paramref name="values" /> 的串联元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接中的每个对象`values`; 它不会添加任何分隔符。  
  
 <xref:System.String.Empty>字符串代替数组中的任何 null 对象。  
  
   
  
## Examples  
 下面的示例演示如何将<xref:System.String.Concat%2A>方法替换<xref:System.String>数组。  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要连接的第一个对象。</param>
        <param name="arg1">要连接的第二个对象。</param>
        <summary>连接两个指定对象的字符串表示形式。</summary>
        <returns>
          <paramref name="arg0" /> 和 <paramref name="arg1" /> 的值的串联字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接在一起`arg0`并`arg1`通过调用无参数`ToString`方法`arg0`和`arg1`; 它不会添加任何分隔符。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 将代替任何 null 参数。  
  
 如果参数是数组引用，该方法将一个字符串，表示该数组，而不是其成员 (例如，"System.String[]")。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Concat%2A>方法。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串联的第一个字符串。</param>
        <param name="str1">要串联的第二个字符串。</param>
        <summary>连接 <see cref="T:System.String" /> 的两个指定实例。</summary>
        <returns>
          <paramref name="str0" /> 和 <paramref name="str1" /> 的串联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接在一起`str0`和`str1`; 它不会添加任何分隔符。  
  
> [!NOTE]
>  此外可以使用你的语言的字符串串联运算符，如`+`在 C# 中，或`&`和`+`在 Visual Basic 中)  
>   
>  连接字符串。  
  
 <xref:System.String.Empty>字符串代替任何 null 参数。  
  
   
  
## Examples  
 下面的示例将一个人的名字、 中间名和姓氏名称串联起来。  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要连接的第一个对象。</param>
        <param name="arg1">要连接的第二个对象。</param>
        <param name="arg2">要连接的第三个对象。</param>
        <summary>连接三个指定对象的字符串表示形式。</summary>
        <returns>
          <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的值的串联字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接在一起`arg0`， `arg1`，并`arg2`通过调用无参数`ToString`方法的每个对象; 它不会添加任何分隔符。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 将代替任何 null 参数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Concat%2A>方法。  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串联的第一个字符串。</param>
        <param name="str1">要串联的第二个字符串。</param>
        <param name="str2">要比较的第三个字符串。</param>
        <summary>连接 <see cref="T:System.String" /> 的三个指定实例。</summary>
        <returns>
          <paramref name="str0" />、<paramref name="str1" /> 和 <paramref name="str2" /> 的串联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接在一起`str0`， `str1`，和`str2`; 它不会添加任何分隔符。  
  
> [!NOTE]
>  此外可以使用你的语言的字符串串联运算符，如`+`在 C# 中，或`&`和`+`在 Visual Basic 中)  
>   
>  连接字符串。  
  
 <xref:System.String.Empty>字符串代替任何 null 参数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.Concat%2A>方法要串联三个字符串，并显示结果。  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">要连接的第一个对象。</param>
        <param name="arg1">要连接的第二个对象。</param>
        <param name="arg2">要连接的第三个对象。</param>
        <param name="arg3">要连接的第四个对象。</param>
        <summary>将四个指定对象的字符串表示形式与可选变量长度参数列表中指定的任何对象串联起来。</summary>
        <returns>参数列表中的每个值的连接字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此 API 不兼容 CLS。 符合 CLS 的替代方法是 <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。 C# 和 Visual Basic 编译器会自动解决调用此方法与调用<xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>。  
  
 该方法通过调用其无参数串联在参数列表中的每个对象`ToString`方法; 它不会添加任何分隔符。  
  
 <xref:System.String.Empty?displayProperty=nameWithType> 将代替任何 null 参数。  
  
> [!NOTE]
>  最后一个参数<xref:System.String.Concat%2A>方法是可选的一个或多个要串联的其他对象以逗号分隔列表。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法要串联的变量参数列表。 在这种情况下，使用 9 个参数调用该方法。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>此方法将标有<see langword="vararg" />关键字，这意味着它支持个数可变的参数。 可以从 Visual c + +，调用该方法，但它不能从 C# 或 Visual Basic 代码调用。 C# 和 Visual Basic 编译器解决对调用<see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />一样调用<see cref="M:System.String.Concat(System.Object[])" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">要串联的第一个字符串。</param>
        <param name="str1">要串联的第二个字符串。</param>
        <param name="str2">要比较的第三个字符串。</param>
        <param name="str3">要比较的第四个字符串。</param>
        <summary>连接 <see cref="T:System.String" /> 的四个指定实例。</summary>
        <returns>
          <paramref name="str0" />、<paramref name="str1" />、<paramref name="str2" /> 和 <paramref name="str3" /> 的串联。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接在一起`str0`， `str1`， `str2`，和`str3`; 它不会添加任何分隔符。  
  
> [!NOTE]
>  此外可以使用你的语言的字符串串联运算符，如`+`在 C# 中，或`&`和`+`在 Visual Basic 中)  
>   
>  连接字符串。  
  
 <xref:System.String.Empty>字符串代替数组中的任何 null 对象。  
  
   
  
## Examples  
 下面的示例定义的四字母单词数组，并将其单个字母为字符串数组存储以便混排它们。 然后，它调用<xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>方法来重新组合打乱的单词。  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">成员的类型<c>值</c>。</typeparam>
        <param name="values">一个实现 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 接口的集合对象。</param>
        <summary>串联 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 实现的成员。</summary>
        <returns>
          <paramref name="values" /> 中的串联成员。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该方法将连接中的每个对象`values`; 它不会添加任何分隔符。  
  
 <xref:System.String.Empty>字符串代替任何 null 参数。  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是可以串联的每个元素的便捷方法<xref:System.Collections.Generic.IEnumerable%601>而无需事先将元素转换为字符串的集合。 如示例所示，它是语言集成查询 (LINQ) 查询表达式特别有用。 在每个对象的字符串表示形式<xref:System.Collections.Generic.IEnumerable%601>通过调用该对象的派生集合`ToString`方法。  
  
   
  
## Examples  
 下面的示例定义一个非常简单`Animal`类，该类包含动物和它所属的顺序的名称。 然后，它定义<xref:System.Collections.Generic.List%601>对象，以包含大量`Animal`对象。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>调用扩展方法来提取`Animal`对象的`Order`属性等于"老鼠"。 将结果传递给<xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法并向控制台显示。  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <summary>返回一个值，该值指示指定的子串是否出现在此字符串中。</summary>
        <returns>如果 <see langword="true" /> 参数出现在此字符串中，或者 <paramref name="value" /> 为空字符串 ("")，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号 （区分大小写和不区分区域性） 比较。 搜索此字符串的第一个字符位置开始并持续到最后一个字符位置。  
  
 确定字符串是否包含指定的子字符串使用序号比较 （如区分区域性的比较或不区分大小写的序号比较） 以外的内容，可以创建自定义方法。 下面的示例说明了一种方法。 它定义<xref:System.String>包括的扩展方法<xref:System.StringComparison>参数，并指示时使用指定的窗体的字符串比较的字符串是否包含子字符串。  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 下面的示例然后调用`Contains`扩展方法，以确定使用序号比较和不区分大小写的序号比较时是否在字符串中找到子字符串。  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 如果您感兴趣子字符串的位置`value`在当前实例中，可以调用<xref:System.String.IndexOf%2A>方法以获取其第一个匹配项，或您的起始位置可以调用<xref:System.String.LastIndexOf%2A>方法获取的起始位置及其最后一个匹配项。 该示例包含对的调用<xref:System.String.IndexOf%28System.String%29>方法，如果在字符串实例中找到子字符串。  
  
   
  
## Examples  
 下面的示例确定字符串"fox"是否熟悉引起来的子字符串。 如果"按照 fox"在字符串中找到，它还显示其起始位置。  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要复制的字符串。</param>
        <summary>创建一个与指定的 <see cref="T:System.String" /> 具有相同值的 <see cref="T:System.String" /> 的新实例。</summary>
        <returns>值与 <paramref name="str" /> 相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Copy%2A>方法将返回<xref:System.String>具有相同的值作为原始字符串，但表示不同的对象引用的对象。 它不同于赋值运算，将分配给其他对象变量的现有字符串引用。 该示例演示了差异。  
  
   
  
## Examples  
 下面的示例使用不同的值创建两个字符串对象。 当调用<xref:System.String.Copy%2A>方法将第一个值分配给第二个字符串，输出会指示以字符串表示不同的对象的引用，但现在它们的值是否相等。 但是，如果第一个字符串分配给第二个字符串，两个字符串具有相同的值，因为它们表示相同的对象引用。  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">要复制的此实例中第一个字符的索引。</param>
        <param name="destination">此实例中的字符所复制到的 Unicode 字符数组。</param>
        <param name="destinationIndex">
          <c>destination</c> 中的索引，在此处开始复制操作。</param>
        <param name="count">此实例中要复制到 <c>destination</c> 的字符数。</param>
        <summary>将指定数目的字符从此实例中的指定位置复制到 Unicode 字符数组中的指定位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法复制`count`个字符`sourceIndex`位置的此实例与`destinationIndex`位置`destination`字符数组。 此方法不会调整大小`destination`字符数组; 它必须具有足够数量的元素，以便复制的字符或该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 `sourceIndex` 和`destinationIndex`都从零开始。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.CopyTo%2A>方法。  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 为负 
或 
 <paramref name="sourceIndex" /> 不标识当前实例中的位置。  
  
或 
 <paramref name="destinationIndex" /> 不标识 <paramref name="destination" /> 数组中的有效索引。  
  
或 
 <paramref name="count" /> 大于从 <paramref name="sourceIndex" /> 到此实例末尾的子字符串的长度 
或 
 <paramref name="count" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destination" /> 数组末尾的子数组的长度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示空字符串。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段的值为零长度字符串，""。  
  
 在应用程序代码中，此字段是最常用于在分配中初始化为空字符串的字符串变量。 若要测试是否字符串的值为`null`或<xref:System.String.Empty?displayProperty=nameWithType>，使用<xref:System.String.IsNullOrEmpty%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定此字符串实例的结尾是否与指定的字符串匹配。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的子字符串进行比较的字符串。</param>
        <summary>确定此字符串实例的结尾是否与指定的字符串匹配。</summary>
        <returns>如果 <paramref name="value" /> 与此实例的末尾匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法比较`value`是相同的长度与此实例的结尾处的子字符串到`value`，并返回指示它们是否相等。 若要对等，`value`必须对此相同的实例的引用或与此实例的末尾匹配。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 比较。  
  
   
  
## Examples  
 下面的示例指示数组中的每个字符串是否以句点结尾 ("。")。  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 下面的示例定义`StripEndTags`方法，它使用<xref:System.String.EndsWith%28System.String%29>方法从行的末尾删除 HTML 结束标记。 请注意，`StripEndTags`方法称为递归，请确保删除在行尾的多个 HTML 结束标记。  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要确定是否字符串结尾的特定子字符串使用当前区域性的字符串比较规则，请调用<see cref="M:System.String.EndsWith(System.String,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的子字符串进行比较的字符串。</param>
        <param name="comparisonType">枚举值之一，用于确定如何比较此字符串与 <c>value</c>。</param>
        <summary>确定使用指定的比较选项进行比较时此字符串实例的结尾是否与指定的字符串匹配。</summary>
        <returns>如果此字符串的末尾与 <paramref name="value" /> 参数匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.EndsWith%2A>方法比较`value`此字符串的末尾处的子字符串的参数，并返回一个值，指示它们是否相等。 若要对等，`value`必须为对此相同的字符串的引用，必须为空字符串 ("")，或必须与此字符串的末尾匹配。 执行比较的类型<xref:System.String.EndsWith%2A>方法的值取决于`comparisonType`参数。  
  
   
  
## Examples  
 下面的示例确定字符串是否以特定子字符串结尾。 区域性，是否忽略大小写，和是否执行序号比较的选择会影响结果。  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例末尾的子字符串进行比较的字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">确定如何对此实例与 <c>value</c> 进行比较的区域性信息。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前区域性。</param>
        <summary>确定在使用指定的区域性进行比较时此字符串实例的结尾是否与指定的字符串匹配。</summary>
        <returns>如果此字符串的末尾与 <paramref name="value" /> 参数匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法比较`value`参数是相同的长度与此字符串的末尾处的子字符串`value`，并返回一个值，指示它们是否相等。 若要对等，`value`必须对此相同的实例的引用或与此字符串的末尾匹配。  
  
 此方法执行使用指定的大小写和区域性的单词 （区分区域性） 比较。  
  
   
  
## Examples  
 下面的示例确定字符串是否出现在另一个字符串的末尾。 <xref:System.String.EndsWith%2A>使用区分大小写，不区分大小写和影响搜索结果的不同区域性的多次调用方法。  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个 <see cref="T:System.String" /> 对象是否具有相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与此实例进行比较的字符串。</param>
        <summary>确定此实例是否与指定的对象（也必须是 <see cref="T:System.String" /> 对象）具有相同的值。</summary>
        <returns>如果 <paramref name="obj" /> 为 <see cref="T:System.String" /> 并且它的值与此实例相同，则为 <see langword="true" />；否则为 <see langword="false" />。  如果 <paramref name="obj" /> 为 <see langword="null" />，则此方法返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号 （区分大小写和不区分区域性） 比较。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Equals%2A>方法。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的字符串。</param>
        <summary>确定此实例是否与另一个指定的 <see cref="T:System.String" /> 对象具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 参数的值与此实例的值相同，则为 <paramref name="value" />；否则为 <see langword="false" />。 如果 <paramref name="value" /> 为 <see langword="null" />，则此方法返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号 （区分大小写和不区分区域性） 比较。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Equals%2A>方法。它将标题的大小写的单词"文件"等效 word、 其小写等效项，其大写等效项，与包含拉丁文小写字母无点 I 的词进行比较 (U + 0131) 而不是拉丁文小写字母 I (U + 0069)。 因为<xref:System.String.Equals%28System.String%29>方法执行序号比较，仅使用完全相同的单词比较返回`true`。  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <summary>确定两个指定的 <see cref="T:System.String" /> 对象是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。 如果 <paramref name="a" /> 和 <paramref name="b" /> 均为 <see langword="null" />，此方法将返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号 （区分大小写和不区分区域性） 比较。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Equals%2A>方法。  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的字符串。</param>
        <param name="comparisonType">枚举值之一，用于指定如何比较字符串。</param>
        <summary>确定此字符串是否与另一个指定的 <see cref="T:System.String" /> 对象具有相同的值。 参数指定区域性、大小写以及比较所用的排序规则。</summary>
        <returns>如果 <see langword="true" /> 参数的值与此字符串相同，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`参数指示是否比较应使用当前或固定区域性，接受或忽略所比较的两个字符串的大小写或不使用 word 或序号排序规则。  
  
   
  
## Examples  
 以下示例创建一个字符串数组，包含一个大写"I"、 一个小写"i"和无点"ı"。 然后，它调用<xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>方法使用每个可能比较<xref:System.StringComparison>枚举值。  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 下面的示例使用的每个成员比较字的四个集<xref:System.StringComparison>枚举。  比较使用英语 （美国） 和萨米语 （上部瑞典） 区域性的约定。 请注意，字符串"encyclopædia"和"百科全书"都视为等效 EN-US 区域性中但不是会在萨米语 （北方瑞典） 区域性。  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <param name="comparisonType">枚举值之一，用于指定比较的规则。</param>
        <summary>确定两个指定的 <see cref="T:System.String" /> 对象是否具有相同的值。 参数指定区域性、大小写以及比较所用的排序规则。</summary>
        <returns>如果 <see langword="true" /> 参数的值与 <paramref name="a" /> 参数的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `comparisonType`参数指示是否比较应使用当前或固定区域性，接受或忽略所比较的两个字符串的大小写或不使用 word 或序号排序规则。  
  
   
  
## Examples  
 下面的示例使用的每个成员比较字的四个集<xref:System.StringComparison>枚举。  比较使用英语 （美国） 和萨米语 （上部瑞典） 区域性的约定。 请注意，字符串"encyclopædia"和"百科全书"都视为等效 EN-US 区域性中但不是会在萨米语 （北方瑞典） 区域性。  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将对象的值转换为基于指定格式的字符串，并将其插入到另一个字符串。  
  
如果不熟悉 `String.Format` 方法，请参阅 [String.Format 方法入门](#Starting)一节来进行快速了解。  
  
有关 `String.Format` 方法的常规文档，请参阅[备注](#remarks-top)部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 本节内容：  
  
 [开始使用 String.Format 方法](#Starting)   
 [我调用哪个方法？](#FTaskList)   
 [Format 方法概述](#Format_Brief)   
 [格式项](#FormatItem)   
 [如何设置参数的格式](#HowFormatted)   
 [格式项具有相同的索引](#SameIndex)   
 [格式设置和区域性](#Format_Culture)   
 [自定义格式设置操作](#Format_Custom)   
 [String.Format 问答](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>开始使用 String.Format 方法  
 使用<xref:System.String.Format%2A?displayProperty=nameWithType>如果你需要将对象、 变量或表达式的值插入到另一个字符串。 例如，可以插入的值<xref:System.Decimal>为字符串，用于显示给用户作为单个字符串值：  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 你可以控制该值的格式设置：  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 除了设置格式，还可以控制对齐方式和间距。  
  
 ### <a name="inserting-a-string"></a>将字符串插入  

 <xref:System.String.Format%2A?displayProperty=nameWithType> 开始一个格式字符串后, 跟一个或多个对象或表达式将转换为字符串并在格式字符串中的指定位置处插入。 例如:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 `{0}`格式字符串是一个格式项。 `0` 是将该位置处插入其字符串值的索引。 （索引从 0 开始。）如果要插入的对象不是字符串，其`ToString`调用方法以将其转换为一个之前将其插入结果字符串中。  
  
 下面是使用对象列表中的两个格式项和两个对象的另一个示例：  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 可以有任意多个格式项并想在对象列表中的多个对象，只要每个格式项的索引对象列表中具有匹配的对象。 你还无需担心有关哪个重载调用;编译器将选择相应的一个。  
  
 ### <a name="controlling-formatting"></a>控制格式设置  
 可以按照与要控制如何格式化对象的格式字符串的格式项中的索引。 例如， `{0:d}` "d"格式字符串应用于对象列表中的第一个对象。 下面是包含单个对象的一个示例，两个项目的格式：  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 类型支持的数字格式字符串，其中包括所有数值类型 (同时[标准](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义](~/docs/standard/base-types/custom-numeric-format-strings.md)格式字符串)，所有日期和时间 (同时[标准](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义](~/docs/standard/base-types/custom-date-and-time-format-strings.md)格式字符串) 和时间间隔 (同时[标准](~/docs/standard/base-types/standard-timespan-format-strings.md)并[自定义](~/docs/standard/base-types/custom-timespan-format-strings.md)格式字符串)，所有枚举类型[枚举类型](~/docs/standard/base-types/enumeration-format-strings.md)，并[Guid](https://msdn.microsoft.com/library/97af8hh4.aspx)。 您还可以向你自己的类型添加支持的格式字符串。  
  
 ### <a name="controlling-spacing"></a>控制间距  
 您可以定义使用的语法类似于插入到结果字符串的字符串的宽度`{0,12}`，用于插入 12 个字符的字符串。 在这种情况下，第一个对象的字符串表示形式为右对齐 12 个字符字段中。  （如果第一个对象的字符串表示形式的长度超过 12 个字符，不过，首选的字段宽度忽略，并且整个字符串插入到结果字符串。）  
  
 下面的示例定义一个 6 字符字段以保存该字符串"Year"和某些年字符串，以及 15 个字符字段以保存"填充"的字符串和某些填充数据。 请注意，这些字符右对齐的字段中。  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>控制对齐方式  
 默认情况下，字符串是右对齐，其字段中如果指定字段宽度。 若要左对齐字符串字段中的，您的前面加上负号的字段宽度如`{0,-12}`定义 12 个字符左对齐字段。  
  
 下面的示例是类似于前一个，只不过它左对齐标签和数据。  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> 使用复合格式设置功能。 有关更多信息，请参见[复合格式设置](~/docs/standard/base-types/composite-formatting.md)。  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>我调用哪个方法？  
  
|到|Call|  
|--------|----------|  
|使用当前区域性的约定格式化的一个或多个对象。|包括重载除外`provider`参数，其余<xref:System.String.Format%2A>重载包括<xref:System.String>参数后跟一个或多个对象参数。 因此，无需确定哪个<xref:System.String.Format%2A>你想要调用的重载。 你的语言编译器选择适当的重载中没有的重载进行`provider`参数，根据您的自变量列表。 例如，如果自变量列表中包含五个参数，编译器将调用<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。|  
|使用特定区域性的约定格式化的一个或多个对象。|每个<xref:System.String.Format%2A>开头的重载`provider`参数后跟<xref:System.String>参数和一个或多个对象的参数。 正因为如此，则不需要确定哪个特定<xref:System.String.Format%2A>你想要调用的重载。 你的语言编译器选择从具有重载的适当重载`provider`参数，根据您的自变量列表。 例如，如果自变量列表中包含五个参数，编译器将调用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法。|  
|执行自定义格式设置操作中使用<xref:System.ICustomFormatter>实现或<xref:System.IFormattable>实现。|任何具有四个重载`provider`参数。 编译器将选择从具有重载的适当重载`provider`参数，根据您的自变量列表。|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Format 方法概述 

 每个重载<xref:System.String.Format%2A>方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)包括从零开始索引的占位符称为*项目的格式*，复合格式字符串中。 在运行时，每个格式项替换的参数列表中的相应参数的字符串表示形式。 如果自变量的值为`null`，格式项替换<xref:System.String.Empty?displayProperty=nameWithType>。 例如，以下调用到<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法包含与三个格式项，一个格式字符串{0}， {1}，和{2}，和包含三个项目的参数列表。  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>格式项  
 格式项具有此语法：  
  
```  
{index[,alignment][:formatString]}  
```  
 
 括号表示可选元素。 左括号和右大括号是必需的。 (包括文本左或右大括号中的格式字符串，请参阅[转义大括号](~/docs/standard/base-types/composite-formatting.md#escaping-braces)主题中[复合格式设置](~/docs/standard/base-types/composite-formatting.md)文章。)  
  
 例如，若要设置格式的货币值的格式项可能显示如下：  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 格式项具有以下元素：  
  
 *index*  
 将成为其字符串表示形式的参数的从零开始的索引包含在字符串中的此位置。 如果此参数为`null`，将在此位置在字符串中包含空字符串。  
  
 *对齐方式*  
 可选。 一个有符号的整数，指示插入参数以及它为右对齐 （正整数） 还是左对齐 （负整数） 到该字段的总长度。 如果省略*对齐*，相应参数的字符串表示形式插入没有前导或尾随空格的字段中。  
  
 如果的值*对齐*是要插入的参数的长度小于*对齐方式*将被忽略并使用参数的字符串表示形式的长度作为字段宽度。  
  
 *formatString*  
 可选。 一个字符串，指定相应参数的结果字符串的格式。 如果省略*formatString*，相应参数的无参数`ToString`调用方法来生成其字符串表示形式。 如果指定*formatString*，参数引用的格式项必须实现<xref:System.IFormattable>接口。 支持格式字符串的类型包括：  
  
-   整型和浮点型的所有类型。 (请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。)  
  
-   <xref:System.DateTime> 和 <xref:System.DateTimeOffset>。 (请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。)  
  
-   所有枚举类型。 (请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。)  
  
-   <xref:System.TimeSpan> 值。 (请参阅[标准 TimeSpan 格式字符串](~/docs/standard/base-types/standard-timespan-format-strings.md)并[自定义 TimeSpan 格式字符串](~/docs/standard/base-types/custom-timespan-format-strings.md)。)  
  
-   GUID。 (请参阅<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>方法。)  
  
 但请注意，可以实现任何自定义类型<xref:System.IFormattable>或扩展现有类型的<xref:System.IFormattable>实现。  
  
 下面的示例使用`alignment`和`formatString`自变量才能生成格式化的输出。  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>如何设置参数的格式  
 格式项按顺序处理从字符串的开头。 每个格式项的索引对应于该方法的参数列表中的对象。 <xref:System.String.Format%2A>方法检索自变量，并派生其字符串表示形式，如下所示：  
  
-   如果参数为`null`，则该方法插入<xref:System.String.Empty?displayProperty=nameWithType>到结果字符串。 无需关心处理<xref:System.NullReferenceException>的 null 参数。 
  
-   如果您调用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>重载并`provider`对象的<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>实现返回非 null<xref:System.ICustomFormatter>实现中，将参数传递给其<xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。 如果格式项包括*formatString*参数，它作为第一个参数传递给该方法。 如果<xref:System.ICustomFormatter>实现可用，并生成一个非空字符串，字符串作为参数的字符串表示形式返回; 否则下, 一步执行。  
  
-   如果参数实现<xref:System.IFormattable>接口，其<xref:System.IFormattable.ToString%2A?displayProperty=nameWithType>调用实现。  
  
-   自变量的无参数`ToString`方法，重写或继承的基类实现，该方法调用。  
  
 有关截获对的调用的示例<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>方法，并允许您查看哪些信息<xref:System.String.Format%2A>方法将传递给在复合格式字符串中，每个格式项的格式设置方法请参阅[示例： 截距提供程序和罗马数字格式化程序](#Format7_Example)。  

 有关详细信息，请参阅[处理顺序](~/docs/standard/base-types/composite-formatting.md##processing-order)主题中[复合格式设置](~/docs/standard/base-types/composite-formatting.md)一文。  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>格式项具有相同的索引  
 <xref:System.String.Format%2A>方法会抛出<xref:System.FormatException>异常索引项的索引是否大于或等于自变量列表中的参数的数目。 但是，`format`可以包含多个格式项不是没有自变量，前提是多个格式项都具有相同的索引。 在调用<xref:System.String.Format%28System.String%2CSystem.Object%29>在以下示例中，参数列表的方法具有一个参数，但在格式字符串包括两个格式项： 一个窗格显示一个数字，十进制值和另一个显示十六进制值。  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>格式设置和区域性  
 通常情况下，参数列表中的对象将转换为其字符串表示形式通过使用当前区域性的约定返回<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性。 可以通过调用的重载之一来控制此行为<xref:System.String.Format%2A>，其中包含`provider`参数。 `provider`参数是<xref:System.IFormatProvider>实现，提供用于控制格式设置的自定义和特定于区域性的格式设置信息处理。  
  
 <xref:System.IFormatProvider>接口具有一个成员， <xref:System.IFormatProvider.GetFormat%2A>，这是负责返回提供格式设置信息的对象。 .NET 具有三个<xref:System.IFormatProvider>提供特定于区域性的格式设置的实现：  
  
-   <xref:System.Globalization.CultureInfo>。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法返回区域性特定<xref:System.Globalization.NumberFormatInfo>设置的数字值和区域性特定格式的对象<xref:System.Globalization.DateTimeFormatInfo>格式化日期和时间值的对象。  
  
-   <xref:System.Globalization.DateTimeFormatInfo>它用于特定于区域性的日期和时间值的格式设置。 其<xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A>方法返回其自身。  
  
-   <xref:System.Globalization.NumberFormatInfo>它用于特定于区域性的数值的格式设置。 其<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>属性返回其自身。 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>自定义格式设置操作  
 你还可以调用的重载的任意<xref:System.String.Format%2A>方法具有`provider`类型的参数<xref:System.IFormatProvider>来执行自定义格式设置操作。 例如，您无法设置整数格式作为一个标识号或电话号码。 若要执行自定义格式设置，你`provider`自变量必须同时实现<xref:System.IFormatProvider>和<xref:System.ICustomFormatter>接口。 当<xref:System.String.Format%2A>方法传递<xref:System.ICustomFormatter>实现作为`provider`自变量，<xref:System.String.Format%2A>方法调用其<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>实现，并请求类型的对象<xref:System.ICustomFormatter>。 然后，它调用返回<xref:System.ICustomFormatter>对象的<xref:System.ICustomFormatter.Format%2A>方法来设置格式的复合字符串中每个格式项传递给它。  
  
 提供自定义格式设置解决方案的详细信息，请参阅[如何： 定义和使用自定义数值格式提供程序](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)和<xref:System.ICustomFormatter>。 将整数转换为带格式的自定义数字示例，请参阅[示例： 自定义格式设置操作](#Format6_Example)。 将无符号的字节转换为罗马数字示例，请参阅[示例： 一个截距提供程序和罗马数字格式化程序](#Format7_Example)。  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>示例： 自定义的格式设置操作  
 此示例中定义格式设置为在窗体 x xxxxx xx 客户帐户编号的整数值的格式提供程序。  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>示例： 一个截距提供程序和罗马数字格式化程序  
 此示例中定义的自定义格式提供程序实现<xref:System.ICustomFormatter>和<xref:System.IFormatProvider>接口做两件事：  
  
-   它显示的参数传递给其<xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>实现。 这使我们能够看到哪些参数<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法将传递到每个对象，它会尝试设置格式的自定义格式设置实现。 在调试应用程序时，这很有用。  
  
-   如果要设置格式的对象是一个无符号的字节值，是要通过使用"R"标准格式字符串设置格式，自定义格式化程序设置为罗马数字格式的数字值。  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format 问答  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>为什么推荐字符串内插通过对调用`String.Format`方法？

字符串内插是：

- 更灵活。 它可在任何字符串而无需对支持复合格式设置方法的调用。 否则，您必须调用<xref:System.String.Format%2A>方法或支持复合格式设置，例如的另一种方法<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>。 

- 更具可读性。 因为内插表达式中，而不是参数列表中，将显示要插入到字符串的表达式内, 插的字符串是代码并读取容易得多。 由于其更好的可读性内, 插的字符串可替换不仅对复合格式方法的调用，但它们还可在字符串串联操作中以生成更简洁、 更清晰的代码。 

比较以下两个代码示例说明了通过字符串串联和对复合格式设置方法的调用的内插字符串的优越性。 使用多个字符串串联操作中在下面的示例生成详细和硬读取代码。

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

在下面的示例中的内插字符串使用与此相反，生成更清晰、 更简洁的代码，比字符串串联语句和对调用<xref:System.String.Format%2A>上一示例中的方法。

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>在哪里可以找到可以在格式项的预定义的格式字符串的列表？  
  
-   对于所有整型和浮点类型，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   日期和时间值，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)并[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
-   枚举值，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
-   有关<xref:System.TimeSpan>值，请参阅[标准 TimeSpan 格式字符串](~/docs/standard/base-types/standard-timespan-format-strings.md)并[自定义 TimeSpan 格式字符串](~/docs/standard/base-types/custom-timespan-format-strings.md)。  
  
-   有关<xref:System.Guid>值，请参阅备注部分的<xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>参考页。  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>如何控制结果字符串的替换为格式项的对齐方式？  
 格式项的常规语法是：  
  
```  
{index[,alignment][: formatString]}  
```  
  
 其中*对齐*是一个有符号的整数，它定义的字段宽度。 如果此值为负，则它是文本字段中的，左对齐。 如果为正数，文本是右对齐。  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>如何小数分隔符后的控制的位数  
 所有[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)除外 （这用于仅包含整数） 的"D"、"G"、"R"和"X"允许定义结果字符串中的十进制数字的精度说明符。 以下示例使用标准数字格式字符串来控制结果字符串中的十进制数字个数。  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 如果您使用的[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)，使用"0"格式说明符来控制结果字符串中的十进制数字，如以下示例所示的编号。  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>如何控制整数位的数？  
 默认情况下，格式设置操作仅显示非零整数位。 如果要进行格式设置整数，可以使用精度说明符"D"和"X"标准格式字符串来控制的数字位数。  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 若要通过使用"0"来生成具有指定数目的整数位的结果字符串的整数或带前导零的浮点数字，可以填充[自定义数字格式说明符](~/docs/standard/base-types/custom-numeric-format-strings.md)，如下面的示例所示。  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>在格式列表中可以包括多少个项？  
 没有任何实际的限制。 第二个参数<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法的标记为<xref:System.ParamArrayAttribute>特性，这使您可以包含一个分隔的列表或对象数组作为格式列表。  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>如何添加文本的大括号 ("{"和"}") 在结果字符串中？  
 例如，如何防止不能引发下面的方法调用<xref:System.FormatException>异常？  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 单个左或右大括号始终解释为开头或末尾的格式项。 若要按原义解释，它必须进行转义。 通过添加另一个大括号转义大括号 ("{{"和"}}"而不是"{"和"}")，如下面的方法调用：  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 但是，即使转义大括号是轻松地误解。 我们建议你在格式列表中包含大括号和格式项用于将它们插入在结果字符串中，如以下示例所示。  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>为什么我调用 String.Format 方法会引发 FormatException  
 异常的最常见原因是格式项的索引不对应于格式列表中的对象。 通常，这表示已 misnumbered 格式项的索引或忘记了要包含在格式列表中的对象。 试图包含非转义左或向右大括号字符也会引发<xref:System.FormatException>。 有时，例外情况是拼写错误; 结果例如，一个典型的错误是错"["（左的括号） 而不是"{"（的左大括号）。  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>如果 Format(System.IFormatProvider,System.String,System.Object[]) 方法支持参数数组，为什么会我的代码引发异常时我使用一个数组？  
 例如，下面的代码引发<xref:System.FormatException>异常：  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 这是编译器重载解析出现问题。 因为编译器不能将整数数组转换为对象数组，它将整数的数组视为单个参数，这样它便可以调用<xref:System.String.Format%28System.String%2CSystem.Object%29>方法。 将引发异常，因为有四个格式项，但仅格式列表中的单个项。  
  
 因为 Visual Basic 既不 C# 可以将一个整数数组转换为对象数组，必须在调用之前自行执行此转换<xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>方法。 下面的示例提供了一种实现。  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

调用的大量示例<xref:System.String.Format%2A>方法通过混杂[备注](#remarks)本文的部分。  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

此外可以下载一组完整的`String.Format`示例，包括[适用于 C#.NET Core 2.0 项目](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip)和一个[适用于 Visual Basic.NET Core 2.0 项目](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)，从[dotnet /示例 GitHub 存储库](https://github.com/dotnet/samples)。

以下是一些项目中所包含的示例：

### <a name="create-a-format-string"></a>创建一个格式字符串

[将字符串插入](#inserting-a-string)  
[格式项](#the-format-item)  
[格式项具有相同的索引](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>控制格式化的输出

[控制格式设置](#controlling-formatting)  
[控制间距](#controlling-spacing)  
[控制对齐方式](#controlling-alignment)  
[控制整数位的数](#how-do-i-control-the-number-of-integral-digits)  
[控制小数分隔符后的位数](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[在结果字符串中包括文本大括号](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>进行区分区域性的格式字符串

[区分区域性的格式设置](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>自定义格式设置操作

[自定义格式设置操作](#example-a-custom-formatting-operation)  
[截距提供程序和罗马数字格式化程序](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>将字符串中的一个或多个格式项替换为指定对象的字符串表示形式。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中的任何格式项均替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将表达式的值转换为其字符串表示形式，并将字符串中嵌入该表示形式。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>示例： 格式设置的单个自变量  
 
 下面的示例使用<xref:System.String.Format%28System.String%2CSystem.Object%29>方法嵌入字符串中间的一个人的年龄。  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 中的格式项无效。  
  
或 
格式项的索引不为零。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">一个对象数组，其中包含零个或多个要设置格式的对象。</param>
        <summary>将指定字符串中的格式项替换为指定数组中相应对象的字符串表示形式。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中格式项已替换为 <paramref name="args" /> 中相应对象的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将四个或多个表达式的值转换为其字符串表示形式，并将字符串中嵌入这些表示形式。 由于`args`参数将标有<xref:System.ParamArrayAttribute?displayProperty=nameWithType>属性中，您可以将对象传递给该方法为各个自变量或<xref:System.Object>数组。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>示例： 设置多个三个参数的格式  
 
 此示例创建一个字符串，包含在特定日期上高和低温度数据。 复合格式字符串具有五个格式项中的 C# 示例和六个 in Visual Basic 示例。 两个格式项定义其相应的值的字符串表示形式的宽度，第一个格式项还包括标准日期和时间格式字符串。  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 你还可以传递要格式化为数组的对象而不是一个自变量列表。  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于零或大于等于 <paramref name="args" /> 数组的长度。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>将指定字符串中的一个或多个格式项替换为对应对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中的一个或多个格式项已替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将表达式的值转换为其字符串表示形式，并将字符串中嵌入该表示形式。 在执行转换，该方法使用区分区域性的格式设置或自定义格式化程序。 该方法将`arg0`为其字符串表示形式通过调用其**ToString(IFormatProvider)** 方法，或者，如果该对象的相应格式项包含一个格式字符串，通过调用其**ToString (String，IFormatProvider）** 方法。 如果这些方法不存在，则会调用该对象的无参数**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引不为零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="args">一个对象数组，其中包含零个或多个要设置格式的对象。</param>
        <summary>将字符串中的格式项替换为指定数组中相应对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中格式项已替换为 <paramref name="args" /> 中相应对象的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将四个或多个表达式转换为其字符串表示形式，并将字符串中嵌入这些表示形式。 在执行转换，该方法使用区分区域性的格式设置或自定义格式化程序。 该方法将每个<xref:System.Object>参数为其字符串表示形式通过调用其**ToString(IFormatProvider)** 方法，或者，如果该对象的相应格式项包含一个格式字符串，通过调用其**ToString(String,IFormatProvider)** 方法。 如果这些方法不存在，则会调用该对象的无参数**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>示例： 区分区域性的格式设置  
 此示例使用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>方法以使用多个不同的区域性显示某些日期和时间值和数值的字符串表示形式。  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于零或大于等于 <paramref name="args" /> 数组的长度。</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>将字符串中的格式项替换为两个指定对象的字符串表示形式。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中的格式项替换为 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将两个表达式的值转换为其字符串表示形式，并将字符串中嵌入这些表示形式。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>示例： 两个自变量格式设置  
 
 此示例使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>方法来显示时间和温度数据存储在一个泛型<xref:System.Collections.Generic.Dictionary%602>对象。 请注意格式字符串具有三个格式项，尽管只有两个要格式化的对象。 这是因为在使用两个格式项列表 （日期和时间值） 中的第一个对象： 第一个格式项显示时，第二个显示的日期。  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引不为零或一。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>将字符串中的格式项替换为两个指定对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中的格式项替换为 <paramref name="arg0" /> 和 <paramref name="arg1" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将两个表达式转换为其字符串表示形式，并将字符串中嵌入这些表示形式。 在执行转换，该方法使用区分区域性的格式设置或自定义格式化程序。 该方法将每个<xref:System.Object>参数为其字符串表示形式通过调用其**ToString(IFormatProvider)** 方法，或者，如果该对象的相应格式项包含一个格式字符串，通过调用其**ToString(String,IFormatProvider)** 方法。 如果这些方法不存在，则会调用该对象的无参数**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引不为零或一。</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>将字符串中的格式项替换为三个指定对象的字符串表示形式。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中的格式项已替换为 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将三个表达式的值转换为其字符串表示形式，并将字符串中嵌入这些表示形式。 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>示例： 设置三个参数的格式  
 
 此示例使用<xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法来创建一个字符串，说明了一个布尔值结果`And`具有两个整数值的操作。 请注意，格式字符串包括六个格式项，但该方法具有在其参数列表中，只有三个项，因为每个项格式化两个不同的方式。  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于零，或者大于二。</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">[复合格式字符串](~/docs/standard/base-types/composite-formatting.md)。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>将字符串中的格式项替换为三个指定对象的字符串表示形式。 参数提供区域性特定的格式设置信息。</summary>
        <returns>
          <paramref name="format" /> 的副本，其中的格式项已替换为 <paramref name="arg0" />、<paramref name="arg1" /> 和 <paramref name="arg2" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将三个表达式转换为其字符串表示形式，并将字符串中嵌入这些表示形式。 在执行转换，该方法使用区分区域性的格式设置或自定义格式化程序。 该方法将每个<xref:System.Object>参数为其字符串表示形式通过调用其**ToString(IFormatProvider)** 方法，或者，如果该对象的相应格式项包含一个格式字符串，通过调用其**ToString(String,IFormatProvider)** 方法。 如果这些方法不存在，则会调用该对象的无参数**ToString**方法。  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
或 
格式项的索引小于零，或者大于二。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索一个可以循环访问此字符串中的每个字符的对象。</summary>
        <returns>枚举器对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> 而不是调用<xref:System.String.GetEnumerator%2A>方法来检索<xref:System.CharEnumerator>对象，然后用于枚举字符串，应改为使用你的语言的迭代构造 (在 C# 中，在 C + + /cli CLR，并在 Visual Basic 中)。 [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md)在 C# 中，[每个](/cpp/dotnet/for-each-in)在 C + + /cli CLR，和[每个](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)在 Visual Basic 中)。
  
 此方法可以循环访问字符串中的单个字符。 例如，Visual Basic`For Each`和 C#`foreach`语句调用此方法以返回<xref:System.CharEnumerator>可以提供对此字符串实例中字符的只读访问权限的对象。  
  
   
  
## Examples  
 下面的示例循环访问中的多个字符串的字符，并显示其各个字符有关的信息。 它使用的语言迭代构造而不是调用<xref:System.String.GetEnumerator%2A>方法。  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回该字符串的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 行为<xref:System.String.GetHashCode%2A>取决于其实现中，从公共语言运行时的一个版本到另一个可能会变化。 此错误的原因是为了提高性能的<xref:System.String.GetHashCode%2A>。  
  
> [!IMPORTANT]
>  如果两个字符串对象是否相等，<xref:System.String.GetHashCode%2A>方法返回完全相同的值。 但是，没有每个唯一字符串值的唯一哈希代码值。 不同的字符串可能会返回相同的哈希代码。  
>   
>  不保证本身的哈希代码以保持不变。 跨.NET 实现，各种.NET 版本和单个.NET 版本的.NET 平台 （例如 32 位和 64 位），相同字符串的哈希代码可能不同。 在某些情况下，它们可能甚至不同的应用程序域。 这意味着两个后续运行的同一个程序可能会返回不同的哈希代码。  
>   
>  因此，哈希代码应永远不会在其中创建了它们，应用程序域之外使用它们永远不应使用的键域中的一个集合，并应永远不会保留它们。  
>   
>  最后，不要将使用而不是返回的加密哈希函数，如果需要加密型强哈希值的哈希代码。 对于加密哈希，请使用派生自的类<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>类。  
>   
>  有关哈希代码的详细信息，请参阅<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
 在桌面应用程序，你可以使用[ \<userandomizedstringhashalgorithm，那么 > 元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)生成唯一的哈希代码对每个应用程序域。 这可以减少冲突数量，并提高插入和使用哈希表查找的整体性能。 下面的示例演示如何使用[ \<userandomizedstringhashalgorithm，那么 > 元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。 它定义要生成唯一的哈希代码上每个应用程序域。 这可以减少冲突数量，并提高插入和使用哈希表查找的整体性能。 下面的示例演示如何使用。 它定义`DisplayString`类，其中包含私有字符串常量， `s`，其值是"这是一个字符串"。 它还包括显示字符串值及其哈希代码的 `ShowStringHashCode` 方法以及该方法在其中执行的应用程序域的名称。  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 当您在未提供配置文件的情况下运行该示例时，它会显示类似下面的输出。 请注意，字符串的散列码在两个应用程序域中是相同的。  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 但是，如果将以下配置文件添加到示例目录，然后运行该示例，则同一个字符串的哈希代码将通过应用程序域进行区分。  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 存在配置文件时，示例会显示以下输出：  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  哈希代码用于插入和有效地从哈希表中检索键控的对象。 但是，哈希代码不唯一地标识字符串。 字符串具有相同哈希代码，但公共语言运行时还可以将相同的哈希代码分配给不同的字符串完全相同。 此外，哈希代码而异的.NET 版本、 平台中的一个版本，以及应用程序域。 正因为如此，不应序列化，或保留哈希代码值，也不应使用它们作为哈希表或字典中的键。  
  
 有关使用哈希代码的其他信息和`GetHashCode`方法，请参阅<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.GetHashCode%2A>方法使用各种输入字符串。  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>返回的值<see cref="M:System.String.GetHashCode" />与平台相关。 它在.NET Framework 的 32 位和 64 位版本上不同。 它也可以不同版本的.NET Framework 和.NET Core 之间。</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="http://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;Userandomizedstringhashalgorithm，那么&gt;元素</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回类 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.String" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示<xref:System.TypeCode>枚举的常量<xref:System.String>类型。  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告指定 Unicode 字符或字符串在此实例中的第一个匹配项的从零开始的索引。 如果未在此实例中找到该字符或字符串，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <summary>报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例演示如何搜索<xref:System.String>字符使用<xref:System.String.IndexOf%2A>方法。  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <summary>报告指定字符串在此实例中的第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符串，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 搜索。 搜索此实例的第一个字符位置开始，将继续，直到最后一个字符位置。  
  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果`value`仅包含一个或多个可忽略字符，<xref:System.String.IndexOf%28System.String%29>方法始终返回 0 （零） 以指示当前实例的开头找到的匹配项。 在以下示例中，<xref:System.String.IndexOf%28System.String%29>方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，每种情况下，因为软连字符是可忽略字符，因此结果是相同像软连字符不包含在`value`。 搜索的软连字符时，该方法将返回 0 （零） 以指示它已在字符串的开头找到匹配项。  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 下面的示例搜索"动物"中的"n"。 因为字符串的索引从零而不是一个开始<xref:System.String.IndexOf%28System.String%29>方法指示"n"位于位置 1。  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 下面的示例使用<xref:System.String.IndexOf%2A>方法，以确定一个句子中的起始位置的动物的名称。 然后使用此位置插入一个句子介绍动物的形容词。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要查找的字符串实例中的子字符串的第一个索引通过使用当前区域性的比较规则，请调用<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其`comparisonType`参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <summary>报告指定 Unicode 字符在此字符串中的第一个匹配项的从零开始的索引。 该搜索从指定字符位置开始。</summary>
        <returns>如果找到该字符，则为从字符串的起始位置开始的 <paramref name="value" /> 从零开始的索引位置；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编号从 0 开始的索引。 `startIndex` 参数可以介于 0 到字符串实例的长度。 如果`startIndex`等于字符串实例的长度，该方法将返回-1。  
  
 搜索范围为从`startIndex`到字符串的末尾。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.IndexOf%2A>方法。  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 小于零或大于字符串的长度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <summary>报告指定字符串在此实例中的第一个匹配项的从零开始的索引。 该搜索从指定字符位置开始。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 的索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编号从 0 开始的索引。 `startIndex` 参数可以介于 0 到字符串实例的长度。 如果`startIndex`等于字符串实例的长度，该方法将返回-1。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 搜索。 在开始执行搜索`startIndex`字符的此实例的位置，并将继续，直到最后一个字符位置。  
  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果`value`仅包含一个或多个可忽略字符，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法始终返回`startIndex`，即搜索开始处的字符位置。 在以下示例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>方法用于查找的软连字符 (U + 00AD) 后, 跟"m"两个字符串中的位置。 只有一个字符串包含必需的子字符串。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 下面的示例搜索目标字符串中指定的字符串的所有匹配项。  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 小于零或大于此字符串的长度。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要使用当前区域性的比较规则后的特定字符位置查找发生的子字符串的第一个索引，请调用<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其`comparisonType`参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。 一个参数指定要用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的索引位置；如果未找到该字符串，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 `comparisonType`参数指定要搜索`value`参数使用当前或固定区域性，使用区分大小写或不区分大小写搜索，以及使用 word 或序号比较规则。  
  
   
  
## Examples  
 以下 exampledemonstrates 三个重载<xref:System.String.IndexOf%2A>查找在字符串中使用的不同值的另一个字符串的第一个匹配项的方法<xref:System.StringComparison>枚举。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法始终返回 0 （零） 以指示当前实例的开头找到的匹配项。  
  
在以下示例中，<see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，因为软连字符是一个可忽略字符，区分区域性的搜索将返回相同的值，它将返回如果搜索字符串中未包含软连字符。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [！ 代码 vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定字符在此实例中的第一个匹配项的从零开始的索引。 搜索从指定字符位置开始，并检查指定数量的字符位置。</summary>
        <returns>如果找到该字符，则为从字符串的起始位置开始的 <paramref name="value" /> 从零开始的索引位置；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在开始执行搜索`startIndex`，而且以后继续`startIndex`  +  `count` -1。 处的字符`startIndex`  +  `count`不包括在搜索中。  
  
 编号从 0 （零） 开始的索引。 `startIndex` 参数可以介于 0 到字符串实例的长度。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.IndexOf%2A>方法。  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。  
  
或 
 <paramref name="startIndex" /> 大于此字符串的长度。  
  
或 
 <paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定字符串在此实例中的第一个匹配项的从零开始的索引。 搜索从指定字符位置开始，并检查指定数量的字符位置。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 的索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编号从 0 （零） 开始的索引。 `startIndex` 参数可以介于 0 到字符串实例的长度。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 搜索。 在开始执行搜索`startIndex`，而且以后继续`startIndex`  +  `count` -1。 处的字符`startIndex`  +  `count`不包括在搜索中。  
  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果`value`仅包含一个或多个可忽略字符，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法始终返回`startIndex`，即搜索开始处的字符位置。 在以下示例中，<xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法用于查找的软连字符 (U + 00AD) 后, 跟"m"中第三到两个字符串中的第六个字符位置开始的位置。 只有一个字符串包含必需的子字符串。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引执行区分区域性的比较时。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 下面的示例查找字符串的所有匹配项的索引"he"另一个字符串的子字符串中。 请注意要搜索的字符数必须针对每个搜索迭代重新计算。  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。  
  
或 
 <paramref name="startIndex" /> 大于此字符串的长度。  
  
或 
 <paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要使用当前区域性的比较规则执行此操作，调用<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其`comparisonType`参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。 参数指定当前字符串中的起始搜索位置以及用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 参数索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编号从 0 开始的索引。 `startIndex` 参数可以介于 0 到字符串实例的长度。 如果`startIndex`等于字符串实例的长度，该方法将返回-1。  
  
 `comparisonType`参数指定要搜索`value`参数使用当前或固定区域性，使用区分大小写或不区分大小写搜索，以及使用 word 或序号比较规则。  
  
   
  
## Examples  
 以下 exampledemonstrates 三个重载<xref:System.String.IndexOf%2A>查找在字符串中使用的不同值的另一个字符串的第一个匹配项的方法<xref:System.StringComparison>枚举。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 小于零或大于此字符串的长度。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"从两个字符串中的第三个字符位置开始的位置。 只有一个字符串包含必需的子字符串。如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引执行区分区域性的比较时。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [！ 代码 vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定的字符串在当前 <see cref="T:System.String" /> 对象中的第一个匹配项的从零开始的索引。 参数指定当前字符串中的起始搜索位置、要搜索的当前字符串中的字符数量，以及要用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为从当前实例的起始位置开始的从零开始的 <paramref name="value" /> 参数索引位置；否则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编号从 0 （零） 开始的索引。 `startIndex` 参数可以介于 0 到字符串实例的长度。  
  
 在开始执行搜索`startIndex`，而且以后继续`startIndex`  +  `count` -1。 处的字符`startIndex`  +  `count`不包括在搜索中。  
  
 `comparisonType`参数指定要搜索`value`参数使用当前或固定区域性，使用区分大小写或不区分大小写搜索，以及使用 word 或序号比较规则。  
  
   
  
## Examples  
 以下 exampledemonstrates 三个重载<xref:System.String.IndexOf%2A>查找在字符串中使用的不同值的另一个字符串的第一个匹配项的方法<xref:System.StringComparison>枚举。  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。  
  
或 
 <paramref name="startIndex" /> 大于此实例的长度。  
  
或 
 <paramref name="count" /> 大于此字符串的长度减 <paramref name="startIndex" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"中第三到两个字符串中的第六个字符位置开始的位置。 只有一个字符串包含必需的子字符串。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引执行区分区域性的比较时。 当它执行序号比较时，但是，它找到的子字符串仅在第一个字符串中。 请注意，对于第一个字符串，包含软连字符后跟"m"，该方法无法返回软连字符的索引而是返回"m"的索引执行区分区域性的比较时。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [！ 代码 vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的索引。 如果未在此实例中找到数组中的字符，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。</summary>
        <returns>在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 搜索`anyOf`区分大小写。 如果`anyOf`是一个空数组，方法找到匹配的字符串开头 （即，位于索引零）。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例查找字符串中第一个元音。  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。 该搜索从指定字符位置开始。</summary>
        <returns>在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 `startIndex`参数的范围可以介于 0 到字符串实例的长度减一。  
  
 搜索范围为从`startIndex`到字符串的末尾。  
  
 搜索`anyOf`区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当它们的 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 以下示例查找字符串的任何字符的匹配项的索引"是"另一个字符串的子字符串中。  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 为负数。  
  
或 
 <paramref name="startIndex" /> 大于此实例中的字符数。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定 Unicode 字符数组中的任意字符在此实例中第一个匹配项的从零开始的索引。 搜索从指定字符位置开始，并检查指定数量的字符位置。</summary>
        <returns>在此实例中第一次找到 <paramref name="anyOf" /> 中的任意字符的索引位置（从零开始）；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在开始执行搜索`startIndex`，而且以后继续`startIndex`  +  `count` -1。 处的字符`startIndex`  +  `count`不包括在搜索中。  
  
 从零开始的索引编号。 `startIndex`参数的范围可以介于 0 到字符串实例的长度减一。  
  
 搜索`anyOf`区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当它们的 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例查找子字符串的另一个字符串中的任何字符的字符串"帮助"的匹配项的索引。  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。  
  
或 
 <paramref name="count" /> + <paramref name="startIndex" /> 大于此实例中的字符数。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">插入的从零开始的索引位置。</param>
        <param name="value">要插入的字符串。</param>
        <summary>返回一个新的字符串，在此实例中的指定的索引位置插入指定的字符串。</summary>
        <returns>与此实例等效的一个新字符串，但在该字符串的 <paramref name="value" /> 位置处插入了 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`startIndex`等于此实例的长度`value`追加到此实例的结尾。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新字符串，在其中`value`插入到当前实例。  
  
 例如，返回值的`"abc".Insert(2, "XYZ")`是"abXYZc"。  
  
   
  
## Examples  
 下面的示例在一个字符串的第四个字符位置 （索引 3 处的字符） 中插入空格字符。  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 以下控制台应用程序会提示用户输入一个或多个用于描述两个动物的形容词。 然后，它调用<xref:System.String.Insert%2A>方法插入到一个字符串，由用户输入的文本。  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 为负，或大于此实例的长度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要在暂存池中搜索的字符串。</param>
        <summary>检索系统对指定 <see cref="T:System.String" /> 的引用。</summary>
        <returns>如果暂存了 <paramref name="str" />，则返回系统对其的引用；否则返回对值为 <paramref name="str" /> 的字符串的新引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时维护一个名为暂存池中，包含对每个声明或在程序中以编程方式创建的唯一字符串的单个引用的表，从而节约的字符串存储空间。 因此，文本字符串的特定值的实例只能一次系统中存在。  
  
 例如，如果将相同的文本字符串分配给多个变量，请在运行时检索对文字字符串的相同引用从暂存池中，并将其分配给每个变量。  
  
 <xref:System.String.Intern%2A>方法使用暂存池中搜索的值相等的字符串`str`。 如果存在这样的字符串，则返回它在暂存池中的引用。 如果字符串不存在，对引用`str`添加到暂存池中，则返回该引用。  
  
 在以下示例中，因为它是在程序中的文本已暂存的值为"MyTest"，字符串 s1。 <xref:System.Text.StringBuilder?displayProperty=nameWithType>类生成一个新的字符串对象具有与 s1 相同的值。 该字符串的引用分配到 s2。 <xref:System.String.Intern%2A>具有相同的值为 s2 的字符串方法搜索。 由于存在这样的字符串，该方法将返回分配给 s1 相同的引用。 然后，该引用被分配到 s3。 由于它们是指不同的对象; 因此，引用 s1 和 s2 比较不相等引用 s1 和 s3，比较结果相等，这是因为它们引用相同的字符串。  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 将此方法<xref:System.String.IsInterned%2A>方法。  
  
## <a name="version-considerations"></a>版本的注意事项  
 在中[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]，则<xref:System.String.Intern%2A>方法恢复到其行为在.NET Framework 1.0 和 1.1 对于暂留空字符串。 在下面的示例中，变量`str1`分配到的引用<xref:System.String.Empty>，和变量`str2`分配对引用<xref:System.String.Empty>返回通过调用<xref:System.String.Intern%2A>方法之后转换<xref:System.Text.StringBuilder>对象，其值为<xref:System.String.Empty>为字符串。 然后在包含的引用`str1`和`str2`比较是否相等。  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 在中[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]， [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，并[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]，`str1`和`str2`是否相等。 在中[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]并[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]，`str1`和`str2`是否不相等。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果想要减少的总内存量分配你的应用程序，请注意，暂留一个字符串，具有两个不需要的副作用。 首先，内存分配的暂留<xref:System.String>对象不太可能，公共语言运行时 (CLR) 操作终止事务之前释放。 其原因在于对暂存的 CLR 的引用<xref:System.String>对象可以保存您的应用程序或甚至在应用程序域后，将终止。 其次，要留用字符串，必须先创建字符串。 使用的内存<xref:System.String>对象必须仍然分配，即使内存最终将进行垃圾回收。  
  
 .NET Framework 2.0 版引入了<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType>枚举成员。 <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>成员标记为不需要字符串暂留的程序集。 您可以将应用<xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>使用的程序集<xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>属性。 此外，使用[Ngen.exe （本机映像生成器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)若要编译的程序集之前运行时，会不暂留字符串多个模块。  
  
   
  
## Examples  
 下面的示例使用三个值以确定是否有新创建的字符串相等的字符串和留用的字符串相等。  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要在暂存池中搜索的字符串。</param>
        <summary>检索对指定 <see cref="T:System.String" /> 的引用。</summary>
        <returns>如果 <paramref name="str" /> 在公共语言运行时的暂存池中，则返回对它的引用；否则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时自动维护一个名为暂存池中，它包含在一个程序，以及任何唯一的实例中声明每个唯一文本字符串常量的单个实例的表<xref:System.String>以编程方式添加通过调用<xref:System.String.Intern%2A>方法。  
  
 暂存池中，从而节约的字符串存储空间。 如果将一个文本字符串常量分配给多个变量，请设置每个变量为引用在暂存池中，而不是引用的几个不同实例中的相同常量<xref:System.String>具有相同的值。  
  
 此方法查找`str`在暂存池中。 如果`str`已经过暂留，对该实例的引用是返回; 否则为`null`返回。  
  
 将此方法<xref:System.String.Intern%2A>方法。  
  
 此方法不返回布尔值。 如果您调用该方法，因为需要一个布尔值，该值指示是否暂留的特定字符串，可以使用类似以下的代码。  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  从.NET Framework 2.0 版开始，你可以重写的暂存池中使用当你使用[Ngen.exe （本机映像生成器）](~/docs/framework/tools/ngen-exe-native-image-generator.md)将程序集安装到本地计算机上的本机映像缓存。 有关详细信息，请参阅备注部分中的性能注意事项<xref:System.String.Intern%2A>属性。  
  
   
  
## Examples  
 下面的示例演示由编译器自动暂存是文本字符串。  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示此字符串是否符合特定的 Unicode 范式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示此字符串是否符合 Unicode 范式 C。</summary>
        <returns>如果此字符串符合范式 C，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字符具有多个等效的二进制表示形式包含的组合集和/或组合的 Unicode 字符。 搜索、 排序、 匹配和其他操作，会增加复杂性存在单个字符的多个表示形式。  
  
 Unicode 标准定义了名为返回在给定的任何字符的等效的二进制表示的一种二进制表示形式的规范化的过程。 可以使用多种算法，名为规范化形式的不同的规则执行规范化。 .NET 目前支持 C、 D、 KC 和 KD 正常化窗体。  
  
 有关受支持的 Unicode 范式的说明，请参阅<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例确定是否已成功为各种范式规范化字符串。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />方法将返回<see langword="false" />一旦遇到第一个非规范化字符在字符串中的。 因此，如果字符串包含无效的 Unicode 字符后, 跟非规范化字符<see cref="Overload:System.String.Normalize" />方法将引发<see cref="T:System.ArgumentException" />虽然<see cref="Overload:System.String.IsNormalized" />返回<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">一个 Unicode 范式。</param>
        <summary>指示此字符串是否符合指定的 Unicode 范式。</summary>
        <returns>如果此字符串符合由 <see langword="true" /> 参数指定的范式，则为 <paramref name="normalizationForm" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字符具有多个等效的二进制表示形式包含的组合集和/或组合的 Unicode 字符。 搜索、 排序、 匹配和其他操作，会增加复杂性存在单个字符的多个表示形式。  
  
 Unicode 标准定义了名为返回在给定的任何字符的等效的二进制表示的一种二进制表示形式的规范化的过程。 可以使用多种算法，名为规范化形式的不同的规则执行规范化。 .NET 目前支持 C、 D、 KC 和 KD 正常化窗体。  
  
 有关受支持的 Unicode 范式的说明，请参阅<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.IsNormalized%2A>和<xref:System.String.Normalize%2A>方法。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />方法将返回<see langword="false" />一旦遇到第一个非规范化字符在字符串中的。 因此，如果字符串包含无效的 Unicode 字符后, 跟非规范化字符<see cref="Overload:System.String.Normalize" />方法将引发<see cref="T:System.ArgumentException" />虽然<see cref="Overload:System.String.IsNormalized" />返回<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要测试的字符串。</param>
        <summary>指示指定的字符串是 <see langword="null" /> 还是 <see cref="F:System.String.Empty" /> 字符串。</summary>
        <returns>如果 <paramref name="value" /> 参数为 <see langword="true" /> 或空字符串 ("")，则为 <see langword="null" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> 是，您可以同时测试的便捷方法是否<xref:System.String>是`null`或其值为<xref:System.String.Empty>。 它等效于以下代码：  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 可以使用<xref:System.String.IsNullOrWhiteSpace%2A>方法来测试字符串是否为`null`，其值是<xref:System.String.Empty?displayProperty=nameWithType>，或它仅包含空白字符。  
  
## <a name="what-is-a-null-string"></a>什么是一个 null 字符串？  
 字符串是`null`如果它尚未分配的值 （c + + 和 Visual Basic） 或显式已分配的值为`null`。 尽管[复合格式设置](~/docs/standard/base-types/composite-formatting.md)功能可以正常处理 null 的字符串，如以下示例所示，如果其成员引发尝试调用一个<xref:System.NullReferenceException>。  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>什么是空字符串？  
 一个字符串为空，如果它显式分配空字符串 ("") 或<xref:System.String.Empty?displayProperty=nameWithType>。 空字符串具有<xref:System.String.Length%2A>为 0。  下面的示例创建一个空字符串，并显示其值，其长度。  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 以下示例检查三个字符串并确定每个字符串具有一个值、 为空字符串，或未`null`。  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要测试的字符串。</param>
        <summary>指示指定的字符串是 <see langword="null" />、空还是仅由空白字符组成。</summary>
        <returns>如果 <see langword="true" /> 参数为 <paramref name="value" /> 或 <see langword="null" />，或者如果 <see cref="F:System.String.Empty" /> 仅由空白字符组成，则为 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> 是类似于下面的代码，只是它提供优异的性能的便捷方法：  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 由 Unicode 标准定义的空白字符。 <xref:System.String.IsNullOrWhiteSpace%2A>方法将返回的值的任何字符解释`true`传递给时<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法作为空白字符。  
  
   
  
## Examples  
 以下示例创建一个字符串数组，并随后将传递到的数组的每个元素<xref:System.String.IsNullOrWhiteSpace%2A>方法。  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>连接指定数组的元素或集合的成员，在每个元素或成员之间使用指定的分隔符。</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。只有在 <c>values</c> 具有多个元素时，<c>separator</c> 才包括在返回的字符串中。</param>
        <param name="values">一个包含要串联的字符串的集合。</param>
        <summary>串联类型为 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 的 <see cref="T:System.String" /> 构造集合的成员，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="values" /> 没有成员，则该方法返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`separator`是`null`，为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改为使用。 如果的任何成员`values`是`null`，改为使用空字符串。  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> 是可以串联的每个元素的便捷方法`IEnumerable(Of String)`不必先转换为字符串数组元素的集合。 它是语言集成查询 (LINQ) 查询表达式特别有用。 下面的示例传入`List(Of String)`对象，其中包含为 lambda 表达式的选择是等于或大于特定字母 （即，在示例中，"M"） 的字母字母表中的大写或小写字母。 `IEnumerable(Of String)`返回的集合<xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>方法将传递给<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法以将结果显示为单个字符串。  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 以下示例使用埃拉托色的尼斯筛法算法来计算小于或等于 100 的质数。 它会将结果发送到将分配<xref:System.Collections.Generic.List%601>类型的对象<xref:System.String>，然后将其传递到<xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法。  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 只有在 <c>values</c> 具有多个元素时，<c>separator</c> 才包括在返回的字符串中。</param>
        <param name="values">一个数组，其中包含要连接的元素。</param>
        <summary>串联对象数组的各个元素，其中在每个元素之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="values" /> 为空数组，该方法将返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`separator`是`null`或者如果的任何元素`values`的第一个元素而不是`null`，为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改为使用。 如果看到的调用方部分的说明的第一个元素`values`是`null`。  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> 是可以无需显式将它的元素转换为字符串串联对象数组中的每个元素的便捷方法。 数组中的每个对象的字符串表示形式通过调用该对象的派生`ToString`方法。  
  
   
  
## Examples  
 以下示例使用埃拉托色的尼斯筛法算法来计算小于或等于 100 的质数。 它将结果分配给整数数组，然后将其传递到<xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>方法。  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>如果第一个元素的<paramref name="values" />是<see langword="null" />，则<see cref="M:System.String.Join(System.String,System.Object[])" />方法不串联中的元素<paramref name="values" />而是返回<see cref="F:System.String.Empty" />。 提供了大量有关此问题的解决方法。 最简单的方法是将分配的值为<see cref="F:System.String.Empty" />数组的第一个元素，如以下示例所示。  
  
[！ 代码 csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [！ 代码 vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 只有在 <c>value</c> 具有多个元素时，<c>separator</c> 才包括在返回的字符串中。</param>
        <param name="value">一个数组，其中包含要连接的元素。</param>
        <summary>串联字符串数组的所有元素，其中在每个元素之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="value" /> 中的元素组成的字符串，这些元素以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="value" /> 为空数组，该方法将返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，如果`separator`是"，"和的元素`value`"apple"、"橙色"、"grape"和"pear"`Join(separator, value)`返回"apple、 橙色、 grape 负责，pear"。  
  
 如果`separator`是`null`，为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改为使用。 如果中的任何元素`value`是`null`，改为使用空字符串。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Join%2A>方法。  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">要用作分隔符的字符串。 只有在 <c>value</c> 具有多个元素时，<c>separator</c> 才包括在返回的字符串中。</param>
        <param name="value">一个数组，其中包含要连接的元素。</param>
        <param name="startIndex">
          <c>value</c> 中要使用的第一个元素。</param>
        <param name="count">要使用的 <c>value</c> 的元素数。</param>
        <summary>串联字符串数组的指定元素，其中在每个元素之间使用指定的分隔符。</summary>
        <returns>由 <paramref name="value" /> 中的字符串组成的字符串，这些字符串以 <paramref name="separator" /> 字符串分隔。  
  
或 
 如果 <see cref="F:System.String.Empty" /> 为零，<paramref name="count" /> 没有元素，或 <paramref name="value" /> 以及 <paramref name="separator" /> 的全部元素均为 <paramref name="value" />，则为 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，如果`separator`是"，"和的元素`value`"apple"、"橙色"、"grape"和"pear"`Join(separator, value, 1, 2)`返回"橙色，grape"。  
  
 如果`separator`是`null`，为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改为使用。 如果中的任何元素`value`是`null`，改为使用空字符串。  
  
   
  
## Examples  
 下面的示例连接中的水果名称的数组的两个元素。  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="count" /> 小于 0。  
  
或 
 <paramref name="startIndex" /> 加上 <paramref name="count" /> 大于 <paramref name="value" /> 中的元素数。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">成员的类型<c>值</c>。</typeparam>
        <param name="separator">要用作分隔符的字符串。只有在 <c>values</c> 具有多个元素时，<c>separator</c> 才包括在返回的字符串中。</param>
        <param name="values">一个包含要串联的对象的集合。</param>
        <summary>串联集合的成员，其中在每个成员之间使用指定的分隔符。</summary>
        <returns>一个由 <paramref name="values" /> 的成员组成的字符串，这些成员以 <paramref name="separator" /> 字符串分隔。 如果 <paramref name="values" /> 没有成员，则该方法返回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`separator`是`null`，为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>) 改为使用。 如果的任何成员`values`是`null`，改为使用空字符串。  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 是可以串联的每个成员的便捷方法<xref:System.Collections.Generic.IEnumerable%601>而无需首先将它们转换为字符串的集合。 在每个对象的字符串表示形式<xref:System.Collections.Generic.IEnumerable%601>通过调用该对象的派生集合`ToString`方法。  
  
 此方法为特定语言集成查询 (LINQ) 查询表达式有用。 例如，下面的代码定义一个非常简单`Animal`类，该类包含动物和它所属的顺序的名称。 然后，它定义<xref:System.Collections.Generic.List%601>对象，其中包含许多`Animal`对象。 <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>调用扩展方法来提取`Animal`对象的`Order`属性等于"老鼠"。 将结果传递给<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 以下示例使用埃拉托色的尼斯筛法算法来计算小于或等于 100 的质数。 它会将结果发送到将分配<xref:System.Collections.Generic.List%601>对象的整数类型，然后将其传递到<xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>方法。  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告指定 Unicode 字符或字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 如果未在此实例中找到该字符或字符串，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <summary>报告指定 Unicode 字符在此实例中的最后一个匹配项的从零开始的索引的位置。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 此方法开始搜索此实例的最后一个字符位置和后面开始直至`value`找到或已检查完第一个字符位置。 搜索是区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例定义`ExtractFilename`方法，它使用<xref:System.String.LastIndexOf%28System.Char%29>方法以查找字符串中最后一个目录分隔符字符并将提取字符串的文件的名称。 如果该文件存在，该方法将返回不包含路径的文件名称。  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为此实例中的最后一个索引位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 搜索此实例的最后一个字符位置开始，后面开始直至`value`找到或已检查完第一个字符位置。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 搜索。  
  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果`value`仅包含一个或多个可忽略字符，<xref:System.String.LastIndexOf%28System.String%29>方法始终返回<xref:System.String.Length%2A?displayProperty=nameWithType>– 1，表示当前实例中的最后一个索引位置。 在以下示例中，<xref:System.String.LastIndexOf%28System.String%29>方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，每种情况下，因为软连字符是可忽略字符，因此结果是相同像软连字符不包含在`value`。 搜索的软连字符时，该方法将返回 6 和 5。 这些值对应于两个字符串中的最后一个字符的索引。  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 下面的示例移除打开和关闭从一个字符串，如果标记开始和结束字符串的 HTML 标记。 如果某个字符串结尾右方括号字符 (">")，该示例使用<xref:System.String.LastIndexOf%2A>方法查找结束标记的起始位置。  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要查找的字符串实例中的子字符串的最后一个索引通过使用当前区域性的比较规则，请调用<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索的起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <summary>报告指定 Unicode 字符在此实例中的最后一个匹配项的从零开始的索引的位置。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1.此方法开始搜索，在`startIndex`字符位置的此实例和将继续向后直至当前实例的开头`value`找到或已检查完第一个字符位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，则方法会从最后一个字符的每个字符搜索到开头的字符串中。 搜索是区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例查找在字符串中，从字符串的末尾使用到字符串的开头的所有出现的字符索引。  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于等于当前实例的长度。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 在开始执行搜索`startIndex`字符位置的此实例和将继续直至开头向后`value`找到或已检查完第一个字符位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，则方法会从最后一个字符的每个字符搜索到开头的字符串中。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 搜索。  
  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果`value`仅包含一个或多个可忽略字符，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法始终返回`startIndex`，即搜索开始处的字符位置。 在以下示例中，<xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>方法用于查找子字符串，其中包含软连字符 (U + 00AD) 并且之前或在字符串中包含的最后一个"m"。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，搜索字符串中的软连字符将被忽略，因为调用要查找的子字符串，包含软连字符和"m"在字符串中，返回"m"的位置而调用它以查找 substrin 的方法g 包含软连字符和"n"返回"n"的位置。 当搜索字符串中包含仅软连字符时，方法会返回"m"，它表示的值的索引`startIndex`。  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 下面的示例在目标字符串中，从目标字符串的末尾使用到的目标字符串起始位置查找字符串的所有匹配项的索引。  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于当前实例的长度。  
  
或 
当前实例等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于-1 或大于零。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要查找特定的字符位置之前通过使用当前区域性的比较规则的子字符串的索引，请调用<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定字符串在当前 <see cref="T:System.String" /> 对象中最后一个匹配项的从零开始的索引。 一个参数指定要用于指定字符串的搜索类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为此实例中的最后一个索引位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 `comparisonType`参数指定要搜索`value`参数使用当前或固定区域性，使用区分大小写或不区分大小写搜索，以及使用 word 或序号比较规则。  
  
 搜索此实例的最后一个字符位置开始，后面开始直至`value`找到或已检查完第一个字符位置。  
  
   
  
## Examples  
 以下 exampledemonstrates 三个重载<xref:System.String.LastIndexOf%2A>查找在字符串中使用的不同值的另一个字符串的最后一个匹配项的方法<xref:System.StringComparison>枚举。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法始终返回<see cref="P:System.String.Length" />– 1，表示当前实例中的最后一个索引位置。  
  
在以下示例中，<see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />方法用于在两个字符串中查找三个子字符串 （软连字符 (U + 00AD)、 软连字符后跟"n"和软连字符后跟"m"）。 只有一个字符串包含软连字符。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，因为软连字符是一个可忽略字符，区分区域性的搜索将返回相同的值，它将返回如果搜索字符串中未包含软连字符。 序号搜索，但是，成功地在一个字符串中查找软连字符，并报告它不存在从第二个字符串。  
  
[！ 代码 csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [！ 代码 vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 Unicode 字符。</param>
        <param name="startIndex">搜索的起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定的 Unicode 字符在此实例内的子字符串中的最后一个匹配项的从零开始的索引的位置。 搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</summary>
        <returns>如果找到该字符，则为 <paramref name="value" /> 的从零开始的索引位置；如果未找到该字符或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 此方法开始搜索，在`startIndex`字符位置，沿反向向前直至此实例的开头`value`找到或`count`检查了字符位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，则方法会向后搜索`count`从字符串中的最后一个字符的字符。 搜索是区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当它们的 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例查找子字符串，到起始位置的子字符串的从字符串末尾工作中出现的所有字符的索引。  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于等于当前实例的长度。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 在开始执行搜索`startIndex`字符位置的此实例，沿反向直至开头`value`找到或`count`检查了字符位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，则方法会向后搜索`count`从字符串中的最后一个字符的字符。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 搜索。  
  
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索中，如果 `value` 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果`value`仅包含一个或多个可忽略字符，<xref:System.String.LastIndexOf%2A>方法始终返回`startIndex`，即搜索开始处的字符位置。 在以下示例中，<xref:System.String.LastIndexOf%2A>方法用于查找在前两个字符串的最后一个"m"的两个字符软连字符 (U + 00AD) 的位置。 只有一个字符串包含必需的子字符串。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引执行区分区域性的比较时。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 下面的示例查找该子字符串中从子字符串的末尾到开头的子字符串的字符串的所有匹配项的索引。  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 为负数。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 为负数。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 大于此实例的长度。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> - <paramref name="count" /> + 1 指定不在此实例内的位置。  
  
或 
当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="start" /> 小于 -1 或大于零。  
  
或 
当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="count" /> 大于 1。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要使用当前区域性的比较规则执行此操作，调用<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定字符串在当前 <see cref="T:System.String" /> 对象中最后一个匹配项的从零开始的索引。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。 一个参数指定要执行搜索指定字符串的比较类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 在开始执行搜索`startIndex`字符位置，沿反向直至`value`找到或已检查完第一个字符位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，则方法会从最后一个字符的每个字符搜索到开头的字符串中。  
  
 `comparisonType`参数指定要搜索`value`参数使用当前或固定区域性，使用区分大小写或不区分大小写搜索，以及使用 word 或序号比较规则。  
  
   
  
## Examples  
 以下 exampledemonstrates 三个重载<xref:System.String.LastIndexOf%2A>查找在字符串中使用的不同值的另一个字符串的最后一个匹配项的方法<xref:System.StringComparison>枚举。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于零或大于当前实例的长度。  
  
或 
当前实例等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 小于-1 或大于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />方法用于查找的软连字符 (U + 00AD) 后, 跟"m"，从最后一个"m"两个字符串中开始的位置。 只有一个字符串包含必需的子字符串。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引执行区分区域性的比较时。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [！ 代码 vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要搜寻的字符串。</param>
        <param name="startIndex">搜索起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <param name="count">要检查的字符位置数。</param>
        <param name="comparisonType">指定搜索规则的枚举值之一。</param>
        <summary>报告指定字符串在此实例中的最后一个匹配项的从零开始的索引的位置。 搜索在所指定的字符位置的数目的字符串开始时，开始指定字符和其后面的位置。 一个参数指定要执行搜索指定字符串的比较类型。</summary>
        <returns>如果找到该字符串，则为 <paramref name="value" /> 参数的从零开始的起始索引位置；如果未找到该字符串或当前实例等于 <see cref="F:System.String.Empty" />，则为 -1。 如果 <paramref name="value" /> 为 <see cref="F:System.String.Empty" />，则返回值为 <paramref name="startIndex" /> 和此实例中的最后一个索引位置中的较小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。 也就是说，在字符串中的第一个字符位于索引零和最后一个是在<xref:System.String.Length%2A>-1。  
  
 在开始执行搜索`startIndex`字符位置，沿直至反向`value`找到或`count`检查了字符位置。 例如，如果`startIndex`是<xref:System.String.Length%2A>-1，则方法会向后搜索`count`从字符串中的最后一个字符的字符。  
  
 `comparisonType`参数指定要搜索`value`参数使用当前或固定区域性，使用区分大小写或不区分大小写搜索，以及使用 word 或序号比较规则。  
  
   
  
## Examples  
 以下 exampledemonstrates 三个重载<xref:System.String.LastIndexOf%2A>查找在字符串中使用的不同值的另一个字符串的最后一个匹配项的方法<xref:System.StringComparison>枚举。  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 为负数。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 为负数。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 大于此实例的长度。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> + 1 - <paramref name="count" /> 指定不在此实例内的位置。  
  
或 
当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="start" /> 小于 -1 或大于零。  
  
或 
当前实例等于 <see cref="F:System.String.Empty" /> 并且 <paramref name="count" /> 大于 1。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
        <block subset="none" type="usage">
          <para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 在区分区域性的搜索 (即，如果 <paramref name="comparisonType" /> 不是 <see cref="F:System.StringComparison.Ordinal" /> 或 <see cref="F:System.StringComparison.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法始终返回<paramref name="startIndex" />，即搜索开始处的字符位置。  
  
在以下示例中，<see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />方法用于在两个字符串中查找所有中后, 跟"m"的软连字符 (U + 00AD) 位置，但之前最后一个"m"的第一个字符位置。 只有一个字符串包含必需的子字符串。 如果运行该示例[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]或更高版本，这两种情况下，因为软连字符是可忽略字符，则此方法返回的字符串中的"m"的索引执行区分区域性的比较时。 当它执行序号比较时，但是，它找到的子字符串仅在第一个字符串中。 请注意，对于第一个字符串，包含软连字符后跟"m"，该方法无法返回软连字符的索引而是返回"m"的索引执行区分区域性的比较时。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。  
  
[！ 代码 csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [！ 代码 vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。 如果未在此实例中找到数组中的字符，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。</summary>
        <returns>最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 此方法开始搜索此实例的最后一个字符位置和后面直到中的字符开始`anyOf`找到或已检查完第一个字符位置。 搜索是区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 以下示例查找字符串中的任何字符的最后一个匹配项的索引"是"另一个字符串内。  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。 在指定的字符位置开始和在向后的右边该字符串的开头处理的搜索。</summary>
        <returns>最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符或者当前实例等于<see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 此方法开始搜索，在`startIndex`字符位置的此实例和继续执行直到中的字符开头向后`anyOf`找到或已检查完第一个字符位置。 搜索是区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 以下示例查找字符串中的任何字符的最后一个匹配项的索引"是"另一个字符串的子字符串中。  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 指定不在此实例内的位置。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Unicode 字符数组，包含一个或多个要查找的字符。</param>
        <param name="startIndex">搜索起始位置。 从 <c>startIndex</c> 开始搜索，一直到此实例的开头处。</param>
        <param name="count">要检查的字符位置数。</param>
        <summary>报告在 Unicode 数组中指定的一个或多个字符在此实例中的最后一个匹配项的从零开始的索引的位置。 搜索在指定字符位置的数目的字符串开始时，开始指定字符和其后面的位置。</summary>
        <returns>最后一次在此实例中找到 <paramref name="anyOf" /> 中的任意字符的索引位置；如果未找到 <paramref name="anyOf" /> 中的字符或者当前实例等于<see cref="F:System.String.Empty" />，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从零开始的索引编号。  
  
 此方法开始搜索，在`startIndex`字符位置的此实例和将继续向后直到中的字符开头`anyOf`找到或`count`检查了字符位置。 搜索是区分大小写。  
  
 此方法执行序号 （不区分区域性） 搜索，其中一个字符被视为等效于另一个字符，仅当其 Unicode 标量值是相同的。 若要执行区分区域性的搜索，请使用<xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>方法，其中一个预构成的字符，例如连字"存储"(U + 00 C 6)，它表示一个 Unicode 标量值可能被视为等效于任何形式的字符中的组件更正序列，如 AE (u+0041，U + 0045)，则根据区域性。  
  
   
  
## Examples  
 下面的示例查找另一个字符串的一个子字符串的字符串"帮助"中的任何字符的最后一个匹配项的索引。  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="count" /> 或 <paramref name="startIndex" /> 为负数。  
  
或 
当前实例不等于 <see cref="F:System.String.Empty" />，并且 <paramref name="startIndex" /> 减去 <paramref name="count" /> 再加 1 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.String" /> 对象中的字符数。</summary>
        <value>当前字符串中字符的数量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Length%2A>属性返回的数<xref:System.Char>此实例中的对象，不是 Unicode 字符数。 原因是可能由多个表示 Unicode 字符<xref:System.Char>。 使用<xref:System.Globalization.StringInfo?displayProperty=nameWithType>类，以便每个 Unicode 字符而不是每个<xref:System.Char>。  
  
 在某些语言中，如 C 和 c + +，null 字符指示字符串的末尾。 在.NET 中，可以在字符串中嵌入 null 字符。 当字符串包含一个或多个 null 字符时，它们包含在字符串的总长度。 例如，在以下字符串"abc"和"def"由 null 字符分隔的子字符串。 <xref:System.String.Length%2A>属性将返回 7，这表示它包含六个字母字符以及 null 字符。  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Length%2A>属性。  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，其二进制表示形式符合特定的 Unicode 范式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合 Unicode 范式 C。</summary>
        <returns>一个新的规范化字符串，其文本值与此字符串相同，但其二进制表示形式符合范式 C。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字符具有多个等效的二进制表示形式包含的组合集和/或组合的 Unicode 字符。 例如，下面的代码点的任何可表示字母"ắ":  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 搜索、 排序、 匹配和其他操作，会增加复杂性存在单个字符的多个表示形式。  
  
 Unicode 标准定义了名为返回在给定的任何字符的等效的二进制表示的一种二进制表示形式的规范化的过程。 可以使用多种算法，名为规范化形式的不同的规则执行规范化。 .NET 支持的四个规范化窗体 （C、 D、 KC 和 KD） 由 Unicode 标准定义。 当两个字符串都包含在相同的范式时，它们可以通过使用序号比较进行比较。  
  
 若要将规范化和比较两个字符串，执行以下步骤：  
  
1.  获取要从输入源，如文件或用户输入的设备进行比较的字符串。  
  
2.  调用<xref:System.String.Normalize>方法以将字符串规范化为范式 c。  
  
3.  若要比较两个字符串，调用如支持的序号字符串比较的方法<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，并提供的值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>作为<xref:System.StringComparison>参数。 若要排序的规范化字符串数组，请将传递`comparer`的值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>的适当重载<xref:System.Array.Sort%2A?displayProperty=nameWithType>。  
  
4.  发出基于上一步所述的顺序排序的输出中的字符串。  
  
 有关受支持的 Unicode 范式的说明，请参阅<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例将每个四个规范化窗体的字符串，确认字符串已规范化为指定的范式，然后列出正常化的字符串中的码位。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />方法将返回<see langword="false" />一旦遇到第一个非规范化字符在字符串中的。 因此，如果字符串包含无效的 Unicode 字符后, 跟非规范化字符<see cref="Overload:System.String.Normalize" />方法将引发<see cref="T:System.ArgumentException" />虽然<see cref="Overload:System.String.IsNormalized" />返回<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">一个 Unicode 范式。</param>
        <summary>返回一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合指定的 Unicode 范式。</summary>
        <returns>一个新字符串，其文本值与此字符串相同，但其二进制表示形式符合由 <paramref name="normalizationForm" /> 参数指定的范式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Unicode 字符具有多个等效的二进制表示形式包含的组合集和/或组合的 Unicode 字符。 搜索、 排序、 匹配和其他操作，会增加复杂性存在单个字符的多个表示形式。  
  
 Unicode 标准定义了名为返回在给定的任何字符的等效的二进制表示的一种二进制表示形式的规范化的过程。 可以使用多种算法，名为规范化形式的不同的规则执行规范化。 .NET 支持的四个规范化窗体 （C、 D、 KC 和 KD） 由 Unicode 标准定义。 当两个字符串都包含在相同的范式时，它们可以通过使用序号比较进行比较。  
  
 若要将规范化和比较两个字符串，执行以下步骤：  
  
1.  获取要从输入源，如文件或用户输入的设备进行比较的字符串。  
  
2.  调用<xref:System.String.Normalize%28System.Text.NormalizationForm%29>方法以将字符串规范化为指定的范式。  
  
3.  若要比较两个字符串，调用如支持的序号字符串比较的方法<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>方法，并提供的值<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>作为<xref:System.StringComparison>参数。 若要排序的规范化字符串数组，请将传递`comparer`的值<xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType>或<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType>的适当重载<xref:System.Array.Sort%2A?displayProperty=nameWithType>。  
  
4.  发出基于上一步所述的顺序排序的输出中的字符串。  
  
 有关受支持的 Unicode 范式的说明，请参阅<xref:System.Text.NormalizationForm?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例将每个四个规范化窗体的字符串，确认字符串已规范化为指定的范式，然后列出正常化的字符串中的码位。  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前实例包含无效的 Unicode 字符。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.String.IsNormalized" />方法将返回<see langword="false" />一旦遇到第一个非规范化字符在字符串中的。 因此，如果字符串包含无效的 Unicode 字符后, 跟非规范化字符<see cref="Overload:System.String.Normalize" />方法可能会引发<see cref="T:System.ArgumentException" />虽然<see cref="Overload:System.String.IsNormalized" />返回<see langword="false" />。</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <summary>确定两个指定的字符串是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值相同，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Equality%2A>方法定义的相等运算符的运算<xref:System.String>类。 这样，如示例部分中所示的代码。 运算符，又调用静态<xref:System.String.Equals%28System.String%2CSystem.String%29>方法，用于执行序号 （区分大小写和不区分区域性） 比较。  
  
> [!NOTE]
>  Visual Basic 编译器不能解决与调用的相等运算符<xref:System.String.op_Equality%2A>方法。 相反，相等运算符包装对的调用<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例演示了相等运算符。  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">要比较的第一个字符串，或 <see langword="null" />。</param>
        <param name="b">要比较的第二个字符串，或 <see langword="null" />。</param>
        <summary>确定两个指定的字符串是否具有不同的值。</summary>
        <returns>如果 <see langword="true" /> 的值与 <paramref name="a" /> 的值不同，则为 <paramref name="b" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.op_Inequality%2A>方法定义为不等运算符的运算<xref:System.String>类。   这样，如示例部分中所示的代码。  
  
 <xref:System.String.op_Inequality%2A>运算符反过来调用静态<xref:System.String.Equals%28System.String%2CSystem.String%29>方法，用于执行序号 （区分大小写和不区分区域性） 比较。  
  
> [!NOTE]
>  Visual Basic 编译器不能解决不等运算符与调用<xref:System.String.op_Inequality%2A>方法。 而是，是否不相等运算符会包装调用<xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例演示不等运算符。  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个指定长度的新字符串，其中在当前字符串的开头填充空格或指定的 Unicode 字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此实例中的字符左侧填充空格来达到指定的总长度，从而实现右对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为右对齐，因此，在左侧填充所需任意数量的空格，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空间被定义为十六进制 0x0020。  
  
 <xref:System.String.PadLeft%28System.Int32%29>方法来填充返回的字符串的开头。 这意味着，对从右到左的语言使用时，它将填充字符串的右侧部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadLeft%2A>方法填补空白字符与当前实例，此方法不会修改当前实例的值。 相反，它返回一个新字符串，则用前导空白字符填充，以便其总长度`totalWidth`字符。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.PadLeft%2A>方法。  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <param name="paddingChar">Unicode 填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此实例中的字符左侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符右对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为右对齐，因此，在左侧填充所需任意数量的 <paramref name="paddingChar" /> 字符，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>方法来填充返回的字符串的开头。 这意味着，对从右到左的语言使用时，它将填充字符串的右侧部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadLeft%2A>方法填补空白字符与当前实例，此方法不会修改当前实例的值。 相反，它返回一个新字符串，则用前导填充`paddingChar`个字符，因此使其总长度`totalWidth`字符。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.PadLeft%2A>方法。  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个指定长度的新字符串，其中在当前字符串的结尾填充空格或指定的 Unicode 字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此字符串中的字符右侧填充空格来达到指定的总长度，从而使这些字符左对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为左对齐，因此，在右侧填充所需任意数量的空格，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unicode 空间被定义为十六进制 0x0020。  
  
 <xref:System.String.PadRight%28System.Int32%29>方法来填充返回的字符串的末尾。 这意味着，对从右到左的语言使用时，它将填充字符串的左侧的部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadRight%2A>方法填补空白字符与当前实例，此方法不会修改当前实例的值。 相反，它返回一个新字符串，以便其总长度是用尾随空格填充`totalWidth`字符。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.PadRight%2A>方法。  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">结果字符串中的字符数，等于原始字符数加上任何其他填充字符。</param>
        <param name="paddingChar">Unicode 填充字符。</param>
        <summary>返回一个新字符串，该字符串通过在此字符串中的字符右侧填充指定的 Unicode 字符来达到指定的总长度，从而使这些字符左对齐。</summary>
        <returns>与此实例等效的一个新字符串，但该字符串为左对齐，因此，在右侧填充所需任意数量的 <paramref name="paddingChar" /> 字符，使长度达到 <paramref name="totalWidth" />。 但是，如果 <paramref name="totalWidth" /> 小于此实例的长度，则此方法返回对现有实例的引用。 如果 <paramref name="totalWidth" /> 等于此实例的长度，则此方法返回与此实例相同的新字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>方法来填充返回的字符串的末尾。 这意味着，对从右到左的语言使用时，它将填充字符串的左侧的部分。  
  
> [!NOTE]
>  如果<xref:System.String.PadRight%2A>方法填补空白字符与当前实例，此方法不会修改当前实例的值。 相反，它返回一个新字符串，则用尾随填充`paddingChar`个字符，因此使其总长度`totalWidth`字符。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.PadRight%2A>方法。  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> 小于零。</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，它相当于从当前字符串删除了指定数量的字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">开始删除字符的从零开始的位置。</param>
        <summary>返回当前实例中从指定位置到最后位置的所有以删除的字符的新字符串。</summary>
        <returns>一个新字符串，除所删除的字符之外，该字符串与此字符串等效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字符串是从零开始。 值`startIndex`参数可以介于 0 到字符串实例的长度减去一。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串中的所有字符从位置`startIndex`到原始字符串的末尾已被删除。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.Remove%2A>方法。 下一步至最后一种情况下删除从通过字符串末尾的指定索引开始的所有文本。 最后一种情况中删除从指定索引开始的三个字符。  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 指定的位置不在此字符串内。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">开始删除字符的从零开始的位置。</param>
        <param name="count">要删除的字符数。</param>
        <summary>返回指定数量字符在当前这个实例起始点在已删除的指定的位置的新字符串。</summary>
        <returns>一个新字符串，除所删除的字符之外，该字符串与此实例等效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，字符串是从零开始。 值`startIndex`参数可以介于 0 到字符串实例的长度减去一。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新字符串，其中由指定的字符数`count`参数已被删除。 在指定的位置删除的字符`startIndex`。  
  
   
  
## Examples  
 下面的示例演示如何从完整名称中删除中间名。  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 加 <paramref name="count" /> 之和指定一个此实例外的位置。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，其中已将当前字符串中的指定 Unicode 字符或 <see cref="T:System.String" /> 的所有匹配项替换为其他指定的 Unicode 字符或 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的 Unicode 字符。</param>
        <param name="newChar">要替换出现的所有 <c>oldChar</c> 的 Unicode 字符。</param>
        <summary>返回一个新字符串，其中此实例中出现的所有指定 Unicode 字符都替换为另一个指定的 Unicode 字符。</summary>
        <returns>等效于此实例（除了 <paramref name="oldChar" /> 的所有实例都已替换为 <paramref name="newChar" /> 外）的字符串。 如果在当前实例中找不到 <paramref name="oldChar" />，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号 （区分大小写和不区分区域性的） 搜索以查找`oldChar`。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串中出现的所有`oldChar`替换为`newChar`。  
  
 由于此方法返回修改后的字符串，你可以链接在一起对连续调用<xref:System.String.Replace%2A>方法来对原始字符串执行多个替换项。 从左向右执行方法调用。 下面的示例进行了这方面的演示。  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 下面的示例创建的以逗号分隔值列表，只需替换一系列数字之间的空白的逗号。  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">要替换 <c>oldValue</c> 的所有匹配项的字符串。</param>
        <summary>返回一个新字符串，其中当前实例中出现的所有指定字符串都替换为另一个指定的字符串。</summary>
        <returns>等效于当前字符串（除了 <paramref name="oldValue" /> 的所有实例都已替换为 <paramref name="newValue" /> 外）的字符串。 如果在当前实例中找不到 <paramref name="oldValue" />，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`newValue`是`null`，出现的所有`oldValue`删除。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串中出现的所有`oldValue`替换为`newValue`。  
  
 此方法执行序号 （区分大小写和不区分区域性的） 搜索以查找`oldValue`。  
  
 由于此方法返回修改后的字符串，你可以链接在一起对连续调用<xref:System.String.Replace%2A>方法来对原始字符串执行多个替换项。 从左向右执行方法调用。 下面的示例进行了这方面的演示。  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.String.Replace%2A>方法更正拼写错误。  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> 为空字符串 ("")。</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回的字符串数组包含此实例中的子字符串（由指定字符串或 Unicode 字符数组的元素分隔）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> 用于分解成子字符串的带分隔符的字符串。 可以使用字符数组来指定零行、 一行或多个分隔字符 (<xref:System.String.Split%28System.Char%5B%5D%29>方法)，或者可以使用的字符数组来指定零行、 一行或多个分隔字符串。 重载<xref:System.String.Split%2A>方法允许你限制数量的方法返回的子字符串 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>方法)，以确定是否返回子字符串中包含空字符串 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法，或上述两个 (<xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>和<xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>方法)。  
  
> [!IMPORTANT]
>  有关更多详细信息上<xref:System.String.Split%2A>方法，如以及调用的示例中，每个重载，请参阅的文档的各个重载<xref:System.String.Split%2A>。  
  
 <xref:System.String.Split%2A>方法始终不是分解成子字符串的带分隔符的字符串的最佳方式。 如果不想要提取所有带分隔符的字符串的子字符串，或者如果你想要分析字符串而不是一组分隔符字符的模式，请考虑以下替代方法。  
  
## <a name="regular-expressions"></a>正则表达式  
 如果您的字符串遵循固定模式，可以使用正则表达式以提取并处理其元素。 例如，如果字符串采用以下形式"*数量**操作数**数*"可以使用[正则表达式](~/docs/standard/base-types/regular-expressions.md)提取和处理字符串的元素。 以下是一个示例：  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 正则表达式模式`(\d+)\s+([-+*/])\s+(\d+)`定义如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`(\d+)`|匹配一个或多个十进制数字。 这是第一个捕获组。|  
|`\s+`|匹配一个或多个空白字符。|  
|`([-+*/])`|匹配一个算术运算符号 (+、-、 *，或 /)。 这是第二个捕获组。|  
|`\s+`|匹配一个或多个空白字符。|  
|`(\d+)`|匹配一个或多个十进制数字。 这是第三个捕获组。|  
  
 正则表达式还可用于从基于一种模式而不是一组固定的字符的字符串中提取子字符串。 其中一项条件发生时，这是一种常见方案：  
  
-   一个或多个分隔符字符不会始终处理中的分隔符<xref:System.String>实例。  
  
-   顺序和分隔符的字符数是变量或未知。  
  
 例如，<xref:System.String.Split%2A>方法不能用于拆分以下字符串，因为数`\n`（在 C# 中) 或`vbCrLf`（在 Visual Basic) 字符是变量，因此它们始终不用作分隔符。  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 正则表达式可以轻松地，如以下示例所示拆分此字符串。  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 正则表达式模式`\[([^\[\]]+)\]`定义如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`\[`|匹配左括号。|  
|`([^\[\]]+)`|匹配任何字符不是一个左或右括号之间的一个或多个时间。 这是第一个捕获组。|  
|`\]`|匹配右括号。|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法在几乎等同于<xref:System.String.Split%2A?displayProperty=nameWithType>，只不过它将拆分而不是固定的字符集的正则表达式模式的字符串。 例如，下面的示例使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法拆分包含子字符串由连字符和其他字符的各种组合分隔的字符串。  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 正则表达式模式`\s-\s?[+*]?\s?-\s`定义如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`\s-`|匹配空白字符后跟一个连字符。|  
|`\s?`|匹配零个或一个空白字符。|  
|`[+*]?`|匹配零个或一个匹配项的 + 或 * 字符。|  
|`\s?`|匹配零个或一个空白字符。|  
|`-\s`|匹配连字符后跟空白字符。|  
  
## <a name="search-methods-and-the-substring-method"></a>搜索方法和 Substring 方法  
 如果您不感兴趣所有字符串中子字符串，可能希望使用一个返回匹配的开始的索引的字符串比较方法。 然后，可以调用<xref:System.String.Substring%2A>方法提取所需的子字符串。 字符串比较方法包括：  
  
-   <xref:System.String.IndexOf%2A>它返回字符串实例中的字符或字符串的第一个匹配项的从零开始的索引。  
  
-   <xref:System.String.IndexOfAny%2A>它返回的字符数组中的任何字符的第一个匹配项的当前字符串实例中的从零开始的索引。  
  
-   <xref:System.String.LastIndexOf%2A>它返回字符串实例中的字符或字符串的最后一个匹配项的从零开始的索引。  
  
-   <xref:System.String.LastIndexOfAny%2A>它返回从零开始的索引中的字符数组中的任何字符的最后一个匹配项的当前字符串实例。  
  
 下面的示例使用<xref:System.String.IndexOf%2A>方法来查找字符串中的段。 然后，它使用<xref:System.String.Substring%2A>方法以返回完整的句子。  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <summary>基于数组中的字符将字符串拆分为多个子字符串。</summary>
        <returns>一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当由一组已知的字符分隔字符串时，可以使用<xref:System.String.Split%28System.Char%5B%5D%29>方法分隔为若干子字符串。 若要从字符串中提取子字符串的其他方法，请参阅[String.Split 的替代方法](#Alternatives)部分。  
  
## <a name="return-value-details"></a>返回值的详细信息  
 返回数组的元素中不包括分隔符字符。 例如，如果分隔符数组包含字符"-"和当前字符串实例的值为"aa bb cc"，该方法返回一个数组，包含三个元素:"aa"、"bb"和"cc"。  
  
 如果此实例不包含任何中的字符`separator`，返回的数组以包含此实例的单个元素组成。  
  
 每个元素`separator`定义单独的分隔符字符。 如果两个分隔符是相邻，或分隔符位于开头或末尾此实例，则返回的数组中的相应元素包含<xref:System.String.Empty>。 下面是一些可能的恶意活动：  
  
|字符串值|Separator|返回的数组|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|新 Char [] {'，'，' '} (C#)<br /><br /> Char （) = {"、"c，""c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|新 Char [] {'。} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|新 Char [] {'。} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba"(C#)<br /><br /> "Darb"vbLf &"Smarba"(Visual Basic)|新 Char [] {} (C#)<br /><br /> Char （) = {} (Visual Basic)|{"Darb"，"Smarba"}|  
|"Darb\nSmarba"(C#)<br /><br /> "Darb"vbLf &"Smarba"(Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb"，"Smarba"}|  
  
## <a name="the-separator-array"></a>分隔符数组  
 分隔符的每个元素定义包含的单个字符的不同分隔符。 如果`separator`自变量是`null`或不包含任何字符，该方法将空格字符视为分隔符。 由 Unicode 标准; 定义的空白字符它们将返回`true`如果将它们传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>String.Split(Char[]) 和编译器重载解析  
 尽管的此重载的单个参数<xref:System.String.Split%2A?displayProperty=nameWithType>是字符数组中，可以调用它用单个字符，如以下示例所示。  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 因为`separator`参数用修饰<xref:System.ParamArrayAttribute>特性，编译器会将解释为单元素字符数组的单个字符。 这不是适用于其他用例<xref:System.String.Split%2A?displayProperty=nameWithType>包括的重载`separator`参数，则必须显式传递这些重载将字符数组作为`separator`参数。  
  
## <a name="comparison-details"></a>比较详细信息  
 <xref:System.String.Split%28System.Char%5B%5D%29>方法将提取由一个或多个中的字符分隔此字符串中子字符串`separator`数组，并将这些子字符串作为数组的元素返回。  
  
 <xref:System.String.Split%28System.Char%5B%5D%29>方法执行比较使用区分大小写的序号排序规则查找分隔符。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>枚举。  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>String.Split 的替代方法  
 <xref:System.String.Split%2A>方法始终不是分解成子字符串的带分隔符的字符串的最佳方式。 如果不想要提取所有带分隔符的字符串的子字符串，或者如果你想要分析字符串而不是一组分隔符字符的模式，请考虑以下替代方法。  
  
### <a name="regular-expressions"></a>正则表达式  
 如果您的字符串遵循固定模式，可以使用正则表达式以提取并处理其元素。 例如，如果字符串采用以下形式"*数量**操作数**数*"可以使用[正则表达式](~/docs/standard/base-types/regular-expressions.md)提取和处理字符串的元素。 以下是一个示例：  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 正则表达式模式`(\d+)\s+([-+*/])\s+(\d+)`定义如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`(\d+)`|匹配一个或多个十进制数字。 这是第一个捕获组。|  
|`\s+`|匹配一个或多个空白字符。|  
|`([-+*/])`|匹配一个算术运算符号 (+、-、 *，或 /)。 这是第二个捕获组。|  
|`\s+`|匹配一个或多个空白字符。|  
|`(\d+)`|匹配一个或多个十进制数字。 这是第三个捕获组。|  
  
 正则表达式还可用于从基于一种模式而不是一组固定的字符的字符串中提取子字符串。 其中一项条件发生时，这是一种常见方案：  
  
-   一个或多个分隔符字符不会始终处理中的分隔符<xref:System.String>实例。  
  
-   顺序和分隔符的字符数是变量或未知。  
  
 例如，<xref:System.String.Split%2A>方法不能用于拆分以下字符串，因为数`\n`（在 C# 中) 或`vbCrLf`（在 Visual Basic) 字符是变量，因此它们始终不用作分隔符。  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 正则表达式可以轻松地，如以下示例所示拆分此字符串。  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 正则表达式模式`\[([^\[\]]+)\]`定义如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`\[`|匹配左括号。|  
|`([^\[\]]+)`|匹配任何字符不是一个左或右括号之间的一个或多个时间。 这是第一个捕获组。|  
|`\]`|匹配右括号。|  
  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法在几乎等同于<xref:System.String.Split%2A?displayProperty=nameWithType>，只不过它将拆分而不是固定的字符集的正则表达式模式的字符串。 例如，下面的示例使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法拆分包含子字符串由连字符和其他字符的各种组合分隔的字符串。  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 正则表达式模式`\s-\s?[+*]?\s?-\s`定义如下：  
  
|模式|描述|  
|-------------|-----------------|  
|`\s-`|匹配空白字符后跟一个连字符。|  
|`\s?`|匹配零个或一个空白字符。|  
|`[+*]?`|匹配零个或一个匹配项的 + 或 * 字符。|  
|`\s?`|匹配零个或一个空白字符。|  
|`-\s`|匹配连字符后跟空白字符。|  
  
### <a name="search-methods-and-the-substring-method"></a>搜索方法和 Substring 方法  
 如果您不感兴趣所有字符串中子字符串，可能希望使用一个返回匹配的开始的索引的字符串比较方法。 然后，可以调用<xref:System.String.Substring%2A>方法提取所需的子字符串。 字符串比较方法包括：  
  
-   <xref:System.String.IndexOf%2A>它返回字符串实例中的字符或字符串的第一个匹配项的从零开始的索引。  
  
-   <xref:System.String.IndexOfAny%2A>它返回的字符数组中的任何字符的第一个匹配项的当前字符串实例中的从零开始的索引。  
  
-   <xref:System.String.LastIndexOf%2A>它返回字符串实例中的字符或字符串的最后一个匹配项的从零开始的索引。  
  
-   <xref:System.String.LastIndexOfAny%2A>它返回从零开始的索引中的字符数组中的任何字符的最后一个匹配项的当前字符串实例。  
  
 下面的示例使用<xref:System.String.IndexOf%2A>方法来查找字符串中的段。 然后，它使用<xref:System.String.Substring%2A>方法以返回完整的句子。  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>性能注意事项  
 <xref:System.String.Split%2A>方法返回的数组对象分配内存和<xref:System.String>每个数组元素的对象。 如果应用程序需要获得最佳性能，或者如果是在应用程序中关键的管理内存分配，请考虑使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法。 此外可以选择使用<xref:System.String.Compare%2A>方法来查找字符串中的子字符串。  
  
 若要拆分处分隔符字符的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法以在字符串中定位的分隔符字符。 若要在分隔符字符串将字符串拆分，请使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法查找分隔符字符串的第一个字符。 然后，使用<xref:System.String.Compare%2A>方法，以确定该第一个字符后的字符的分隔符字符串的剩余字符是否相等。  
  
 此外，如果一组相同的字符用于拆分字符串中存在多个<xref:System.String.Split%2A>方法调用，请考虑创建一个数组，并在每个方法调用中引用它。 这将显著减少每个方法调用的额外开销。  
  
   
  
## Examples  
 下面的示例演示如何通过将空格和标点符号作为分隔符的文本块从提取各个单词。 字符数组传递给`separator`参数的<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法组成一个空格字符和制表符，以及一些常用标点符号。  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]及更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法传递<paramref name="separator" />即<see langword="null" />或不包含任何字符，该方法使用略有不同的一组字符来拆分字符串比<see cref="M:System.String.Trim(System.Char[])" />方法执行到修整字符串。 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，这两种方法使用一组相同的 Unicode 空白字符。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="count">要返回的子字符串的最大数量。</param>
        <summary>基于数组中的字符将一个字符串拆分成最大数量的子字符串。 也可指定要返回的子字符串的最大数量。</summary>
        <returns>一个数组，其元素包含此实例中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回数组的元素中不包括分隔符字符。  
  
 如果此实例不包含任何中的字符`separator`，返回的数组以包含此实例的单个元素组成。 如果`count`为零，则返回空数组。  
  
 如果`separator`参数是`null`不包含任何字符或空格字符被假定为分隔符。 由 Unicode 标准和返回定义的空白字符`true`如果将它们传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
 每个元素`separator`定义单独的分隔符字符。 如果两个分隔符是相邻，或分隔符位于开头或末尾此实例，则相应的数组元素包含<xref:System.String.Empty>。  
  
 如果有多个`count`此实例中的子字符串第一个`count`减 1 的子字符串中返回第一个`count`减 1 个元素的返回值和此实例中的剩余字符返回的最后一个返回值的元素。  
  
 如果`count`大于数量的子字符串，则返回可用的子字符串并不会引发异常。  
  
 下表提供了示例。  
  
|字符串值|Separator|计数|返回的数组|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|新 Char [] {'，'，' '} (C#)<br /><br /> Char （) = {"、"c，""c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|新 Char [] {'。} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|新 Char [] {'。} (C#)<br /><br /> Char （) = {"。"c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba"(C#)<br /><br /> "Darb"vbLf &"Smarba"(Visual Basic)|新 Char [] {} (C#)<br /><br /> Char （) = {} (Visual Basic)|1|{"Darb\nSmarba"}(C#)<br /><br /> "Darb"vbLf &"Smarba"(Visual Basic)|  
|"Darb\nSmarba"(C#)<br /><br /> "Darb"vbLf &"Smarba"(Visual Basic)|新的 Char [] null (C#)<br /><br /> Char （) = Nothing|2|{"Darb"，"Smarba"}|  
|"Darb\nSmarba"(C#)<br /><br /> "Darb"vbLf &"Smarba"(Visual Basic)|新的 Char [] null (C#)<br /><br /> Char （) = Nothing|100|{"Darb"，"Smarba"}|  
  
## <a name="performance-considerations"></a>性能注意事项  
 <xref:System.String.Split%2A>方法返回的数组对象分配内存和<xref:System.String>每个数组元素的对象。 如果应用程序需要获得最佳性能，或者如果是在应用程序中关键的管理内存分配，请考虑使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，并选择性地<xref:System.String.Compare%2A>方法，以查找字符串中的子字符串。  
  
 如果你拆分处分隔符字符的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法以在字符串中定位的分隔符字符。 如果你拆分处分隔符字符串的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法查找分隔符字符串的第一个字符。 然后，使用<xref:System.String.Compare%2A>方法，以确定该第一个字符后的字符的分隔符字符串的剩余字符是否相等。  
  
 此外，如果一组相同的字符用于拆分字符串中存在多个<xref:System.String.Split%2A>方法调用，请考虑创建一个数组，并在每个方法调用中引用它。 这将显著减少每个方法调用的额外开销。  
  
   
  
## Examples  
 下面的示例演示如何`count`影响返回的字符串数<xref:System.String.Split%2A>。  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 为负数。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]及更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法传递<paramref name="separator" />即<see langword="null" />或不包含任何字符，该方法使用略有不同的一组字符来拆分字符串比<see cref="M:System.String.Trim(System.Char[])" />方法执行到修整字符串。 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，这两种方法使用一组相同的 Unicode 空白字符。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="options">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>基于数组中的字符将字符串拆分为多个子字符串。 可以指定子字符串是否包含空数组元素。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>返回值的详细信息  
 分隔符字符 (中的字符`separator`数组) 不包括在返回数组的元素。 例如，如果`separator`数组包含字符"-"和当前字符串实例的值为"aa bb cc"，该方法返回一个数组，包含三个元素:"aa"、"bb"和"cc"。  
  
 如果此实例不包含任何中的字符`separator`，返回的数组以包含此实例的单个元素组成。  
  
 如果`options`参数是<xref:System.StringSplitOptions.RemoveEmptyEntries>和此实例的长度为零，则该方法返回一个空数组。  
  
 每个元素`separator`定义包含的单个字符的不同分隔符。 如果`options`自变量是<xref:System.StringSplitOptions.None>，且它是相邻的两个分隔符或分隔符找到开头或结尾的此实例相对应的数组元素包含<xref:System.String.Empty?displayProperty=nameWithType>。 例如，如果`separator`包括两个元素，"-"和"\_"，字符串实例的值是"-\_aa-\_"，和的值`options`自变量是<xref:System.StringSplitOptions.None>，该方法返回的字符串数组以下五个元素：  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>它表示之前的空字符串"-"字符位于索引 0 处。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>它表示之间的空字符串"-"字符在索引 0 和位于索引 1 处的"_"字符。  
  
3.  "aa"，  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>它表示索引 4"_"字符后面的空字符串。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>它表示后面的空字符串"-"字符索引 5 处。  
  
## <a name="the-separator-array"></a>分隔符数组  
 如果`separator`参数是`null`不包含任何字符或空格字符被假定为分隔符。 由 Unicode 标准和返回定义的空白字符`true`如果将它们传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
 如果`separator`对此方法的重载的调用中的参数是`null`，编译器重载解析失败。 若要明确地标识所调用的方法，您的代码必须指示的类型`null`。 下面的示例显示了几种方法都会明确标识此重载。  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>比较详细信息  
 <xref:System.String.Split%2A>方法将提取由一个或多个中的字符分隔此字符串中子字符串`separator`参数，并将这些子字符串作为数组的元素返回。  
  
 <xref:System.String.Split%2A>方法执行比较使用区分大小写的序号排序规则查找分隔符。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>枚举。  
  
## <a name="performance-considerations"></a>性能注意事项  
 <xref:System.String.Split%2A>方法返回的数组对象分配内存和<xref:System.String>每个数组元素的对象。 如果应用程序需要获得最佳性能，或者如果是在应用程序中关键的管理内存分配，请考虑使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，并选择性地<xref:System.String.Compare%2A>方法，以查找字符串中的子字符串。  
  
 如果你拆分处分隔符字符的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法以在字符串中定位的分隔符字符。 如果你拆分处分隔符字符串的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法查找分隔符字符串的第一个字符。 然后，使用<xref:System.String.Compare%2A>方法，以确定该第一个字符后的字符的分隔符字符串的剩余字符是否相等。  
  
 此外，如果一组相同的字符用于拆分字符串中存在多个<xref:System.String.Split%2A>方法调用，请考虑创建一个数组，并在每个方法调用中引用它。 这将显著减少每个方法调用的额外开销。  
  
   
  
## Examples  
 下面的示例使用<xref:System.StringSplitOptions>枚举来包括或排除子字符串由生成<xref:System.String.Split%2A>方法。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]及更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法传递<paramref name="separator" />即<see langword="null" />或不包含任何字符，该方法使用略有不同的一组字符来拆分字符串比<see cref="M:System.String.Trim(System.Char[])" />方法执行到修整字符串。 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，这两种方法使用一组相同的 Unicode 空白字符。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符串数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="options">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>基于数组中的字符串将字符串拆分为多个子字符串。 可以指定子字符串是否包含空数组元素。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符串分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当一组已知的字符串由分隔字符串时，可以使用<xref:System.String.Split%2A>方法分隔为若干子字符串。  
  
## <a name="return-value-details"></a>返回值的详细信息  
 返回数组的元素中不包括分隔符字符串。 例如，如果`separator`数组包含字符串"-"和当前字符串实例的值为"aa-bb cc"，该方法返回一个数组，包含三个元素:"aa"、"bb"和"cc"。  
  
 如果此实例不包含任何中的字符串`separator`，返回的数组以包含此实例的单个元素组成。  
  
 如果`options`参数是<xref:System.StringSplitOptions.RemoveEmptyEntries>和此实例的长度为零，则该方法返回一个空数组。  
  
 每个元素`separator`定义一个或多个字符组成的单独分隔符。 如果`options`自变量是<xref:System.StringSplitOptions.None>，且它是相邻的两个分隔符或分隔符找到开头或结尾的此实例相对应的数组元素包含<xref:System.String.Empty?displayProperty=nameWithType>。 例如，如果`separator`包括两个元素，"-"和"_"的字符串实例的值是"-_aa-\_"，和的值`options`自变量是<xref:System.StringSplitOptions.None>，该方法返回以下五个元素的字符串数组：  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>它表示之前的空字符串"-"索引 0 处的子字符串。  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>它表示之间的空字符串"-"在索引 0 和位于索引 1 处的"_"子字符串的子字符串。  
  
3.  "aa"，  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>它表示索引 4 处的"_"子字符串之后的空字符串。  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>它表示后面的空字符串"-"索引 5 处的子字符串。  
  
## <a name="the-separator-array"></a>分隔符数组  
 如果中的元素的任何`separator`包含多个字符，将整个子字符串被视为分隔符。 例如，如果一个中的元素的`separator`为"10"，尝试进行拆分的字符串"This10is10a10string。" 返回以下四个元素数组: {"This"，"is"，"a"、"字符串。 }.  
  
 如果`separator`参数是`null`不包含任何字符或空格字符被假定为分隔符。 由 Unicode 标准和返回定义的空白字符`true`如果将它们传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
 如果`separator`对此方法的重载的调用中的参数是`null`，编译器重载解析失败。 若要明确地标识所调用的方法，您的代码必须指示的类型`null`。 下面的示例显示了几种方法都会明确标识此重载。  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>比较详细信息  
 <xref:System.String.Split%2A>方法将提取由一个或多个字符串中分隔此字符串中的子字符串`separator`参数，并将这些子字符串作为数组的元素返回。  
  
 <xref:System.String.Split%2A>方法执行比较使用区分大小写的序号排序规则查找分隔符。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>枚举。  
  
 <xref:System.String.Split%2A>方法将忽略的任何元素`separator`其值是`null`或空字符串 ("")。  
  
 若要避免不明确的结果时中字符串`separator`具有公共，字符<xref:System.String.Split%2A>操作从开始处继续到的实例的值的末尾和匹配的第一个元素`separator`，它等于中分隔符实例。 在其中子字符串的实例中出现的顺序的优先级高于中元素的顺序`separator`。  
  
 例如，考虑一个其值是"abcdef"的实例。 如果中的第一个元素`separator`是"ef"，且第二个元素为"bcde"，该拆分操作的结果将是一个字符串数组，包含两个元素，"a"和"f"。 这是因为在实例中，"bcde"的子字符串中遇到和中的元素匹配`separator`遇到"f"的子字符串之前。  
  
 但是，如果第一个元素的`separator`为"bcd"和第二个元素为"bc"，该拆分操作的结果将是一个字符串数组，包含两个元素，"a"和"ef"。 这是因为"bcd"中的第一个分隔符`separator`相匹配的实例中的分隔符。 如果分隔符的顺序已撤消，因此第一个元素是"bc"，并且第二个元素是"bcd"，则结果将是一个字符串数组，包含两个元素，"a"和"def"。  
  
## <a name="performance-considerations"></a>性能注意事项  
 <xref:System.String.Split%2A>方法返回的数组对象分配内存和<xref:System.String>每个数组元素的对象。 如果应用程序需要获得最佳性能，或者如果是在应用程序中关键的管理内存分配，请考虑使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，并选择性地<xref:System.String.Compare%2A>方法，以查找字符串中的子字符串。  
  
 如果你拆分处分隔符字符的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法以在字符串中定位的分隔符字符。 如果你拆分处分隔符字符串的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法查找分隔符字符串的第一个字符。 然后，使用<xref:System.String.Compare%2A>方法，以确定该第一个字符后的字符的分隔符字符串的剩余字符是否相等。  
  
 此外，如果一组相同的字符用于拆分字符串中存在多个<xref:System.String.Split%2A>方法调用，请考虑创建一个数组，并在每个方法调用中引用它。 这将显著减少每个方法调用的额外开销。  
  
   
  
## Examples  
 下面的示例演示返回通过调用一个字符串数组中的差异<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>方法替换其`options`参数等于<xref:System.StringSplitOptions.None?displayProperty=nameWithType>和<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 下面的示例定义了包含标点和空格字符的分隔符的一个数组。 传递的值以及此数组<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>到<xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>方法返回一个数组，其中包含从字符串的单个单词。  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 请注意，与调用方法`options`参数设置为<xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>。 这可以防止在返回的数组包括<xref:System.String.Empty?displayProperty=nameWithType>表示标点符号和空格字符之间的空的子字符串匹配项的值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]及更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法传递<paramref name="separator" />即<see langword="null" />或不包含任何字符，该方法使用略有不同的一组字符来拆分字符串比<see cref="M:System.String.Trim(System.Char[])" />方法执行到修整字符串。 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，这两种方法使用一组相同的 Unicode 空白字符。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="count">要返回的子字符串的最大数量。</param>
        <param name="options">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>基于数组中的字符将一个字符串拆分成最大数量的子字符串。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回数组的元素中不包括分隔符字符。  
  
 如果此实例不包含任何中的字符`separator`，或`count`参数为 1，返回的数组以包含此实例的单个元素组成。 如果`separator`参数是`null`不包含任何字符或空格字符被假定为分隔符。 由 Unicode 标准和返回定义的空白字符`true`如果将它们传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。 但是，如果`separator`对此方法的重载的调用中的参数是`null`，编译器重载解析失败。 若要明确地标识所调用的方法，您的代码必须指示为 null 的类型。 下面的示例显示了几种方法都会明确标识此重载。  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 如果`count`参数为零，或`options`参数是<xref:System.StringSplitOptions.RemoveEmptyEntries>和此实例的长度为零，则返回空数组。  
  
 每个元素`separator`定义单独的分隔符字符。 如果`options`参数是<xref:System.StringSplitOptions.None>，且它是相邻的两个分隔符或分隔符找到开头或结尾的此实例相对应的数组元素包含<xref:System.String.Empty>。  
  
 如果有多个`count`此实例中的子字符串第一个`count`减 1 的子字符串中返回第一个`count`减 1 个元素的返回值和此实例中的剩余字符返回的最后一个返回值的元素。  
  
 如果`count`大于数量的子字符串，则返回可用的子字符串并不会引发异常。  
  
## <a name="performance-considerations"></a>性能注意事项  
 <xref:System.String.Split%2A>方法返回的数组对象分配内存和<xref:System.String>每个数组元素的对象。 如果应用程序需要获得最佳性能，或者如果是在应用程序中关键的管理内存分配，请考虑使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，并选择性地<xref:System.String.Compare%2A>方法，以查找字符串中的子字符串。  
  
 如果你拆分处分隔符字符的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法以在字符串中定位的分隔符字符。 如果你拆分处分隔符字符串的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法查找分隔符字符串的第一个字符。 然后，使用<xref:System.String.Compare%2A>方法，以确定该第一个字符后的字符的分隔符字符串的剩余字符是否相等。  
  
 此外，如果一组相同的字符用于拆分字符串中存在多个<xref:System.String.Split%2A>方法调用，请考虑创建一个数组，并在每个方法调用中引用它。 这将显著减少每个方法调用的额外开销。  
  
   
  
## Examples  
 下面的示例使用<xref:System.StringSplitOptions>枚举来包括或排除子字符串由生成<xref:System.String.Split%2A>方法。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]及更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法传递<paramref name="separator" />即<see langword="null" />或不包含任何字符，该方法使用略有不同的一组字符来拆分字符串比<see cref="M:System.String.Trim(System.Char[])" />方法执行到修整字符串。 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，这两种方法使用一组相同的 Unicode 空白字符。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">分隔此字符串中子字符串的字符串数组、不包含分隔符的空数组或 <see langword="null" />。</param>
        <param name="count">要返回的子字符串的最大数量。</param>
        <param name="options">要省略返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />；要包含返回的数组中的空数组元素，则为 <see cref="F:System.StringSplitOptions.None" />。</param>
        <summary>基于数组中的字符串将一个字符串拆分成最大数量的子字符串。 可以指定子字符串是否包含空数组元素。</summary>
        <returns>一个数组，其元素包含此字符串中的子字符串，这些子字符串由 <paramref name="separator" /> 中的一个或多个字符串分隔。 有关详细信息，请参阅“备注”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>返回值的详细信息  
 返回数组的元素中不包括分隔符字符串。  
  
 如果此实例不包含任何中的字符串`separator`，或`count`参数为 1，返回的数组以包含此实例的单个元素组成。 如果`separator`参数是`null`不包含任何字符或空格字符被假定为分隔符。 由 Unicode 标准和返回定义的空白字符`true`如果将它们传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。 但是，如果`separator`对此方法的重载的调用中的参数是`null`，编译器重载解析失败。 若要明确地标识所调用的方法，您的代码必须指示的类型`null`。 下面的示例显示了几种方法都会明确标识此重载。  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 如果`count`参数为零，或`options`参数是<xref:System.StringSplitOptions.RemoveEmptyEntries>和此实例的长度为零，则返回空数组。  
  
 每个元素`separator`定义一个或多个字符组成的单独分隔符。 如果`options`参数是<xref:System.StringSplitOptions.None>，且它是相邻的两个分隔符或分隔符找到开头或结尾的此实例相对应的数组元素包含<xref:System.String.Empty>。  
  
 如果有多个`count`此实例中的子字符串第一个`count`减 1 的子字符串中返回第一个`count`减 1 个元素的返回值和此实例中的剩余字符返回的最后一个返回值的元素。  
  
 如果`count`大于数量的子字符串，则返回可用的子字符串并不会引发异常。  
  
## <a name="the-separator-array"></a>分隔符数组  
 如果中的元素的任何`separator`包含多个字符，将整个子字符串被视为分隔符。 例如，如果一个中的元素的`separator`为"10"，尝试进行拆分的字符串"This10is10a10string。" 返回此四个元素的数组: {"This"，"is"，"a"、"字符串。 }.  
  
## <a name="comparison-details"></a>比较详细信息  
 <xref:System.String.Split%2A>方法将提取由一个或多个字符串中分隔此字符串中的子字符串`separator`参数，并将这些子字符串作为数组的元素返回。  
  
 <xref:System.String.Split%2A>方法执行比较使用区分大小写的序号排序规则查找分隔符。 有关 word、 字符串和顺序排序的详细信息，请参阅<xref:System.Globalization.CompareOptions?displayProperty=nameWithType>枚举。  
  
 <xref:System.String.Split%2A>方法将忽略的任何元素`separator`其值是`null`或空字符串 ("")。  
  
 若要避免不明确的结果时中字符串`separator`具有公共，字符<xref:System.String.Split%2A>方法继续从开始到的实例的值的末尾，并与匹配的第一个元素`separator`，它等于中分隔符实例。 在其中子字符串的实例中出现的顺序的优先级高于中元素的顺序`separator`。  
  
 例如，考虑一个其值是"abcdef"的实例。 如果中的第一个元素`separator`是"ef"，且第二个元素为"bcde"，该拆分操作的结果将是"a"和"f"。 这是因为在实例中，"bcde"的子字符串中遇到和中的元素匹配`separator`遇到"f"的子字符串之前。  
  
 但是，如果第一个元素的`separator`为"bcd"和第二个元素为"bc"，该拆分操作的结果将是"a"和"ef"。 这是因为"bcd"中的第一个分隔符`separator`相匹配的实例中的分隔符。 如果分隔符的顺序已撤消，因此第一个元素是"bc"，并且第二个元素是"bcd"，则结果将是"a"和"def"。  
  
## <a name="performance-considerations"></a>性能注意事项  
 <xref:System.String.Split%2A>方法返回的数组对象分配内存和<xref:System.String>每个数组元素的对象。 如果应用程序需要获得最佳性能，或者如果是在应用程序中关键的管理内存分配，请考虑使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法，并选择性地<xref:System.String.Compare%2A>方法，以查找字符串中的子字符串。  
  
 如果你拆分处分隔符字符的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法以在字符串中定位的分隔符字符。 如果你拆分处分隔符字符串的字符串，使用<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOfAny%2A>方法查找分隔符字符串的第一个字符。 然后，使用<xref:System.String.Compare%2A>方法，以确定该第一个字符后的字符的分隔符字符串的剩余字符是否相等。  
  
 此外，如果一组相同的字符用于拆分字符串中存在多个<xref:System.String.Split%2A>方法调用，请考虑创建一个数组，并在每个方法调用中引用它。 这将显著减少每个方法调用的额外开销。  
  
   
  
## Examples  
 下面的示例使用<xref:System.StringSplitOptions>枚举来包括或排除子字符串由生成<xref:System.String.Split%2A>方法。  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是 <see cref="T:System.StringSplitOptions" /> 值之一。</exception>
        <block subset="none" type="usage">
          <para>中[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]及更早版本，如果<see cref="M:System.String.Split(System.Char[])" />方法传递<paramref name="separator" />即<see langword="null" />或不包含任何字符，该方法使用略有不同的一组字符来拆分字符串比<see cref="M:System.String.Trim(System.Char[])" />方法执行到修整字符串。 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，这两种方法使用一组相同的 Unicode 空白字符。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定此字符串实例的开头是否与指定的字符串匹配。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符串。</param>
        <summary>确定此字符串实例的开头是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法比较`value`是相同的长度与此实例的开头处的子字符串到`value`，并返回指示它们是否相等。 若要对等，`value`必须为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必须是对此相同的实例的引用，或者必须与此实例的开头匹配。  
  
 此方法执行使用当前区域性的单词 （区分大小写和区分区域性） 比较。  
  
   
  
## Examples  
 下面的示例定义`StripStartTags`方法，它使用<xref:System.String.StartsWith%28System.String%29>方法中删除 HTML 开始标记从字符串的开头。 请注意，`StripStartTags`方法称为递归，请确保删除在行开头的多个 HTML 开始标记。 该示例不会删除在字符串中嵌入的 HTML 标记。  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用将替换默认值，而是调用需要显式指定参数的方法的字符串比较方法。 若要确定是否字符串开头的特定子字符串使用当前区域性的字符串比较规则，请调用<see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />方法的值的重载<see cref="F:System.StringComparison.CurrentCulture" />有关其<paramref name="comparisonType" />参数。</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符串。</param>
        <param name="comparisonType">枚举值之一，用于确定如何比较此字符串与 <c>value</c>。</param>
        <summary>确定在使用指定的比较选项进行比较时此字符串实例的开头是否与指定的字符串匹配。</summary>
        <returns>如果此实例以 <see langword="true" /> 开头，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.StartsWith%2A>方法比较`value`此字符串的开头处的子字符串的参数，并返回一个值，指示它们是否相等。 若要对等，`value`必须为对此相同的字符串的引用，必须为空字符串 ("")，或必须与此字符串的开头匹配。 执行比较的类型<xref:System.String.StartsWith%2A>方法的值取决于`comparisonType`参数。 比较可以使用当前区域性的约定 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>并<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) 或固定区域性 (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>并<xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>)，也可以包含的字符对字符的码位比较 (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>或<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). 此外可以区分大小写比较 (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>，或<xref:System.StringComparison.Ordinal?displayProperty=nameWithType>)，或它可以忽略大小写 (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>， <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>)。  
  
   
  
## Examples  
 下面的示例搜索字符串"the"开头的词较长字符串的开头"The"。 如示例所示，对的调用中的输出<xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>执行不区分区域性的但区分大小写比较的方法来匹配的字符串，而执行区域性-和写的 insensitive 比较的调用与字符串匹配将失败。  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 下面的示例确定字符串是否以特定子字符串开头。 它将初始化二维字符串数组。 第二个维度中的第一个元素包含一个字符串，并且第二个元素包含要搜索的第一个字符串开头的字符串。 区域性，是否忽略大小写，和是否执行序号比较的选择会影响结果。 请注意，当字符串实例中包含连字，具有连续的字符的区分区域性的比较成功匹配。  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是 <see cref="T:System.StringComparison" /> 值。</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">要比较的字符串。</param>
        <param name="ignoreCase">若要在比较过程中忽略大小写，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="culture">确定如何对此字符串与 <c>value</c> 进行比较的区域性信息。 如果 <c>culture</c> 为 <see langword="null" />，则使用当前区域性。</param>
        <summary>确定在使用指定的区域性进行比较时此字符串实例的开头是否与指定的字符串匹配。</summary>
        <returns>如果 <see langword="true" /> 参数与此字符串的开头匹配，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法比较`value`参数是相同的长度与此字符串的开头处的子字符串`value`，并返回一个值，指示它们是否相等。 若要对等，`value`必须为空字符串 (<xref:System.String.Empty?displayProperty=nameWithType>)，必须是对此相同的实例的引用，或者必须与此实例的开头匹配。  
  
 此方法执行使用指定的大小写和区域性的比较。  
  
   
  
## Examples  
 下面的示例确定字符串是否出现在另一个字符串的开头。 <xref:System.String.StartsWith%2A>使用区分大小写，不区分大小写和影响搜索结果的不同区域性的多次调用方法。  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此实例检索子字符串。  
  
重载此成员。 有关此成员的完整信息（包括语法、用法和示例），请单击重载列表中的相应名称。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例中子字符串的起始字符位置（从零开始）。</param>
        <summary>从此实例检索子字符串。 子字符串在指定的字符位置开始并一直到该字符串的末尾。</summary>
        <returns>与此实例中在 <paramref name="startIndex" /> 处开头的子字符串等效的一个字符串；如果 <see cref="F:System.String.Empty" /> 等于此实例的长度，则为 <paramref name="startIndex" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.String.Substring%28System.Int32%29>方法以从指定的字符位置开始，字符串的结尾结束的字符串中提取子字符串。 起始字符位置是一个从零开始;换而言之，在字符串中的第一个字符位于索引 0，不索引 1。 若要提取的子字符串，在指定的字符位置开始和结束的字符串的结束之前，调用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新字符串，开始于`startIndex`当前字符串中的位置。  
  
 若要提取特定的字符或字符序列开头的子字符串，请如调用方法<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>若要获取的值`startIndex`。 第二个示例阐释了这一点;它将提取一个字符位置开始后的"="字符的密钥值。  
  
 如果`startIndex`等于零，该方法返回的原始字符串保持不变。  
   
  
## Examples  
 下面的示例演示如何获取从字符串的子字符串。  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 下面的示例使用<xref:System.String.Substring%2A>方法来分隔由等号分隔的键/值对 （"="） 字符。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A>方法用于获取等字符的字符串中的位置。 在调用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法将提取的键的名称，从字符串中的第一个字符开始，并扩展到调用所返回的字符数为<xref:System.String.IndexOf%2A>方法。 对调用<xref:System.String.Substring%28System.Int32%29>方法然后提取分配给键的值。 它等于字符之外的一个字符位置开始，并将扩展到字符串的末尾。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 小于零或大于此实例的长度。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例中子字符串的起始字符位置（从零开始）。</param>
        <param name="length">子字符串中的字符数。</param>
        <summary>从此实例检索子字符串。 子字符串从指定的字符位置开始且具有指定的长度。</summary>
        <returns>与此实例中在 <paramref name="length" /> 处开头、长度为 <paramref name="startIndex" /> 的子字符串等效的一个字符串；如果 <see cref="F:System.String.Empty" /> 等于此实例的长度且 <paramref name="startIndex" /> 为零，则为 <paramref name="length" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法以从在指定的字符位置开始和结束之前字符串的末尾的字符串中提取子字符串。 起始字符位置是一个从零开始;换而言之，在字符串中的第一个字符位于索引 0，不索引 1。 若要提取的子字符串，则从指定的字符位置开始并持续到字符串的末尾，调用<xref:System.String.Substring%28System.Int32%29>方法。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回的新字符串`length`字符从开始`startIndex`当前字符串中的位置。  
  
 `length`参数表示要从当前字符串实例中提取的字符总数。 这包括的起始字符索引处找到`startIndex`。  换而言之，<xref:System.String.Substring%2A>方法尝试从索引中提取字符`startIndex`到索引`startIndex`  +  `length` -1。  
  
 若要提取特定的字符或字符序列开头的子字符串，请如调用方法<xref:System.String.IndexOf%2A>或<xref:System.String.LastIndexOf%2A>若要获取的值`startIndex`。  
  
 如果从子字符串延伸`startIndex`到指定的字符序列，您可以调用一个方法如<xref:System.String.IndexOf%2A>或<xref:System.String.LastIndexOf%2A>要获取的字符序列的结束字符的索引。  你可以然后将该值转换到字符串中的索引位置，如下所示：  
  
-   如果已搜索的单个字符的标记的子字符串的结尾`length`参数等于`endIndex`  -  `startIndex` + 1，其中`endIndex`是返回的值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。 下面的示例从字符串提取"b"字符的连续块。  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   如果已搜索的多个字符来标记的子字符串的结尾`length`参数等于`endIndex`  +  `endMatchLength`  -  `startIndex`，其中`endIndex`的返回值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。 和`endMatchLength`标记的子字符串的末尾的字符序列的长度。 下面的示例提取包含 XML 的文本块`<definition>`元素。  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   如果字符或字符序列不包含子字符串内，最后`length`参数等于`endIndex`  -  `startIndex`，其中`endIndex`是返回的值<xref:System.String.IndexOf%2A>或<xref:System.String.IndexOf%2A>方法。  
  
 如果`startIndex`是等于零且等于当前的字符串，该方法的长度返回未更改的原始字符串。  
  
   
  
## Examples  
 下面的示例阐释如何简单调用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法从字符串的第六个字符位置开始提取两个字符 （即，在索引 5）。  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 下面的示例使用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>来隔离在字符串内的子字符串的以下三个用例中的方法。 在两种情况下使用子字符串在比较中，并指定无效的参数是因为在第三种情况下引发异常。  
  
-   它提取单个字符和 （索引 2） 处的字符串中的第三个位置，并将其与"c"。 此比较将返回`true`。  
  
-   它提取零个字符 （位于索引 3） 在字符串中的第四个位置开始，并将其传递给<xref:System.String.IsNullOrEmpty%2A>方法。 这返回 true，因为在调用<xref:System.String.Substring%2A>方法将返回<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它会尝试提取一个字符在字符串中的第四个位置开始。 由于该位置没有字符，方法调用将引发<xref:System.ArgumentOutOfRangeException>异常。  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 下面的示例使用<xref:System.String.Substring%2A>方法来分隔由等号分隔的键/值对 （"="） 字符。  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <xref:System.String.IndexOf%2A>方法用于获取等字符的字符串中的位置。 在调用<xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>方法将提取的键的名称，从字符串中的第一个字符开始，并扩展到调用所返回的字符数为<xref:System.String.IndexOf%2A>方法。 对调用<xref:System.String.Substring%28System.Int32%29>方法然后提取分配给键的值。 它等于字符之外的一个字符位置开始，并将扩展到字符串的末尾。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 加 <paramref name="length" /> 指示不在此实例内的位置。  
  
或 
 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问当前 <see cref="T:System.String" /> 对象的枚举数。</summary>
        <returns>可用于循环访问当前 <see cref="T:System.String" /> 对象的强类型化枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 可以使用它时，才<xref:System.String>实例转换为<xref:System.Collections.Generic.IEnumerable%601>接口对象。 有关更多信息，请参见 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问当前 <see cref="T:System.String" /> 对象的枚举数。</summary>
        <returns>一个枚举器，可用于循环访问当前的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.Collections.IEnumerable> 接口时使用。 有关更多信息，请参见 <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果当前字符串的值为 <see langword="true" />，则为 <see cref="F:System.Boolean.TrueString" />；如果当前字符串的值为 <see langword="false" />，则为 <see cref="F:System.Boolean.FalseString" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">当前字符串的值不是 <see cref="F:System.Boolean.TrueString" /> 或 <see cref="F:System.Boolean.FalseString" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是大于 <see cref="F:System.Byte.MaxValue" /> 或小于 <see cref="F:System.Byte.MinValue" /> 的数。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象中索引 0 处的字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是小于 <see cref="F:System.Decimal.MinValue" /> 或大于 <see cref="F:System.Decimal.MaxValue" /> 的数。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是小于 <see cref="F:System.Double.MinValue" /> 或大于 <see cref="F:System.Double.MaxValue" /> 的数。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是大于 <see cref="F:System.Int16.MaxValue" /> 或小于 <see cref="F:System.Int16.MinValue" /> 的数。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是大于 <see cref="F:System.SByte.MaxValue" /> 或小于 <see cref="F:System.SByte.MinValue" /> 的数。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">返回对象的类型。</param>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ChangeType%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">无法将当前 <see cref="T:System.String" /> 对象的值转换为由 <paramref name="type" /> 参数指定的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是大于 <see cref="F:System.UInt16.MaxValue" /> 或小于 <see cref="F:System.UInt16.MinValue" /> 的数。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">无法分析当前 <see cref="T:System.String" /> 对象的值。</exception>
        <exception cref="T:System.OverflowException">当前 <see cref="T:System.String" /> 对象的值是大于 <see cref="F:System.UInt32.MaxValue" /> 或小于 <see cref="F:System.UInt32.MinValue" /> 的数</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，提供区域性特定的格式设置信息。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>当前 <see cref="T:System.String" /> 对象的转换值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.String> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例中的字符复制到 Unicode 字符数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例中的字符复制到 Unicode 字符数组。</summary>
        <returns>元素为此实例的各字符的 Unicode 字符数组。 如果此实例是空字符串，则返回的数组为空且长度为零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会复制每个字符 (即，每个<xref:System.Char>对象) 中的字符数组的字符串。 复制的第一个字符位于索引零开始的返回的字符数组中;复制的最后一个字符位于索引<xref:System.Array.Length%2A?displayProperty=nameWithType>– 1。  
  
 若要创建从字符数组中的字符的字符串，调用<xref:System.String.%23ctor%28System.Char%5B%5D%29>构造函数。  
  
 若要创建包含已编码的字符在字符串中的字节数组，请实例化相应<xref:System.Text.Encoding>对象，并调用其<xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType>方法。 在.NET 中可用的标准编码的一些因素包括：  
  
|编码|对象|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 有关详细信息，请参阅[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)。  
  
   
  
## Examples  
 下面的示例调用<xref:System.String.ToCharArray%2A>方法提取到字符数组的字符串中的字符。 它然后数组中显示的原始字符串和元素。  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 下面的示例定义一个包含作为带分隔符的字符串中的分隔符的字符的字符串。 然后，它调用<xref:System.String.ToCharArray%2A>方法来创建字符数组，可传递给<xref:System.String.Split%28System.Char%5B%5D%29>方法要将带分隔符的字符串拆分为其单独的子字符串。  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例内子字符串的起始位置。</param>
        <param name="length">此实例内子字符串的长度。</param>
        <summary>将此实例中的指定子字符串内的字符复制到 Unicode 字符数组。</summary>
        <returns>元素为此实例中从字符位置 <paramref name="length" /> 开始的 <paramref name="startIndex" /> 字符数的 Unicode 字符数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将字符串的部分中的字符复制到字符数组。 若要创建从一系列字符数组中字符的字符串，调用<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>构造函数。  
  
 `startIndex`参数是从零开始。 也就是说，在字符串实例中的第一个字符的索引为零。  
  
 如果`length`为零，则返回的数组为空并且具有长度为零。 如果此实例是`null`或空字符串 ("")，则返回的数组为空并且具有长度为零。  
  
 若要创建包含已编码的字符在字符串的一部分的字节数组，请实例化相应<xref:System.Text.Encoding>对象，并调用其<xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>方法。 在.NET 中可用的标准编码包括：  
  
|编码|对象|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 有关详细信息，请参阅[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)。  
  
   
  
## Examples  
 下面的示例将字符串中的子字符串转换为数组的字符，然后枚举并显示数组的元素。  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 加上 <paramref name="length" /> 大于此实例的长度。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此字符串转换为小写形式的副本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此字符串转换为小写形式的副本。</summary>
        <returns>一个小写字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会考虑当前区域性的大小写规则。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串，其中当前实例中的所有字符都转换为小写。  
  
## <a name="security-considerations"></a>安全注意事项  
 调用结果的大小写操作<xref:System.String.ToLower>方法会考虑当前区域性的大小写约定。 如果需要小写或大写版本的操作系统标识符，如文件的名称、 命名管道或注册表项，请使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 这将产生在每个区域性相同的结果 (不同于<xref:System.String.ToLower>方法)，并更有效地执行。  
  
   
  
## Examples  
 下面的示例将多个混合大小写的字符串转换为小写。  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用字符串的大小写的方法替换为默认值改为调用需要显式指定参数的方法。 若要将字符转换为小写的通过使用当前区域性的大小写约定，调用<see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />方法的值的重载<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />有关其<paramref name="culture" />参数。</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">一个对象，用于提供区域性特定的大小写规则。</param>
        <summary>根据指定区域性的大小写规则返回此字符串转换为小写形式的副本。</summary>
        <returns>当前字符串的等效小写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的区域性的大小写规则`culture`参数确定更改字符串的大小写的方法。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串，其中当前实例中的所有字符都转换为小写。  
  
## <a name="security-considerations"></a>安全注意事项  
 如果传递<xref:System.String.ToLower%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>对象而不<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小写操作将考虑特定于区域性的规则。 如果需要小写或大写版本的操作系统标识符，如文件的名称、 命名管道或注册表项，请使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 此生成中每个区域性相同的结果，并更有效地执行。  
  
   
  
## Examples  
 下面的示例将转换为小写字符使用英语-美国和土耳其语-土耳其语区域性的大写字符组成的两个字符串，然后比较小写字符串。 大写的字符串完全相同，只不过 Unicode LATIN CAPITAL LETTER 我在一个字符串中每个匹配项，另一个字符串包含 LATIN CAPITAL LETTER I 使用圆点上方。  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.String" /> 对象的转换为小写形式的副本，返回时使用固定区域性的大小写规则。</summary>
        <returns>当前字符串的等效小写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 固定的区域性表示是不区分区域性的区域性。 相关联的英语语言但不是与特定国家或地区。 有关更多信息，请参见 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。  
  
 如果你的应用程序依赖于不受当前区域性使用的可预测方式更改字符串的大小写<xref:System.String.ToLowerInvariant%2A>方法。 <xref:System.String.ToLowerInvariant%2A>方法等效于`ToLower(CultureInfo.InvariantCulture)`。 一个字符串集合必须在用户界面控件中可预测的顺序出现时，建议的方法。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串，其中当前实例中的所有字符都转换为小写。  
  
## <a name="security-considerations"></a>安全注意事项  
 如果需要小写或大写版本的操作系统标识符，如文件的名称、 命名管道或注册表项，请使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。  
  
   
  
## Examples  
 下面的示例定义一个字符串数组，包含了多种语言版本中使用的单个字符。 <xref:System.String.ToLowerInvariant%2A>方法用于填充每个单词的不区分大小写版本的并行数组元素。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用于区分大小写数组基于小写的数组，以确保元素出现在与语言无关的相同顺序中的元素的顺序排序。  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值转换为 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.String" /> 的此实例；不执行实际转换。</summary>
        <returns>当前的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅返回未更改的当前字符串，因为没有无需直接调用。 它通常称为隐式中的复合格式设置操作，如示例所示。  
  
   
  
## Examples  
 下面的示例演示<xref:System.String.ToString%2A>方法。请注意，该示例不显式调用<xref:System.String.ToString%2A>方法。 相反，该方法会隐式调用[复合格式设置](~/docs/standard/base-types/composite-formatting.md)功能。  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">（保留）一个对象，用于提供区域性特定的格式设置信息。</param>
        <summary>返回 <see cref="T:System.String" /> 的此实例；不执行实际转换。</summary>
        <returns>当前的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` 保留，并且当前不参与此操作。  
  
 此方法仅返回未更改的当前字符串，因为没有无需直接调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此字符串转换为大写形式的副本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此字符串转换为大写形式的副本。</summary>
        <returns>当前字符串的大写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用当前区域性的大小写规则以将当前实例中的每个字符转换为其大写等效项。 如果字符没有大写等效项，则包含返回的字符串中保持不变。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串，其中当前实例中的所有字符都转换为大写。  
  
 <xref:System.String.ToUpper%2A>方法通常用于将字符串转换为大写形式，以便可以在不区分大小写比较中使用它。 若要执行不区分大小写比较的更好方法是调用具有的字符串比较方法<xref:System.StringComparison>参数的值设置为<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>进行区分区域性的、 不区分大小写的比较。  
  
## <a name="security-considerations"></a>安全注意事项  
 调用结果的大小写操作<xref:System.String.ToUpper>方法会考虑当前区域性的大小写约定。 如果需要小写或大写版本的操作系统标识符，如文件的名称、 命名管道或注册表项，请使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 这将产生在每个区域性相同的结果 (不同于<xref:System.String.ToUpper>方法)，并更有效地执行。  
  
   
  
## Examples  
 下面的示例调用<xref:System.String.ToUpper%2A>方法将一系列包含基本拉丁语、 拉丁语 1 补充和拉丁语扩充-A 在字符集中的每个字符的单字符字符串。 然后，显示每个字符串的大写字符为不同于它的小写字符。  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>中所述[字符串使用最佳做法](~/docs/standard/base-types/best-practices-strings.md)，我们建议你避免调用字符串的大小写的方法替换为默认值改为调用需要显式指定参数的方法。 若要将转换要使用当前区域性的大小写约定大写的字符串，请调用<see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />方法的值的重载<see cref="P:System.Globalization.CultureInfo.CurrentCulture" />有关其<paramref name="culture" />参数。</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">一个对象，用于提供区域性特定的大小写规则。</param>
        <summary>根据指定区域性的大小写规则返回此字符串转换为大写形式的副本。</summary>
        <returns>当前字符串的大写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的区域性的大小写规则`culture`参数确定的方式的字符串大小写更改。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串，其中当前实例中的所有字符都转换为大写。  
  
## <a name="security-considerations"></a>安全注意事项  
 如果传递<xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>方法<xref:System.Globalization.CultureInfo>对象而不<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，大小写操作将考虑特定于区域性的规则。 如果需要小写或大写版本的操作系统标识符，如文件的名称、 命名管道或注册表项，请使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。 此生成中每个区域性相同的结果，并更有效地执行。  
  
   
  
## Examples  
 以下示例将小写字符的字符串转换为使用英语-美国和土耳其语-土耳其语区域性的大写字符组成的两个字符串，然后对大写的字符串进行比较。 大写的字符串完全相同，只不过 Unicode LATIN CAPITAL LETTER 我在一个字符串中每个匹配项，另一个字符串包含 LATIN CAPITAL LETTER I 使用圆点上方。  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.String" /> 对象的转换为大写形式的副本，返回时使用固定区域性的大小写规则。</summary>
        <returns>当前字符串的大写形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 固定的区域性表示是不区分区域性的区域性。 相关联的英语语言但不是与特定国家或地区。 有关更多信息，请参见 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。  
  
 如果你的应用程序依赖于不受当前区域性使用的可预测方式更改字符串的大小写<xref:System.String.ToUpperInvariant%2A>方法。 <xref:System.String.ToUpperInvariant%2A>方法等效于`ToUpper(CultureInfo.InvariantCulture)`。 一个字符串集合必须在用户界面控件中可预测的顺序出现时，建议的方法。  
  
> [!NOTE]
>  此方法不修改的当前实例的值。 相反，它返回一个新的字符串，其中当前实例中的所有字符都转换为大写。  
  
## <a name="security-considerations"></a>安全注意事项  
 如果需要小写或大写版本的操作系统标识符，如文件的名称、 命名管道或注册表项，请使用<xref:System.String.ToLowerInvariant%2A>或<xref:System.String.ToUpperInvariant%2A>方法。  
  
   
  
## Examples  
 下面的示例定义一个字符串数组，包含了多种语言版本中使用的单个字符。 <xref:System.String.ToUpperInvariant%2A>方法用于填充每个单词的不区分大小写版本的并行数组元素。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法用于区分大小写数组基于大写的数组，以确保元素出现在与语言无关的相同顺序中的元素的顺序排序。  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个新字符串，它相当于从当前 <see cref="T:System.String" /> 对象中移除了一组指定字符的所有前导匹配项和尾随匹配项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前 <see cref="T:System.String" /> 对象移除所有前导空白字符和尾部空白字符。</summary>
        <returns>从当前字符串的开头和结尾删除所有空白字符后剩余的字符串。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A>方法从字符串中移除当前所有前导和尾随空白字符。 在遇到非空白字符后停止每个前导和尾随的剪裁操作。 例如，如果当前字符串"abc xyz"<xref:System.String.Trim%2A>方法将返回"abc xyz"。 若要删除字符串中的单词之间的空白字符，请使用[.NET 正则表达式](~/docs/standard/base-types/regular-expressions.md)。  
  
> [!NOTE]
>  如果<xref:System.String.Trim%2A>方法从当前实例中删除的任何字符，此方法不会修改当前实例的值。 相反，它返回已找到的当前实例中的所有前导和尾随空白字符的新字符串。  
  
 如果当前字符串等于<xref:System.String.Empty>或当前实例中的所有字符由空白字符都组成，该方法返回<xref:System.String.Empty>。  
  
 由 Unicode 标准定义的空白字符。 <xref:System.String.Trim>方法中删除生成返回值的任何前导和尾随字符`true`时传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.Trim?displayProperty=nameWithType>方法以从之前将它们连用户输入的字符串中删除任何多余的空白区域。  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本维护此方法修整的空白字符的内部列表。 从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，该方法裁剪掉所有 Unicode 空白字符 (字符生成<see langword="true" />返回值时传递给<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 由于此更改，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中删除两个字符，零宽度的空格 (U + 200B) 和零宽度无中断空格 (U + FEFF) 的<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以及更高版本不是删除。 此外，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本不会修整三个 Unicode 空白字符： 蒙古文元音标记分隔符 (U + 180E)、 窄无中断空格 (U + 202F) 和中等数学空间 (U + 205F)。</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要删除的 Unicode 字符的数组，或 <see langword="null" />。</param>
        <summary>从当前 <see cref="T:System.String" /> 对象移除数组中指定的一组字符的所有前导匹配项和尾部匹配项。</summary>
        <returns>从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。 如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为移除空白字符。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Trim%2A>方法删除从当前字符串中的所有前导和尾随字符`trimChars`参数。 每个前导空格和尾随剪裁操作将会停止时不在的字符`trimChars`遇到。 例如，如果当前字符串为"123abc456xyz789"和`trimChars`包含从"1"至"9"的数字<xref:System.String.Trim%2A>方法返回"abc456xyz"。  
  
> [!NOTE]
>  如果<xref:System.String.Trim%2A>方法从当前实例中删除的任何字符，此方法不会修改当前实例的值。 相反，它返回一个新字符串，其中所有前导空格和尾随`trimChars`删除当前实例中找到的字符。  
  
 如果当前字符串等于<xref:System.String.Empty>或当前实例中的所有字符中的字符都组成`trimChars`数组，该方法将返回<xref:System.String.Empty>。  
  
 如果`trimChars`是`null`或空数组，此方法删除导致方法返回任何前导或尾随字符`true`时传递给<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>方法，  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType>方法从字符串中删除空间、 星号 （*） 和撇号 （'） 字符。  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护此方法修整如果的空白字符的内部列表<paramref name="trimChars" />是<see langword="null" />或空数组。 从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空数组，该方法将修整所有 Unicode 空白字符 (字符生成<see langword="true" />返回值时传递给<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 由于此更改，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中删除两个字符，零宽度的空格 (U + 200B) 和零宽度无中断空格 (U + FEFF) 的<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以及更高版本不是删除。 此外，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本不会修整三个 Unicode 空白字符： 蒙古文元音标记分隔符 (U + 180E)、 窄无中断空格 (U + 202F) 和中等数学空间 (U + 205F)。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要删除的 Unicode 字符的数组，或 <see langword="null" />。</param>
        <summary>从当前 <see cref="T:System.String" /> 对象移除数组中指定的一组字符的所有尾部匹配项。</summary>
        <returns>从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。 如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为删除 Unicode 空白字符。 如果从当前实例无法删除字符，此方法返回未更改的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimEnd%2A>方法删除从当前字符串中的所有尾随字符`trimChars`参数。 剪裁操作停止时的第一个字符不在`trimChars`遇到字符串的末尾。 例如，如果当前字符串为"123abc456xyz789"和`trimChars`包含从"1"至"9"的数字<xref:System.String.TrimEnd%2A>方法返回"123abc456xyz"。  
  
> [!NOTE]
>  如果<xref:System.String.TrimEnd%2A>方法从当前实例中删除的任何字符，此方法不会修改当前实例的值。 相反，它返回一个新的字符串中找到的所有尾随字符中`trimChars`从当前字符串中删除。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.String.TrimEnd%28System.Char%5B%5D%29>方法，以修整空格或标点符号的字符串的末尾。  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护此方法修整如果的空白字符的内部列表<paramref name="trimChars" />是<see langword="null" />或空数组。 从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空数组，该方法将修整所有 Unicode 空白字符 (字符生成<see langword="true" />返回值时传递给<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 由于此更改，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中删除两个字符，零宽度的空格 (U + 200B) 和零宽度无中断空格 (U + FEFF) 的<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以及更高版本不是删除。 此外，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本不会修整三个 Unicode 空白字符： 蒙古文元音标记分隔符 (U + 180E)、 窄无中断空格 (U + 202F) 和中等数学空间 (U + 205F)。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">要删除的 Unicode 字符的数组，或 <see langword="null" />。</param>
        <summary>从当前 <see cref="T:System.String" /> 对象移除数组中指定的一组字符的所有前导匹配项。</summary>
        <returns>从当前字符串的开头移除所出现的所有 <paramref name="trimChars" /> 参数中的字符后剩余的字符串。 如果 <paramref name="trimChars" /> 为 <see langword="null" /> 或空数组，则改为移除空白字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.TrimStart%2A>方法删除从当前字符串中的所有前导字符`trimChars`参数。 剪裁操作时不在一个字符停止`trimChars`遇到。 例如，如果当前字符串为"123abc456xyz789"和`trimChars`包含从"1"至"9"的数字<xref:System.String.TrimStart%2A>方法返回"abc456xyz789"。  
  
> [!NOTE]
>  如果<xref:System.String.TrimStart%2A>方法从当前实例中删除的任何字符，此方法不会修改当前实例的值。 相反，它返回已找到的当前实例中的所有前导空白字符的新字符串。  
  
   
  
## Examples  
 下面的示例使用<xref:System.String.TrimStart%2A>方法，以修整空格和行的源代码中注释字符。 `StripComments`方法包装对的调用<xref:System.String.TrimStart%2A>并将其传递 Visual Basic 和 C# 中的以斜杠 （/） 中包含一个空格和撇号 （'） 的注释字符的字符数组。 <xref:System.String.TrimStart%2A>方法也称为计算字符串是否为注释时删除前导空格。  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 下面的示例因而演示 `StripComments` 方法的调用。  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本维护此方法修整如果的空白字符的内部列表<paramref name="trimChars" />是<see langword="null" />或空数组。 从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，如果<paramref name="trimChars" />是<see langword="null" />或空数组，该方法将修整所有 Unicode 空白字符 (字符生成<see langword="true" />返回值时传递给<see cref="M:System.Char.IsWhiteSpace(System.Char)" />方法)。 由于此更改，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和更早版本中删除两个字符，零宽度的空格 (U + 200B) 和零宽度无中断空格 (U + FEFF) 的<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以及更高版本不是删除。 此外，<see cref="M:System.String.Trim" />中的方法[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]和早期版本不会修整三个 Unicode 空白字符： 蒙古文元音标记分隔符 (U + 180E)、 窄无中断空格 (U + 202F) 和中等数学空间 (U + 205F)。</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>