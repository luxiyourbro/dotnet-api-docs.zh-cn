<Type Name="TimeZoneInfo" FullName="System.TimeZoneInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="71dbea1a307dc50a2dc5a792cbb440bdb886c164" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39809866" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TimeZoneInfo : IEquatable&lt;TimeZoneInfo&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit TimeZoneInfo extends System.Object implements class System.IEquatable`1&lt;class System.TimeZoneInfo&gt;, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.TimeZoneInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TimeZoneInfo&#xA;Implements IDeserializationCallback, IEquatable(Of TimeZoneInfo), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TimeZoneInfo sealed : IEquatable&lt;TimeZoneInfo ^&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type TimeZoneInfo = class&#xA;    interface IEquatable&lt;TimeZoneInfo&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.TimeZoneInfo&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=2.0.5.0, Culture=Neutral, PublicKeyToken=7cec85d7bea7798e")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示世界上的任何时区。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 时区指使用相同时间的某个地理区域。  
  
 <xref:System.TimeZoneInfo>类提供了重要的增强功能，通过<xref:System.TimeZone>类，该类提供有限的功能。  
  
 <xref:System.TimeZone>类识别仅本地时区，并可以将协调世界时 (UTC) 和当地时间之间的时间转换。 一个<xref:System.TimeZoneInfo>对象可以表示任何时区，以及方法<xref:System.TimeZoneInfo>类可用于将一个时区的时间转换为其他时区中相应的时间。 成员<xref:System.TimeZoneInfo>类支持以下操作：  
  
-   正在检索已由操作系统定义的时区。  
  
-   枚举可用的系统的时区。  
  
-   转换不同时区之间的时间。  
  
-   创建新的时区不由操作系统已定义的。  
  
-   序列化时区，以供将来检索。  
  
> [!NOTE]
>  实例<xref:System.TimeZoneInfo>类是不可变。 一旦已实例化一个对象，不能修改其值。  
  
 无法实例化<xref:System.TimeZoneInfo>对象使用`new`关键字。 相反，您必须调用的静态成员之一<xref:System.TimeZoneInfo>下表中所示的类。  
  
|静态成员名称|描述|  
|------------------------|-----------------|  
|<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A> 方法|从应用程序提供的数据创建自定义时区。|  
|<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A> 方法|实例化基于区域的标识符在系统注册表中定义的时区。|  
|<xref:System.TimeZoneInfo.FromSerializedString%2A> 方法|反序列化要重新创建以前序列化的字符串值<xref:System.TimeZoneInfo>对象。|  
|<xref:System.TimeZoneInfo.GetSystemTimeZones%2A> 方法|返回可枚举<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>的<xref:System.TimeZoneInfo>对象，表示所有本地系统上可用的时区。|  
|<xref:System.TimeZoneInfo.Local%2A> 属性|实例化<xref:System.TimeZoneInfo>对象，表示本地时区。|  
|<xref:System.TimeZoneInfo.Utc%2A> 属性|实例化<xref:System.TimeZoneInfo>对象，表示 UTC 时区。|  
  
 可以使用<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法来创建未在本地系统注册表中定义的时区。 然后，可以使用<xref:System.TimeZoneInfo.ToSerializedString%2A>属性将时区对象的信息另存为可以存储在应用程序可以访问某种形式的字符串。 可以使用<xref:System.TimeZoneInfo.FromSerializedString%2A>方法将序列化的字符串转换回<xref:System.TimeZoneInfo>对象。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseUtcOffset">
      <MemberSignature Language="C#" Value="public TimeSpan BaseUtcOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan BaseUtcOffset" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.BaseUtcOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseUtcOffset As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan BaseUtcOffset { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseUtcOffset : TimeSpan" Usage="System.TimeZoneInfo.BaseUtcOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前时区的标准时间与协调世界时 (UTC) 之间的时差。</summary>
        <value>一个对象，它指示当前时区的标准时间与协调世界时 (UTC) 之间的时差。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的时间跨度<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性介于 14 小时 （14 小时领先于协调世界时 (UTC) 的时区） 到 （适用于为 14 小时 utc 时区）-14 小时。 早于 utc 时间的时区具有负的偏移量;位于 UTC 时区具有负偏移量。  
  
 <xref:System.TimeZoneInfo.BaseUtcOffset%2A>值表示为整分钟数。 它不能包含小数分钟数。  
  
> [!NOTE]
>  因为<xref:System.TimeZoneInfo.BaseUtcOffset%2A>是的一个属性<xref:System.TimeZoneInfo>对象而非<xref:System.TimeZoneInfo.AdjustmentRule>对象，<xref:System.TimeZoneInfo>类将从 UTC 一个偏移量应用于所有时区的调整。 以反映已修改其相对于 UTC 的时区，必须创建新的时区使用<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法。  
  
 <xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性不同于<xref:System.TimeZoneInfo.GetUtcOffset%2A>方法按以下方式：  
  
-   <xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性返回 UTC 与时区的标准时间; 之间的差异<xref:System.TimeZoneInfo.GetUtcOffset%2A>方法在时间中返回 UTC 与时区的时间的特定点之间的差异。  
  
-   <xref:System.TimeZoneInfo.GetUtcOffset%2A>方法将反映到时区; 应用程序的任何调整规则<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性却没有。  
  
   
  
## Examples  
 下面的示例使用<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性来显示本地时间与协调世界时 (UTC) 之间的差异。  
  
 [!code-csharp[System.TimeZone2.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#1)]
 [!code-vb[System.TimeZone2.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.TimeZoneInfo.GetUtcOffset" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedData">
      <MemberSignature Language="C#" Value="public static void ClearCachedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearCachedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ClearCachedData" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearCachedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearCachedData();" />
      <MemberSignature Language="F#" Value="static member ClearCachedData : unit -&gt; unit" Usage="System.TimeZoneInfo.ClearCachedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除已缓存的时区数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已缓存的时区数据包括本地时区、 协调世界时 (UTC) 区域中，和使用方法类似于检索任何时区数据<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>和<xref:System.TimeZoneInfo.GetSystemTimeZones%2A>。  
  
 您可能要调用<xref:System.TimeZoneInfo.ClearCachedData%2A>方法，以减少内存专门用于应用程序的缓存的时区信息或以反映本地系统时区已更改的事实。  
  
 不建议存储对本地和 UTC 时区的引用。 在调用<xref:System.TimeZoneInfo.ClearCachedData%2A>方法，这些对象变量将是未定义<xref:System.TimeZoneInfo>不再对引用的对象<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>或<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>。 例如，下面的代码中的第二个调用到<xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType>方法会抛出<xref:System.ArgumentException>因为`local`变量不再被视为等于<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.TimeZone2.BestPractices#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.BestPractices/cs/System.TimeZone2.BestPractices.cs#1)]
 [!code-vb[System.TimeZone2.BestPractices#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.BestPractices/vb/System.TimeZone2.BestPractices.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertTime">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将时间转换为特定时区的时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertTime">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTime (DateTime dateTime, TimeZoneInfo destinationTimeZone);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTime(valuetype System.DateTime dateTime, class System.TimeZoneInfo destinationTimeZone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTime(System.DateTime,System.TimeZoneInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo ^ destinationTimeZone);" />
      <MemberSignature Language="F#" Value="static member ConvertTime : DateTime * TimeZoneInfo -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTime (dateTime, destinationTimeZone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="destinationTimeZone" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="dateTime">要转换的日期和时间。</param>
        <param name="destinationTimeZone">
          <c>dateTime</c> 要转换到的时区。</param>
        <summary>将时间转换为特定时区的时间。</summary>
        <returns>目标时区的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTime%28System.DateTimeOffset%2CSystem.TimeZoneInfo%29>方法将应用实际上在任何调整规则`destinationTimeZone`时区。  
  
 此重载<xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%29>方法确定源时区的值从`dateTime`参数的<xref:System.DateTime.Kind%2A>属性，如下表所示。  
  
|Kind 属性值|源时区|方法行为|  
|-------------------------|----------------------|---------------------|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|<xref:System.TimeZoneInfo.Local%2A>|将本地时间转换到的时间`destinationTimeZone`。|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|<xref:System.TimeZoneInfo.Utc%2A>|将协调世界时 (UTC) 转换为时间`destinationTimeZone`。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|假定为<xref:System.TimeZoneInfo.Local%2A>。|将本地时间转换到的时间`destinationTimeZone`。|  
  
 <xref:System.DateTime.Kind%2A>属性所返回的<xref:System.DateTime>下表中所示设置值。  
  
|条件|返回的 Kind 属性值|  
|---------------|----------------------------------|  
|`destinationTimeZone` 为 <xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|`destinationTimeZone` 为 <xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|  
|所有其他日期和时间值和目标时区。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|  
  
 如果的值`dateTime`参数是不明确本地时间，它被解释为标准时间。 如果`dateTime`参数是无效的本地时间，则此方法将引发<xref:System.ArgumentException>。  
  
 如果转换`dateTime`早于的日期和时间值会导致<xref:System.DateTime.MinValue?displayProperty=nameWithType>或更高版本比<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTime.MinValue?displayProperty=nameWithType>或<xref:System.DateTime.MaxValue?displayProperty=nameWithType>分别。  
  
 您还可以通过调用转换为 / 自 UTC<xref:System.TimeZoneInfo.ConvertTimeFromUtc%2A>和<xref:System.TimeZoneInfo.ConvertTimeToUtc%2A>方法。  
  
   
  
## Examples  
 下面的示例将数组转换为日期和时间值到时间在美国和加拿大东部时区中。 它显示了上取决于源时区<xref:System.DateTime.Kind%2A?displayProperty=nameWithType>源属性<xref:System.DateTime>值。 它还演示了<xref:System.TimeZoneInfo.ConvertTime%2A>方法采用时区调整，因为时区调整在源和目标时区中发生在凌晨 2:00 在 2010 年 11 月 7日日。  
  
 [!code-csharp[System.TimeZoneInfo.ConvertTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timezoneinfo.converttime/cs/converttime1.cs#1)]
 [!code-vb[System.TimeZoneInfo.ConvertTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timezoneinfo.converttime/vb/converttime1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 参数值表示无效的时间。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationTimeZone" /> 参数的值为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，如果在执行转换时此方法识别只是将当前的调整规则<paramref name="dateTime" />被视为本地时间或如果<paramref name="destinationTimeZone" />是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确转换之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ConvertTime">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ConvertTime (DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ConvertTime(valuetype System.DateTimeOffset dateTimeOffset, class System.TimeZoneInfo destinationTimeZone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTime(System.DateTimeOffset,System.TimeZoneInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo ^ destinationTimeZone);" />
      <MemberSignature Language="F#" Value="static member ConvertTime : DateTimeOffset * TimeZoneInfo -&gt; DateTimeOffset" Usage="System.TimeZoneInfo.ConvertTime (dateTimeOffset, destinationTimeZone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
        <Parameter Name="destinationTimeZone" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">要转换的日期和时间。</param>
        <param name="destinationTimeZone">
          <c>dateTime</c> 要转换到的时区。</param>
        <summary>将时间转换为特定时区的时间。</summary>
        <returns>目标时区的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTime%28System.DateTimeOffset%2CSystem.TimeZoneInfo%29>方法将应用实际上在任何调整规则`destinationTimeZone`时区。  
  
 此重载与不同的其他重载<xref:System.TimeZoneInfo.ConvertTime%2A>方法通过接受<xref:System.DateTimeOffset>作为其第一个参数的值。 此标识的日期和时间与协调世界时 (UTC) 偏移量为而不是日期和时间在某个特定时区中。 因此，`dateTimeOffset`参数不能表示不明确时间无效。  
  
 在转换`dateTimeOffset`会考虑任何调整规则目标时区中的有效的值为目标时区，此方法中的时间。  
  
 如果转换`dateTimeOffset`早于的日期和时间值会导致<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>或更高版本比<xref:System.DateTimeOffset.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>或<xref:System.DateTimeOffset.MaxValue?displayProperty=nameWithType>分别。  
  
   
  
## Examples  
 下面的示例将数组转换为<xref:System.DateTimeOffset>时间的美国和加拿大东部时区中的值。 它演示了<xref:System.TimeZoneInfo.ConvertTime%2A>方法采用时区调整，因为时区调整在源和目标时区中发生在凌晨 2:00 在 2010 年 11 月 7日日。  
  
 [!code-csharp[System.TimeZoneInfo.ConvertTime#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timezoneinfo.converttime/cs/converttime2.cs#2)]
 [!code-vb[System.TimeZoneInfo.ConvertTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timezoneinfo.converttime/vb/converttime2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationTimeZone" /> 参数的值为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅在当前的调整规则时区转换到<paramref name="dateTimeOffset" />被视为本地时间或如果<paramref name="destinationTimeZone" />是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确转换之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ConvertTime">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTime (DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTime(valuetype System.DateTime dateTime, class System.TimeZoneInfo sourceTimeZone, class System.TimeZoneInfo destinationTimeZone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTime(System.DateTime,System.TimeZoneInfo,System.TimeZoneInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo ^ sourceTimeZone, TimeZoneInfo ^ destinationTimeZone);" />
      <MemberSignature Language="F#" Value="static member ConvertTime : DateTime * TimeZoneInfo * TimeZoneInfo -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTime (dateTime, sourceTimeZone, destinationTimeZone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="sourceTimeZone" Type="System.TimeZoneInfo" />
        <Parameter Name="destinationTimeZone" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="dateTime">要转换的日期和时间。</param>
        <param name="sourceTimeZone">
          <c>dateTime</c> 的时区。</param>
        <param name="destinationTimeZone">
          <c>dateTime</c> 要转换到的时区。</param>
        <summary>将时间从一个时区转换到另一个时区。</summary>
        <returns>目标时区中与源时区中的 <paramref name="dateTime" /> 参数对应的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTime%2A>方法将应用实际上在任何调整规则`destinationTimeZone`时区。  
  
 值<xref:System.DateTime.Kind%2A>的属性`dateTime`参数必须对应于`sourceTimeZone`参数，如下表所示。  
  
|DateTime.Kind 值|sourceTimeZone 值|方法行为|  
|-------------------------|--------------------------|---------------------|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|等于<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>。|将转换`dateTime`为目标时区的时间。|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|不等于<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>。|引发<xref:System.ArgumentException>。|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|等于<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。|将转换`dateTime`为目标时区的时间。|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|不等于<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。|引发<xref:System.ArgumentException>。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|任何。|将转换`dateTime`为目标时区的时间。|  
  
 您还可以将转换到或从协调世界时 (UTC) 通过调用<xref:System.TimeZoneInfo.ConvertTimeFromUtc%2A>和<xref:System.TimeZoneInfo.ConvertTimeToUtc%2A>方法。  
  
 <xref:System.DateTime.Kind%2A>属性所返回的<xref:System.DateTime>下表中所示设置值。  
  
|条件|返回的 Kind 属性值|  
|---------------|----------------------------------|  
|`destinationTimeZone` 参数为 <xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|`destinationTimeZone` 参数为 <xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|  
|所有其他日期和时间值、 源时区，并且目标时区。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|  
  
 如果的值`dateTime`参数为源时区中的不明确时间时，将其解释为标准时间。 如果`dateTime`参数是无效时间源时区中的，则此方法将引发<xref:System.ArgumentException>。  
  
 如果转换`dateTime`早于的日期和时间值会导致<xref:System.DateTime.MinValue?displayProperty=nameWithType>或更高版本比<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTime.MinValue?displayProperty=nameWithType>或<xref:System.DateTime.MaxValue?displayProperty=nameWithType>分别。  
  
 <xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%2CSystem.TimeZoneInfo%29>方法会抛出<xref:System.ArgumentException>异常如果<xref:System.DateTime.Kind%2A?displayProperty=nameWithType>的属性`dateTime`自变量是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>但`sourceTimeZone`参数不是<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。 若要确定该方法是否与源时区为本地时区或世界时区，而不是使用的值相等性测试引用相等性测试<xref:System.TimeZoneInfo.Equals%28System.TimeZoneInfo%29>方法。 请注意，<xref:System.TimeZoneInfo>对象，表示本地时区和通过调用检索<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法没有与引用相等性<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>。 此外，<xref:System.TimeZoneInfo>对象，表示本地或世界时区，并通过循环访问返回的集合检索<xref:System.TimeZoneInfo.GetSystemTimeZones%2A>方法没有与引用相等性<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>或<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>。 或者，可以调用<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%28System.DateTime%2CSystem.String%2CSystem.String%29>方法。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%2CSystem.TimeZoneInfo%29>方法将夏威夷标准时间转换为本地时间。  
  
 [!code-csharp[System.TimeZone2.Concepts#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Concepts/CS/TimeZone2Concepts.cs#9)]
 [!code-vb[System.TimeZone2.Concepts#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Concepts/VB/TimeZone2Concepts.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 参数的 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Local" />，但 <paramref name="sourceTimeZone" /> 参数不等于 <see cref="F:System.DateTimeKind.Local" />。  
  
或 
<paramref name="dateTime" /> 参数的 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Utc" />，但 <paramref name="sourceTimeZone" /> 参数不等于 <see cref="P:System.TimeZoneInfo.Utc" />。  
  
或 
<paramref name="dateTime" /> 参数为无效时间（即，它表示因时区的调整规则而不存在的时间）。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceTimeZone" /> 参数为 <see langword="null" />。  
  
或 
<paramref name="destinationTimeZone" /> 参数为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，如果在执行转换时此方法适用只是将当前的调整规则<paramref name="dateTime" />被视为本地时间，如果<paramref name="sourceTimeZone" />是<see cref="P:System.TimeZoneInfo.Local" />，或者，如果<paramref name="destinationTimeZone" />是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确转换之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="Overload:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertTimeBySystemTimeZoneId">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根据时区标识符将时间转换为另一时区中的时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertTimeBySystemTimeZoneId">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTimeBySystemTimeZoneId (DateTime dateTime, string destinationTimeZoneId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTimeBySystemTimeZoneId(valuetype System.DateTime dateTime, string destinationTimeZoneId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId(System.DateTime,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, System::String ^ destinationTimeZoneId);" />
      <MemberSignature Language="F#" Value="static member ConvertTimeBySystemTimeZoneId : DateTime * string -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId (dateTime, destinationTimeZoneId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="destinationTimeZoneId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dateTime">要转换的日期和时间。</param>
        <param name="destinationTimeZoneId">目标时区的标识符。</param>
        <summary>根据时区标识符将时间转换为另一时区中的时间。</summary>
        <returns>目标时区的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%2A>方法将应用实际上在任何调整规则`destinationTimeZoneId`时区。  
  
 此重载在很大程度上等同于调用<xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%29>方法，但还允许您通过其标识符而不是对象引用指定目标时区。 当必须将时间转换而无需检索与之相对应的时区对象并且不需要知道转换后的时间是标准或夏时制，则此方法是最有用。  
  
 <xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%28System.DateTime%2CSystem.String%29>方法确定源时区的值从`dateTime`参数的<xref:System.DateTime.Kind%2A>属性，如下表所示。  
  
|Kind 属性值|源时区|方法行为|  
|-------------------------|----------------------|---------------------|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|<xref:System.TimeZoneInfo.Local%2A>|将本地时间转换到的时间`destinationTimeZone`。|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|<xref:System.TimeZoneInfo.Utc%2A>|将协调世界时 (UTC) 转换为时间`destinationTimeZone`。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|假定为<xref:System.TimeZoneInfo.Local%2A>。|将本地时间转换到的时间`destinationTimeZone`。|  
  
 <xref:System.DateTime.Kind%2A>属性所返回的<xref:System.DateTime>下表中所示设置值。  
  
|条件|返回的 Kind 属性值|  
|---------------|----------------------------------|  
|`destinationTimeZone` 为 `TimeZoneInfo.Utc.Id`。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|任何其他`destinationTimeZone`值。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|  
  
 如果的值`dateTime`参数是不明确本地时间，它被解释为标准时间。 如果`dateTime`参数是无效的本地时间，则此方法将引发<xref:System.ArgumentException>。  
  
 如果转换`dateTime`早于的日期和时间值会导致<xref:System.DateTime.MinValue?displayProperty=nameWithType>或更高版本比<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTime.MinValue?displayProperty=nameWithType>或<xref:System.DateTime.MaxValue?displayProperty=nameWithType>分别。  
  
 此方法检索其标识符指定的时区`destinationTimeZoneId`注册表中的参数。 它不能检索使用创建的时区对象<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法。 `destinationTimeZoneId`参数必须精确对应于时区的注册表项的长度，但不是在情况下，成功匹配发生; 也就是说，比较`destinationTimeZoneId`时区标识符不区分大小写。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationTimeZoneId" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidTimeZoneException">时区标识符已找到，但注册表数据已损坏。</exception>
        <exception cref="T:System.Security.SecurityException">该进程没有读取包含时区信息的注册表项所需的权限。</exception>
        <exception cref="T:System.TimeZoneNotFoundException">在本地系统上找不到 <paramref name="destinationTimeZoneId" /> 标识符。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertTimeBySystemTimeZoneId">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ConvertTimeBySystemTimeZoneId (DateTimeOffset dateTimeOffset, string destinationTimeZoneId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ConvertTimeBySystemTimeZoneId(valuetype System.DateTimeOffset dateTimeOffset, string destinationTimeZoneId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId(System.DateTimeOffset,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, System::String ^ destinationTimeZoneId);" />
      <MemberSignature Language="F#" Value="static member ConvertTimeBySystemTimeZoneId : DateTimeOffset * string -&gt; DateTimeOffset" Usage="System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId (dateTimeOffset, destinationTimeZoneId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
        <Parameter Name="destinationTimeZoneId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">要转换的日期和时间。</param>
        <param name="destinationTimeZoneId">目标时区的标识符。</param>
        <summary>根据时区标识符将时间转换为另一时区中的时间。</summary>
        <returns>目标时区的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%2A>方法将应用实际上在任何调整规则`destinationTimeZoneId`时区。  
  
 此重载相当于调用<xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%29>方法，但还允许您通过其标识符而不是对象引用指定目标时区。 当必须将时间转换而无需检索与之相对应的时区对象并且不需要知道转换后的时间是标准或夏时制，则此方法是最有用。  
  
 因为`dateTimeOffset`参数表示的日期和时间再加上该时间的偏移量从协调世界时 (UTC)，它不能表示不明确时间无效。  
  
 此方法检索其标识符指定的时区`destinationTimeZoneId`注册表中的参数。 它不能检索使用创建的时区对象<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法。 `destinationTimeZoneId`参数必须精确对应于时区的注册表项的长度，但不是在情况下，成功匹配发生; 也就是说，比较`destinationTimeZoneId`时区标识符不区分大小写。  
  
 在转换`dateTimeOffset`会考虑任何调整规则目标时区中的有效的值为目标时区，该方法中的时间。  
  
 如果转换`dateTimeOffset`早于的日期和时间值会导致<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>或更高版本比<xref:System.DateTimeOffset.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>或<xref:System.DateTimeOffset.MaxValue?displayProperty=nameWithType>分别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationTimeZoneId" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidTimeZoneException">时区标识符已找到，但注册表数据已损坏。</exception>
        <exception cref="T:System.Security.SecurityException">该进程没有读取包含时区信息的注册表项所需的权限。</exception>
        <exception cref="T:System.TimeZoneNotFoundException">在本地系统上找不到 <paramref name="destinationTimeZoneId" /> 标识符。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertTimeBySystemTimeZoneId">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTimeBySystemTimeZoneId (DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTimeBySystemTimeZoneId(valuetype System.DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId(System.DateTime,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, System::String ^ sourceTimeZoneId, System::String ^ destinationTimeZoneId);" />
      <MemberSignature Language="F#" Value="static member ConvertTimeBySystemTimeZoneId : DateTime * string * string -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId (dateTime, sourceTimeZoneId, destinationTimeZoneId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="sourceTimeZoneId" Type="System.String" />
        <Parameter Name="destinationTimeZoneId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dateTime">要转换的日期和时间。</param>
        <param name="sourceTimeZoneId">源时区的标识符。</param>
        <param name="destinationTimeZoneId">目标时区的标识符。</param>
        <summary>根据时区标识符将时间从一个时区转换到另一个时区。</summary>
        <returns>目标时区中与源时区中的 <paramref name="dateTime" /> 参数对应的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%2A>方法将应用实际上在任何调整规则`destinationTimeZoneId`时区。  
  
 尽管它是类似于<xref:System.TimeZoneInfo.ConvertTime%28System.DateTime%2CSystem.TimeZoneInfo%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType>方法中，可以使用<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%28System.DateTime%2CSystem.String%2CSystem.String%29?displayProperty=nameWithType>来指定使用其标识符，而不是在源和目标时区其<xref:System.TimeZoneInfo>对象。 当必须将时间转换而无需检索与之相对应的时区对象并且不需要知道转换后的时间是标准或夏时制，则此方法是最有用。  
  
 此方法检索其标识符是时区`sourceTimeZoneId`和`destinationTimeZoneId`注册表中的参数。 它不能检索时区对象，使用创建<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法。  
  
 值<xref:System.DateTime.Kind%2A>的属性`dateTime`参数必须对应于`sourceTimeZoneId`参数，如下表所示。  
  
|DateTime.Kind 值|sourceTimeZone 值|方法行为|  
|-------------------------|--------------------------|---------------------|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|等于`TimeZoneInfo.Utc.Id`。|将转换`dateTime`为目标时区的时间。|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|不等于`TimeZoneInfo.Utc.Id`。|引发<xref:System.ArgumentException>。|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|等于`TimeZoneInfo.Local.Id`。|将转换`dateTime`为目标时区的时间。|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|不等于`TimeZoneInfo.Local.Id`。|引发<xref:System.ArgumentException>。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|任何。|将转换`dateTime`为目标时区的时间。|  
  
 因为它依赖于调用<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法，<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%2A>方法用于执行不区分大小写的搜索来查找对应于时区`sourceTimeZoneId`和`destinationTimeZoneId`。  
  
 如果的值`dateTime`参数为源时区中的不明确时间时，将其解释为标准时间。 如果`dateTime`参数是无效时间源时区中的，则此方法将引发<xref:System.ArgumentException>。  
  
 <xref:System.DateTime.Kind%2A>所返回的属性<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>除非目标时区为协调世界时 (UTC)，在这种情况下它设置为<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId%28System.DateTime%2CSystem.String%2CSystem.String%29?displayProperty=nameWithType>方法相对应的时间为本地系统时间显示八个城市的世界。  
  
 [!code-csharp[System.TimeZone2.Conversions#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Conversions/cs/System.TimeZone2.Conversions.cs#3)]
 [!code-vb[System.TimeZone2.Conversions#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Conversions/vb/System.TimeZone2.Conversions.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 参数的 <see cref="P:System.DateTime.Kind" /> 属性与源时区不对应。  
  
或 
 <paramref name="dateTime" /> 是源时区中的无效时间。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceTimeZoneId" /> 为 <see langword="null" />。  
  
或 
 <paramref name="destinationTimeZoneId" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidTimeZoneException">已找到时区标识符，但注册表数据已损坏。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取包含时区数据的注册表项所需的权限。</exception>
        <exception cref="T:System.TimeZoneNotFoundException">在本地系统上找不到 <paramref name="sourceTimeZoneId" /> 标识符。  
  
或 
在本地系统上找不到 <paramref name="destinationTimeZoneId" /> 标识符。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertTimeFromUtc">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTimeFromUtc (DateTime dateTime, TimeZoneInfo destinationTimeZone);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTimeFromUtc(valuetype System.DateTime dateTime, class System.TimeZoneInfo destinationTimeZone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTimeFromUtc(System.DateTime,System.TimeZoneInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo ^ destinationTimeZone);" />
      <MemberSignature Language="F#" Value="static member ConvertTimeFromUtc : DateTime * TimeZoneInfo -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTimeFromUtc (dateTime, destinationTimeZone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="destinationTimeZone" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="dateTime">协调世界时 (UTC)。</param>
        <param name="destinationTimeZone">
          <c>dateTime</c> 要转换到的时区。</param>
        <summary>将协调世界时 (UTC) 转换为指定时区中的时间。</summary>
        <returns>目标时区的日期和时间。 如果 <paramref name="destinationTimeZone" /> 为 <see cref="P:System.TimeZoneInfo.Utc" />，则其 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Utc" />；否则其 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Unspecified" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在执行转换时,<xref:System.TimeZoneInfo.ConvertTimeFromUtc%2A>方法将应用实际上在任何调整规则`destinationTimeZone`时区。  
  
 此方法的确切行为取决于的值<xref:System.DateTime.Kind%2A>属性的`dateTime`参数，如下表所示。  
  
|DateTime.Kind 属性|转换|  
|----------------------------|----------------|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|引发<xref:System.ArgumentException>。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> 或 <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|将从协调世界时 (UTC)。|  
  
 如果转换`dateTime`早于的日期和时间值会导致<xref:System.DateTime.MinValue?displayProperty=nameWithType>或更高版本比<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTime.MinValue?displayProperty=nameWithType>或<xref:System.DateTime.MaxValue?displayProperty=nameWithType>分别。  
  
   
  
## Examples  
 下面的示例将协调世界时 (UTC) 转换为中部时间。  
  
 [!code-csharp[System.TimeZone2.Concepts#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Concepts/CS/TimeZone2Concepts.cs#8)]
 [!code-vb[System.TimeZone2.Concepts#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Concepts/VB/TimeZone2Concepts.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 的 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Local" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationTimeZone" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅在当前的调整规则时区转换到<paramref name="destinationTimeZone" />是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确转换之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertTimeToUtc">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间转换为协调世界时 (UTC)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertTimeToUtc">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTimeToUtc (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTimeToUtc(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTimeToUtc(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="static member ConvertTimeToUtc : DateTime -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTimeToUtc dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">要转换的日期和时间。</param>
        <summary>将指定的日期和时间转换为协调世界时 (UTC)。</summary>
        <returns>与 <paramref name="dateTime" /> 参数对应的协调世界时 (UTC)。 <see cref="T:System.DateTime" /> 值的 <see cref="P:System.DateTime.Kind" /> 属性始终设置为 <see cref="F:System.DateTimeKind.Utc" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 执行的具体转换取决于的值<xref:System.DateTime.Kind%2A>属性的`dateTime`参数，如下表所示。  
  
|DateTime.Kind 属性|转换|  
|----------------------------|----------------|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|从本地时间转换为协调世界时 (UTC)。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|假定`dateTime`为本地时间，将从本地时间转换为 UTC。|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|返回`dateTime`不变。|  
  
 如果`dateTime`对应到不明确本地时间，此方法假设它是标准的本地时间。 如果`dateTime`对应于无效的本地时间，该方法将引发<xref:System.ArgumentException>。  
  
> [!NOTE]
>  如果当前计算机的本地时区包含多个调整规则，此重载<xref:System.TimeZoneInfo.ConvertTimeToUtc%2A>方法可返回不同的结果<xref:System.TimeZone.ToUniversalTime%2A?displayProperty=nameWithType>和<xref:System.DateTime.ToUniversalTime%2A?displayProperty=nameWithType>方法。 <xref:System.TimeZone.ToUniversalTime%2A?displayProperty=nameWithType> 始终将当前的调整规则是否应用时区转换到`dateTime`其日期范围内。 和在执行时[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]，<xref:System.DateTime.ToUniversalTime%2A?displayProperty=nameWithType>也适用于时区转换，当前的调整规则，该值指示是否`dateTime`其日期范围内。  
  
 如果 UTC 等效于`dateTime`早于<xref:System.DateTime.MinValue?displayProperty=nameWithType>或更高版本的<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTime.MinValue>或<xref:System.DateTime.MaxValue>分别。  
  
   
  
## Examples  
 下面的示例演示的转换时间值的<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>， <xref:System.DateTimeKind.Local?displayProperty=nameWithType>，和<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>分别。 它还阐释了不明确和无效时间转换。  
  
 [!code-csharp[System.TimeZone2.Conversions#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Conversions/cs/System.TimeZone2.Conversions.cs#1)]
 [!code-vb[System.TimeZone2.Conversions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Conversions/vb/System.TimeZone2.Conversions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="TimeZoneInfo.Local.IsInvalidDateTime(" />
          <paramref name="dateTime" />
          <see langword=")" /> 返回 <see langword="true" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，此方法适用于时区转换只是将当前的调整规则。因此，该方法可能无法准确转换之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ConvertTimeToUtc">
      <MemberSignature Language="C#" Value="public static DateTime ConvertTimeToUtc (DateTime dateTime, TimeZoneInfo sourceTimeZone);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ConvertTimeToUtc(valuetype System.DateTime dateTime, class System.TimeZoneInfo sourceTimeZone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo ^ sourceTimeZone);" />
      <MemberSignature Language="F#" Value="static member ConvertTimeToUtc : DateTime * TimeZoneInfo -&gt; DateTime" Usage="System.TimeZoneInfo.ConvertTimeToUtc (dateTime, sourceTimeZone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="sourceTimeZone" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="dateTime">要转换的日期和时间。</param>
        <param name="sourceTimeZone">
          <c>dateTime</c> 的时区。</param>
        <summary>将指定时区中的时间转换为协调世界时 (UTC)。</summary>
        <returns>与 <paramref name="dateTime" /> 参数对应的协调世界时 (UTC)。 <see cref="T:System.DateTime" /> 对象的 <see cref="P:System.DateTime.Kind" /> 属性始终设置为 <see cref="F:System.DateTimeKind.Utc" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.DateTime.Kind%2A>的属性`dateTime`参数等于<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>并且`sourceTimeZone`参数等于<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>，此方法返回`dateTime`而不执行任何转换。  
  
 如果`dateTime`对应到不明确的时间，此方法假设它是源时区的标准时间。 如果`dateTime`对应于一个无效的时间，此方法，则会引发<xref:System.ArgumentException>。  
  
 如果的协调世界时 (UTC) 等效项`dateTime`早于<xref:System.DateTime.MinValue?displayProperty=nameWithType>或更高版本的<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，此方法返回<xref:System.DateTime.MinValue>或<xref:System.DateTime.MaxValue>分别。  
  
   
  
## Examples  
 下面的示例从本地系统中检索当前日期并将其转换为协调世界时 (UTC)，然后将其转换到东京标准时间，并最后将从东京标准时间转换回为 UTC。 请注意，这两个的 UTC 时间相同。  
  
 [!code-csharp[System.TimeZone2.Conversions#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Conversions/cs/convertdt2.cs#2)]
 [!code-vb[System.TimeZone2.Conversions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Conversions/vb/convertdt2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" />
          <see langword=".Kind" /> 为 <see cref="F:System.DateTimeKind.Utc" />，并且 <paramref name="sourceTimeZone" /> 不等于 <see cref="P:System.TimeZoneInfo.Utc" />。  
  
或 
 <paramref name="dateTime" /><see langword=".Kind" /> 为 <see cref="F:System.DateTimeKind.Local" />，并且 <paramref name="sourceTimeZone" /> 不等于 <see cref="P:System.TimeZoneInfo.Local" />。  
  
或 
 <paramref name="sourceTimeZone" /><see langword=".IsInvalidDateTime(" /><paramref name="dateTime" /><see langword=")" /> 返回 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceTimeZone" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，该方法所在的时区转换为应用只是将当前的调整规则，如果<paramref name="sourceTimeZone" />是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确转换之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateCustomTimeZone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定义在本地计算机上未找到的时区。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateCustomTimeZone">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo CreateCustomTimeZone (string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.TimeZoneInfo CreateCustomTimeZone(string id, valuetype System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.CreateCustomTimeZone(System.String,System.TimeSpan,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCustomTimeZone (id As String, baseUtcOffset As TimeSpan, displayName As String, standardDisplayName As String) As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeZoneInfo ^ CreateCustomTimeZone(System::String ^ id, TimeSpan baseUtcOffset, System::String ^ displayName, System::String ^ standardDisplayName);" />
      <MemberSignature Language="F#" Value="static member CreateCustomTimeZone : string * TimeSpan * string * string -&gt; TimeZoneInfo" Usage="System.TimeZoneInfo.CreateCustomTimeZone (id, baseUtcOffset, displayName, standardDisplayName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="baseUtcOffset" Type="System.TimeSpan" />
        <Parameter Name="displayName" Type="System.String" />
        <Parameter Name="standardDisplayName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">时区的标识符。</param>
        <param name="baseUtcOffset">一个对象，它表示此时区和协调世界时 (UTC) 之间的时差。</param>
        <param name="displayName">新时区的显示名称。</param>
        <param name="standardDisplayName">新时区的标准时间的名称。</param>
        <summary>创建带指定标识符的自定义时区、与协调世界时 (UTC) 的偏移量、显示名称以及标准时间显示名称。</summary>
        <returns>新时区。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.TimeZoneInfo.CreateCustomTimeZone%28System.String%2CSystem.TimeSpan%2CSystem.String%2CSystem.String%29>方法适合于创建不具有任何调整 （即，不支持夏时制时间区域） 的时区。 若要定义包括调整为夏时制时区，请使用<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>或<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法。  
  
 下表显示了为提供的参数之间的关系<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法和属性的<xref:System.TimeZoneInfo>方法调用返回的对象。  
  
|CreateCustomTimeZone 参数|TimeZoneInfo 属性|  
|------------------------------------|---------------------------|  
|`id`|<xref:System.TimeZoneInfo.Id%2A>|  
|`baseUtcOffset`|<xref:System.TimeZoneInfo.BaseUtcOffset%2A>|  
|`displayName`|<xref:System.TimeZoneInfo.DisplayName%2A>|  
|`standardDisplayName`|<xref:System.TimeZoneInfo.StandardName%2A>|  
  
 通常情况下，时区的标准时间名称和其标识符是相同的。 但是，时区的标识符的长度不应超过 32 个字符。 将字符串传递到`displayName`参数遵循相当标准的格式。 显示名称的第一个部分是时区的基本偏移量从协调世界时，这将由的首字母缩写 GMT （格林尼治标准时间），括在括号中。 随后是一个字符串，标识时区本身，或一个或和 / 或多个城市、 区域或国家/地区时区的时间。 例如:  
  
```  
(GMT+02:00) Athens, Beirut, Istanbul, Minsk  
(GMT-02:00) Mid-Atlantic  
(GMT-07:00) Mountain Time (US & Canada)  
```  
  
   
  
## Examples  
 以下示例创建一个自定义时区，莫森，霍尔姆湾南极洲区域。 然后，它显示将本地时间转换为新的时区中的时间的结果。  
  
 [!code-csharp[System.TimeZone2.CreateTimeZone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/cs/System.TimeZone2.CreateTimeZone.cs#1)]
 [!code-vb[System.TimeZone2.CreateTimeZone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/vb/System.TimeZone2.CreateTimeZone.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="id" /> 参数为空字符串 ("")。  
  
或 
<paramref name="baseUtcOffset" /> 参数不表示整分钟数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUtcOffset" /> 参数大于 14 小时或小于 -14 小时。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCustomTimeZone">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo CreateCustomTimeZone (string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.TimeZoneInfo CreateCustomTimeZone(string id, valuetype System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, class System.TimeZoneInfo/AdjustmentRule[] adjustmentRules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.CreateCustomTimeZone(System.String,System.TimeSpan,System.String,System.String,System.String,System.TimeZoneInfo.AdjustmentRule[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCustomTimeZone (id As String, baseUtcOffset As TimeSpan, displayName As String, standardDisplayName As String, daylightDisplayName As String, adjustmentRules As TimeZoneInfo.AdjustmentRule()) As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeZoneInfo ^ CreateCustomTimeZone(System::String ^ id, TimeSpan baseUtcOffset, System::String ^ displayName, System::String ^ standardDisplayName, System::String ^ daylightDisplayName, cli::array &lt;TimeZoneInfo::AdjustmentRule ^&gt; ^ adjustmentRules);" />
      <MemberSignature Language="F#" Value="static member CreateCustomTimeZone : string * TimeSpan * string * string * string * TimeZoneInfo.AdjustmentRule[] -&gt; TimeZoneInfo" Usage="System.TimeZoneInfo.CreateCustomTimeZone (id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName, adjustmentRules)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="baseUtcOffset" Type="System.TimeSpan" />
        <Parameter Name="displayName" Type="System.String" />
        <Parameter Name="standardDisplayName" Type="System.String" />
        <Parameter Name="daylightDisplayName" Type="System.String" />
        <Parameter Name="adjustmentRules" Type="System.TimeZoneInfo+AdjustmentRule[]" />
      </Parameters>
      <Docs>
        <param name="id">时区的标识符。</param>
        <param name="baseUtcOffset">一个对象，它表示此时区和协调世界时 (UTC) 之间的时差。</param>
        <param name="displayName">新时区的显示名称。</param>
        <param name="standardDisplayName">新时区的标准时间名称。</param>
        <param name="daylightDisplayName">新时区的夏令制名称。</param>
        <param name="adjustmentRules">一个数组，它将基本 UTC 偏移量增加了特定的期间。</param>
        <summary>创建带指定标识符的自定义时区、与协调世界时 (UTC) 的偏移量、显示名称、标准时间名称、夏时制名称和夏时制规则。</summary>
        <returns>一个表示新时区的 <see cref="T:System.TimeZoneInfo" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法适合于创建支持夏令时的时区。 若要定义不支持夏令时的时区，请使用<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>或<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法。  
  
 下表显示了为提供的参数之间的关系<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法和成员<xref:System.TimeZoneInfo>方法调用返回的对象。  
  
|CreateCustomTimeZone 参数|TimeZoneInfo 成员|  
|------------------------------------|-------------------------|  
|`id`|<xref:System.TimeZoneInfo.Id%2A>|  
|`baseUtcOffset`|<xref:System.TimeZoneInfo.BaseUtcOffset%2A>|  
|`displayName`|<xref:System.TimeZoneInfo.DisplayName%2A>|  
|`standardDisplayName`|<xref:System.TimeZoneInfo.StandardName%2A>|  
|`daylightDisplayName`|<xref:System.TimeZoneInfo.DaylightName%2A>|  
|`adjustmentRules`|一个数组<xref:System.TimeZoneInfo.AdjustmentRule?displayProperty=nameWithType>返回的对象<xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法。|  
  
 通常情况下，时区的标准时间名称和其标识符是相同的。 但是，时区的标识符的长度不应超过 32 个字符。 将字符串传递到`displayName`参数遵循相当标准的格式。 显示名称的第一个部分是时区的基本偏移量从协调世界时，这将由的首字母缩写 GMT （格林尼治标准时间），括在括号中。 随后是一个字符串，标识时区本身，或一个或和 / 或多个城市、 区域或国家/地区时区的时间。 例如:  
  
```  
(GMT+02:00) Athens, Beirut, Istanbul, Minsk  
(GMT-02:00) Mid-Atlantic  
(GMT-07:00) Mountain Time (US & Canada)  
```  
  
 `baseUtcOffset`参数定义自定义时区的偏移量从协调世界时 (UTC) 的所有时区的调整规则。 换而言之，<xref:System.TimeZoneInfo>对象模型假定相对于 UTC 的时区的偏移量是常量的时区，整个生存期，并且存在独立于特定的调整规则。 以反映已更改其偏移量与 UTC 的时区，必须创建一个新的时区对象。  
  
 通过执行以下操作定义时区的调整规则：  
  
1.  调用<xref:System.TimeZoneInfo.TransitionTime.CreateFloatingDateRule%2A>或<xref:System.TimeZoneInfo.TransitionTime.CreateFixedDateRule%2A>方法定义的起始和结束每个调整规则的过渡时间。  
  
2.  调用<xref:System.TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule%2A>对于每个调整规则的方法。  
  
3.  将调整规则分配到一个数组可作为传递`adjustmentRules`参数。  
  
   
  
## Examples  
 下面的示例在南极洲中创建一个自定义时区，帕默站，安特卫普岛。 然后，将本地时间转换为新的时区中的时间，并显示结果。  
  
 [!code-csharp[System.TimeZone2.CreateTimeZone#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/cs/System.TimeZone2.CreateTimeZone.cs#2)]
 [!code-vb[System.TimeZone2.CreateTimeZone#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/vb/System.TimeZone2.CreateTimeZone.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="id" /> 参数为空字符串 ("")。  
  
或 
<paramref name="baseUtcOffset" /> 参数不表示整分钟数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUtcOffset" /> 参数大于 14 小时或小于 -14 小时。</exception>
        <exception cref="T:System.InvalidTimeZoneException">在 <paramref name="adjustmentRules" /> 参数中指定的调整规则重叠。  
  
或 
在 <paramref name="adjustmentRules" /> 参数中指定的调整规则未按时间顺序排列。  
  
或 
<paramref name="adjustmentRules" /> 中的一个或多个元素为 <see langword="null" />。  
  
或 
一个日期可能有多个应用于它的调整规则。  
  
或 
<paramref name="baseUtcOffset" /> 参数与 <paramref name="adjustmentRules" /> 数组中一个或多个对象的 <see cref="P:System.TimeZoneInfo.AdjustmentRule.DaylightDelta" /> 值的和大于 14 小时或小于 -14 小时。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCustomTimeZone">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo CreateCustomTimeZone (string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.TimeZoneInfo CreateCustomTimeZone(string id, valuetype System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, class System.TimeZoneInfo/AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.CreateCustomTimeZone(System.String,System.TimeSpan,System.String,System.String,System.String,System.TimeZoneInfo.AdjustmentRule[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCustomTimeZone (id As String, baseUtcOffset As TimeSpan, displayName As String, standardDisplayName As String, daylightDisplayName As String, adjustmentRules As TimeZoneInfo.AdjustmentRule(), disableDaylightSavingTime As Boolean) As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeZoneInfo ^ CreateCustomTimeZone(System::String ^ id, TimeSpan baseUtcOffset, System::String ^ displayName, System::String ^ standardDisplayName, System::String ^ daylightDisplayName, cli::array &lt;TimeZoneInfo::AdjustmentRule ^&gt; ^ adjustmentRules, bool disableDaylightSavingTime);" />
      <MemberSignature Language="F#" Value="static member CreateCustomTimeZone : string * TimeSpan * string * string * string * TimeZoneInfo.AdjustmentRule[] * bool -&gt; TimeZoneInfo" Usage="System.TimeZoneInfo.CreateCustomTimeZone (id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName, adjustmentRules, disableDaylightSavingTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="baseUtcOffset" Type="System.TimeSpan" />
        <Parameter Name="displayName" Type="System.String" />
        <Parameter Name="standardDisplayName" Type="System.String" />
        <Parameter Name="daylightDisplayName" Type="System.String" />
        <Parameter Name="adjustmentRules" Type="System.TimeZoneInfo+AdjustmentRule[]" />
        <Parameter Name="disableDaylightSavingTime" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="id">时区的标识符。</param>
        <param name="baseUtcOffset">一个 <see cref="T:System.TimeSpan" /> 对象，它表示此时区和协调世界时 (UTC) 之间的时差。</param>
        <param name="displayName">新时区的显示名称。</param>
        <param name="standardDisplayName">新时区的标准时间名称。</param>
        <param name="daylightDisplayName">新时区的夏令制名称。</param>
        <param name="adjustmentRules">一个 <see cref="T:System.TimeZoneInfo.AdjustmentRule" /> 对象的数组，这些对象增加特定期间的基本 UTC 偏移量。</param>
        <param name="disableDaylightSavingTime">如果为 <see langword="true" /> ，则丢弃包含新对象的 <c>adjustmentRules</c> 中与夏令制相关的任何信息；否则为 <see langword="false" />。</param>
        <summary>创建带指定标识符的自定义时区、与协调世界时 (UTC) 的偏移量、显示名称、标准时间名称、夏令制名称、夏令制规则以及指示返回的对象是否反映夏令制信息的值。</summary>
        <returns>新时区。 如果 <paramref name="disableDaylightSavingTime" /> 参数为 <see langword="true" />，则返回的对象没有夏令制数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此重载<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法来创建在运行时条件可以确定夏时制其支持的自定义时区。  
  
 下表显示了为提供的参数之间的关系<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法和成员<xref:System.TimeZoneInfo>方法调用返回的对象。  
  
|CreateCustomTimeZone 参数|TimeZoneInfo 属性|  
|------------------------------------|---------------------------|  
|`id`|<xref:System.TimeZoneInfo.Id%2A>|  
|`baseUtcOffset`|<xref:System.TimeZoneInfo.BaseUtcOffset%2A>|  
|`displayName`|<xref:System.TimeZoneInfo.DisplayName%2A>|  
|`standardDisplayName`|<xref:System.TimeZoneInfo.StandardName%2A>|  
|`daylightDisplayName`|<xref:System.TimeZoneInfo.DaylightName%2A> 如果`disableDaylightSavingTime`是`false`;<xref:System.String.Empty?displayProperty=nameWithType>如果`disableDaylightSavingTime`是`true`。|  
|`adjustmentRules`|一个数组<xref:System.TimeZoneInfo.AdjustmentRule>返回的对象<xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法如果`disableDaylightSavingTime`是`false`; 返回一个空数组<xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法如果`disableDaylightSavingTime`是`true`。|  
|`disableDaylightSavingTime`|不<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A>。|  
  
 通常情况下，时区的标准时间名称和其标识符是相同的。 但是，时区的标识符的长度不应超过 32 个字符。 将字符串传递到`displayName`参数遵循相当标准的格式。 显示名称的第一个部分是时区的基本偏移量从协调世界时，这将由的首字母缩写 GMT （格林尼治标准时间），括在括号中。 随后是一个字符串，标识时区本身，或一个或和 / 或多个城市、 区域或国家/地区时区的时间。 例如:  
  
```  
(GMT+02:00) Athens, Beirut, Istanbul, Minsk  
(GMT-02:00) Mid-Atlantic  
(GMT-07:00) Mountain Time (US & Canada)  
```  
  
 通过执行以下操作定义时区的调整规则：  
  
1.  调用<xref:System.TimeZoneInfo.TransitionTime.CreateFloatingDateRule%2A>或<xref:System.TimeZoneInfo.TransitionTime.CreateFixedDateRule%2A>方法定义的起始和结束每个调整规则的转换规则。  
  
2.  调用<xref:System.TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule%2A>对于每个调整规则的方法。  
  
3.  将调整规则分配到一个数组可作为传递`adjustmentRules`参数。  
  
 如果`disableDaylightSavingTime`参数是`false`，此方法的操作等同于<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>重载。 如果`disableDaylightSavingTime`是`true`，返回的对象包括带调整规则和一个<xref:System.TimeZoneInfo.DaylightName%2A>属性值为空字符串。  
  
   
  
## Examples  
 下面的示例在南极洲中创建一个自定义时区，帕默站，安特卫普岛。 它会设置`disableDaylightSavingTime`对的调用中的参数<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A?displayProperty=nameWithType>方法`true`。 然后显示新时区的夏时制名称，如果不存在，并调整规则，以确认新时区具有任何夏令制信息数。  
  
 [!code-csharp[System.TimeZone2.CreateTimeZone#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/cs/System.TimeZone2.CreateTimeZone.cs#3)]
 [!code-vb[System.TimeZone2.CreateTimeZone#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/vb/System.TimeZone2.CreateTimeZone.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="id" /> 参数为空字符串 ("")。  
  
或 
<paramref name="baseUtcOffset" /> 参数不表示整分钟数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUtcOffset" /> 参数大于 14 小时或小于 -14 小时。</exception>
        <exception cref="T:System.InvalidTimeZoneException">在 <paramref name="adjustmentRules" /> 参数中指定的调整规则重叠。  
  
或 
在 <paramref name="adjustmentRules" /> 参数中指定的调整规则未按时间顺序排列。  
  
或 
<paramref name="adjustmentRules" /> 中的一个或多个元素为 <see langword="null" />。  
  
或 
一个日期可能有多个应用于它的调整规则。  
  
或 
<paramref name="baseUtcOffset" /> 参数与 <paramref name="adjustmentRules" /> 数组中一个或多个对象的 <see cref="P:System.TimeZoneInfo.AdjustmentRule.DaylightDelta" /> 值的和大于 14 小时或小于 -14 小时。</exception>
      </Docs>
    </Member>
    <Member MemberName="DaylightName">
      <MemberSignature Language="C#" Value="public string DaylightName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DaylightName" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.DaylightName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DaylightName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DaylightName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DaylightName : string" Usage="System.TimeZoneInfo.DaylightName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前时区的夏令时的显示名称。</summary>
        <value>时区的夏令时的显示名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据随 Windows 操作系统一起安装的区域性进行本地化的显示名称。  
  
 一个<xref:System.TimeZoneInfo.DaylightName%2A>属性的值不是<xref:System.String.Empty?displayProperty=nameWithType>或`null`并不一定表示时区支持夏令时。 若要确定是否时区支持夏令时，检查的值及其<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A>属性。  
  
 在大多数情况下，<xref:System.TimeZoneInfo.DaylightName%2A>属性在注册表中定义的时区不是<xref:System.String.Empty?displayProperty=nameWithType>或`null`。 但是，<xref:System.TimeZoneInfo.DaylightName%2A>的自定义时区的属性可以设置为<xref:System.String.Empty?displayProperty=nameWithType>。 通过创建自定义时区时将发生这种情况<xref:System.TimeZoneInfo.CreateCustomTimeZone%28System.String%2CSystem.TimeSpan%2CSystem.String%2CSystem.String%29?displayProperty=nameWithType>或<xref:System.TimeZoneInfo.CreateCustomTimeZone%28System.String%2CSystem.TimeSpan%2CSystem.String%2CSystem.String%2CSystem.String%2CSystem.TimeZoneInfo.AdjustmentRule%5B%5D%2CSystem.Boolean%29?displayProperty=nameWithType>重载并`disableDaylightSavingTime`参数是`true`。 因此，你的代码应永远不会假设的值<xref:System.TimeZoneInfo.DaylightName%2A>属性不是`null`或为空。  
  
 <xref:System.TimeZoneInfo.DaylightName%2A>属性等效于<xref:System.TimeZone.DaylightName%2A>属性的<xref:System.TimeZone>类。  
  
   
  
## Examples  
 下面的示例定义一个名为方法`DisplayDateWithTimeZoneName`，它使用<xref:System.TimeZoneInfo.IsDaylightSavingTime%28System.DateTime%29>方法，以确定是否显示时区的标准时间名称或夏令时名称。  
  
 [!code-csharp[System.TimeZone2.IsDaylightSavingTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/cs/IsDaylightSavingTime.cs#1)]
 [!code-vb[System.TimeZone2.IsDaylightSavingTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/vb/IsDaylightSavingTime.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayName">
      <MemberSignature Language="C#" Value="public string DisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayName" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.DisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayName : string" Usage="System.TimeZoneInfo.DisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示时区的一般显示名称。</summary>
        <value>时区的一般显示名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据随 Windows 操作系统一起安装的区域性进行本地化的显示名称。  
  
 Windows 系统的时区的时区显示名称遵循相当标准的格式。 显示名称的第一个部分是时区的基本偏移量从协调世界时，这将由的首字母缩写 GMT （格林尼治标准时间），括在括号中。 为协调世界时，格林威治标准时间首字母缩写词，没有偏移量被括在括号中。  随后是一个字符串，标识时区或一个或多个城市、 区域或国家/地区时区中。 例如:  
  
```  
(GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London  
(GMT+02:00) Athens, Beirut, Istanbul, Minsk  
(GMT-02:00) Mid-Atlantic  
(GMT-07:00) Mountain Time (US & Canada)  
```  
  
   
  
## Examples  
 下面的示例检索<xref:System.TimeZoneInfo>对象，表示本地时区，并输出其显示名称、 标准时间名称和夏时制名称。 输出显示在美国的系统太平洋标准时区运行。  
  
 [!code-csharp[System.TimeZone2.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/ShowTimeZoneNames1.cs#2)]
 [!code-vb[System.TimeZone2.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/ShowTimeZoneNames1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个 <see cref="T:System.TimeZoneInfo" /> 对象是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="timeZoneInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前对象进行比较的第二个对象。</param>
        <summary>确定当前的 <see cref="T:System.TimeZoneInfo" /> 对象和另一个对象是否相等。</summary>
        <returns>如果 <paramref name="obj" /> 是等于当前实例的 <see cref="T:System.TimeZoneInfo" /> 对象，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将转换或强制转换`obj`到<xref:System.TimeZoneInfo>对象，并将其与当前实例进行比较。 为确定相等性测试基于值的比较。 当前<xref:System.TimeZoneInfo>实例和`obj`视为可在以下情况下等于：  
  
-   运行时类型`obj`是<xref:System.TimeZoneInfo>。  
  
-   两个对象具有相同<xref:System.TimeZoneInfo.Id%2A>属性值。  
  
-   两个对象具有相同的调整规则。  
  
 如果 `obj` 为 `null`，则此方法返回 `false`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.TimeZoneInfo.Equals%28System.Object%29>方法确定本地时区为太平洋时间或美国东部时间。  
  
 [!code-csharp[System.TimeZoneInfo.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timezoneinfo.equals/cs/equals1.cs#1)]
 [!code-vb[System.TimeZoneInfo.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timezoneinfo.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (TimeZoneInfo other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.TimeZoneInfo other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.Equals(System.TimeZoneInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As TimeZoneInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(TimeZoneInfo ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : TimeZoneInfo -&gt; bool" Usage="timeZoneInfo.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="other">要与当前对象进行比较的第二个对象。</param>
        <summary>确定当前的 <see cref="T:System.TimeZoneInfo" /> 对象和另一个 <see cref="T:System.TimeZoneInfo" /> 对象是否相等。</summary>
        <returns>如果两个 <see cref="T:System.TimeZoneInfo" /> 对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相等性基于值的比较。 两个<xref:System.TimeZoneInfo>对象被视为等于在以下情况下：  
  
-   值及其<xref:System.TimeZoneInfo.Id%2A>属性相同时。  
  
-   它们具有相同的调整规则。  
  
 <xref:System.TimeZoneInfo.Equals%28System.TimeZoneInfo%29?displayProperty=nameWithType> 返回用于得出以下表达式的结果的布尔值：  
  
 ```csharp 
 other.Id == this.Id && HasSameRules(other);  
 ```
  
 ```vb
 other.Id = me.Id AndAlso HasSameRules(other)  
 ```

 如果`other`参数为未初始化<xref:System.TimeZoneInfo>对象，此方法将返回`false`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.TimeZoneInfo.Equals%28System.TimeZoneInfo%29>方法确定本地时区为太平洋时间或美国东部时间。  
  
 [!code-csharp[System.TimeZone2.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#7)]
 [!code-vb[System.TimeZone2.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSystemTimeZoneById">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo FindSystemTimeZoneById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.TimeZoneInfo FindSystemTimeZoneById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindSystemTimeZoneById (id As String) As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeZoneInfo ^ FindSystemTimeZoneById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="static member FindSystemTimeZoneById : string -&gt; TimeZoneInfo" Usage="System.TimeZoneInfo.FindSystemTimeZoneById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">时区标识符，它对应于 <see cref="P:System.TimeZoneInfo.Id" /> 属性。</param>
        <summary>根据其标识符从注册表中检索 <see cref="T:System.TimeZoneInfo" /> 对象。</summary>
        <returns>一个对象，其标识符为 <paramref name="id" /> 参数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`参数必须精确对应于时区的注册表项的长度，但不是在情况下，成功匹配发生; 也就是说，比较`id`时区标识符不区分大小写。 如果你想要检索时区对象基于部分匹配项，您可以编写使用的只读集合的自定义过程<xref:System.TimeZoneInfo>返回的对象<xref:System.TimeZoneInfo.GetSystemTimeZones%2A>方法。  
  
 <xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A> 尝试匹配`id`到 Windows XP 和 Windows Vista 下的注册表的 HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Time Zones 分支的子项名称。 此分支不一定包含时区标识符的完整列表。 如果所需的应用程序，您可以创建特定的时间区域通过调用的重载之一<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法或通过调用<xref:System.TimeZoneInfo.FromSerializedString%2A>要反序列化<xref:System.TimeZoneInfo>对象，表示所需的时间区域。 但是，通过这些方法调用的时区不包括在注册表中和不能使用检索<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法。 可以仅通过返回的对象引用访问这些自定义的时区<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>或<xref:System.TimeZoneInfo.FromSerializedString%2A>方法调用。  
  
   
  
## Examples  
 下面的示例使用<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法来检索东京标准时区。 这<xref:System.TimeZoneInfo>在东京中将本地时间转换为时间并确定它是东京标准时间还是东京夏时制时间，然后使用对象。  
  
 [!code-csharp[System.TimeZone2.Conversions#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Conversions/cs/convertdt2.cs#2)]
 [!code-vb[System.TimeZone2.Conversions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Conversions/vb/convertdt2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">系统没有足够的内存来存放有关时区的信息。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.TimeZoneNotFoundException">未找到 <paramref name="id" /> 指定的时区标识符。 这表示名称与 <paramref name="id" /> 匹配的注册表项不存在，或者该项存在但不包含任何时区数据。</exception>
        <exception cref="T:System.Security.SecurityException">该进程没有读取包含时区信息的注册表项所需的权限。</exception>
        <exception cref="T:System.InvalidTimeZoneException">时区标识符已找到，但注册表数据已损坏。</exception>
        <altmember cref="P:System.TimeZoneInfo.Id" />
      </Docs>
    </Member>
    <Member MemberName="FromSerializedString">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo FromSerializedString (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.TimeZoneInfo FromSerializedString(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.FromSerializedString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromSerializedString (source As String) As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeZoneInfo ^ FromSerializedString(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member FromSerializedString : string -&gt; TimeZoneInfo" Usage="System.TimeZoneInfo.FromSerializedString source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">已序列化的 <see cref="T:System.TimeZoneInfo" /> 对象的字符串表示形式。</param>
        <summary>反序列化一个字符串，以重新创建原始的已序列化的 <see cref="T:System.TimeZoneInfo" /> 对象。</summary>
        <returns>原始序列化对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 没有提供了创建时区，在注册表中找不到所需的所有代码的替代方法。 您可以定义自定义时区，然后使用<xref:System.TimeZoneInfo.ToSerializedString%2A>独立可执行文件或使用应用程序的安装程序也可以将时区保存为一个字符串中的方法。 应用程序然后可以从其存储位置检索此字符串并使用它进行实例化<xref:System.TimeZoneInfo.FromSerializedString%2A>方法。  
  
   
  
## Examples  
 下面的示例尝试检索南极从本地系统时区。 如果失败，该代码将尝试从应用程序目录中的文本文件中检索有关时区信息。 如果此尝试失败，代码将创建时区，并将有关时区信息写入到文本文件。  
  
 [!code-csharp[System.TimeZone2.CreateTimeZone#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/cs/System.TimeZone2.CreateTimeZone.cs#4)]
 [!code-vb[System.TimeZone2.CreateTimeZone#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/vb/System.TimeZone2.CreateTimeZone.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 参数为 <see cref="F:System.String.Empty" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 参数为空字符串。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">无法将源参数反序列化回 <see cref="T:System.TimeZoneInfo" /> 对象。</exception>
        <altmember cref="M:System.TimeZoneInfo.ToSerializedString" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjustmentRules">
      <MemberSignature Language="C#" Value="public TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.TimeZoneInfo/AdjustmentRule[] GetAdjustmentRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetAdjustmentRules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjustmentRules () As TimeZoneInfo.AdjustmentRule()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;TimeZoneInfo::AdjustmentRule ^&gt; ^ GetAdjustmentRules();" />
      <MemberSignature Language="F#" Value="member this.GetAdjustmentRules : unit -&gt; TimeZoneInfo.AdjustmentRule[]" Usage="timeZoneInfo.GetAdjustmentRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo+AdjustmentRule[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索应用至当前 <see cref="T:System.TimeZoneInfo" /> 对象的 <see cref="T:System.TimeZoneInfo.AdjustmentRule" /> 对象的数组。</summary>
        <returns>此时区的对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法检索数组<xref:System.TimeZoneInfo.AdjustmentRule?displayProperty=nameWithType>对象。 数组中的每个对象定义的该时区调整，以及其增量生效的开始和结束日期 （精确调整用来使要更改的时间量）。 此外，两个属性返回<xref:System.TimeZoneInfo.TransitionTime?displayProperty=nameWithType>定义每个每年何时从标准时间与转换发生时的对象。  
  
 如果时区具有多个调整规则，则通常按从最早 （位于索引 0 处） 到最新 (索引处<xref:System.Array.Length%2A>– 1)。  
  
 如果时区具有带调整规则，<xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法返回一个空数组 (数组的<xref:System.Array.Length%2A>为零)。  
  
 对返回的数组的元素进行任何修改<xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法不会反映在属于某个特定时区的调整规则。 要修改时区的调整规则 （例如，反映到 / 从夏令时其历史转换），必须使用适当的调整规则创建新的时区而修改现有的一个。  
  
   
  
## Examples  
 下面的示例检索有关其到控制台的调整规则的本地系统，并显示完整信息定义的所有时区。  
  
 [!code-csharp[System.TimeZone2.AdjustmentRule.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.AdjustmentRule.Class/cs/System.TimeZone2.AdjustmentRule.Class.cs#3)]
 [!code-vb[System.TimeZone2.AdjustmentRule.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.AdjustmentRule.Class/vb/System.TimeZone2.AdjustmentRule.Class.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">系统内存不足，无法在内存中创建调整规则副本。</exception>
        <altmember cref="T:System.TimeZoneInfo.AdjustmentRule" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAmbiguousTimeOffsets">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回不明确的日期和时间可能映射到的日期和时间的相关信息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAmbiguousTimeOffsets">
      <MemberSignature Language="C#" Value="public TimeSpan[] GetAmbiguousTimeOffsets (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan[] GetAmbiguousTimeOffsets(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetAmbiguousTimeOffsets(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;TimeSpan&gt; ^ GetAmbiguousTimeOffsets(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="member this.GetAmbiguousTimeOffsets : DateTime -&gt; TimeSpan[]" Usage="timeZoneInfo.GetAmbiguousTimeOffsets dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">日期和时间。</param>
        <summary>返回不明确的日期和时间可能映射到的日期和时间的相关信息。</summary>
        <returns>对象的数组，它表示特定日期和时间可以映射到的可能的协调世界时 (UTC) 偏移量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的确切行为取决于之间的关系<xref:System.DateTime.Kind%2A>属性和<xref:System.TimeZoneInfo>对象，如下表所示。  
  
|TimeZoneInfo 对象类型|Kind 属性值|行为|  
|------------------------------|-------------------------|--------------|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|<xref:System.DateTimeKind.Local?displayProperty=nameWithType> 或 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|返回不明确时间的偏移量`dateTime`。|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|将转换`dateTime`到本地时间，然后返回该时间的不明确的时间偏移量。|  
|<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>|任意值。|引发<xref:System.ArgumentException>。|  
|任何其他时区。|<xref:System.DateTimeKind.Local> 或 <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|将转换`dateTime`到指定的时区，然后确定该时间是否不明确。|  
|任何其他时区。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|确定是否`dateTime`中指定的时区不明确。|  
  
 顺序<xref:System.TimeSpan>未定义此方法返回的数组中的对象。 但是，可以确定哪些元素可表示时区的标准时间通过比较其值的时区偏移量<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性。 若要将不明确时间映射到时区的标准时间，请参阅[如何： 解决不明确时间](~/docs/standard/datetime/resolve-ambiguous-times.md)。  
  
   
  
## Examples  
 下面的示例定义一个名为方法`ShowPossibleUtcTimes`，它使用<xref:System.TimeZoneInfo.GetAmbiguousTimeOffsets%28System.DateTime%29>方法以将不明确时间映射到其对应的协调世界时 (UTC) 时间的可能。  
  
 [!code-csharp[System.TimeZone2.GetAmbiguousTimeOffsets#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.GetAmbiguousTimeOffsets/cs/System.TimeZone2.GetAmbiguousTimeOffsets.cs#1)]
 [!code-vb[System.TimeZone2.GetAmbiguousTimeOffsets#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.GetAmbiguousTimeOffsets/vb/System.TimeZone2.GetAmbiguousTimeOffsets.vb#1)]  
  
 然后可以使用类似以下的代码调用该方法：  
  
 [!code-csharp[System.TimeZone2.GetAmbiguousTimeOffsets#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.GetAmbiguousTimeOffsets/cs/System.TimeZone2.GetAmbiguousTimeOffsets.cs#2)]
 [!code-vb[System.TimeZone2.GetAmbiguousTimeOffsets#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.GetAmbiguousTimeOffsets/vb/System.TimeZone2.GetAmbiguousTimeOffsets.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 是明确的时间。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法仅将当前调整规则应用时确定是否<paramref name="dateTime" />是当前实例是否不明确的<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告当前的调整规则生效之前不明确时间偏移的量。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="Overload:System.TimeZoneInfo.IsAmbiguousTime" />
      </Docs>
    </Member>
    <Member MemberName="GetAmbiguousTimeOffsets">
      <MemberSignature Language="C#" Value="public TimeSpan[] GetAmbiguousTimeOffsets (DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan[] GetAmbiguousTimeOffsets(valuetype System.DateTimeOffset dateTimeOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetAmbiguousTimeOffsets(System.DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;TimeSpan&gt; ^ GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="F#" Value="member this.GetAmbiguousTimeOffsets : DateTimeOffset -&gt; TimeSpan[]" Usage="timeZoneInfo.GetAmbiguousTimeOffsets dateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">日期和时间。</param>
        <summary>返回不明确的日期和时间可能映射到的日期和时间的相关信息。</summary>
        <returns>对象的数组，它表示特定日期和时间可以映射到的可能的协调世界时 (UTC) 偏移量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的确切行为取决于之间的关系<xref:System.DateTimeOffset.Offset%2A>的属性`dateTimeOffset`参数和<xref:System.TimeZoneInfo>对象。 如果的值<xref:System.DateTimeOffset.Offset%2A>属性对应于当前时区的可能的偏移量从协调世界时 (UTC) 的日期和时间，该方法将返回可能的偏移量。 否则，它将为`dateTimeOffset`当前所在的时区，然后返回的可能偏移量的时间的日期和时间。  
  
 顺序<xref:System.TimeSpan>未定义此方法返回的数组中的对象。 但是，可以确定哪些元素可表示时区的标准时间通过比较其值的时区偏移量<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性。 若要将不明确时间映射到时区的标准时间，请参阅[如何： 解决不明确时间](~/docs/standard/datetime/resolve-ambiguous-times.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTimeOffset" /> 是明确的时间。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法仅将当前调整规则应用时确定是否<paramref name="dateTimeOffset" />是当前实例是否不明确的<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告当前的调整规则生效之前不明确时间偏移的量。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="M:System.TimeZoneInfo.IsAmbiguousTime(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="timeZoneInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>用作哈希算法的哈希函数和数据结构（如哈希表）。</summary>
        <returns>一个 32 位有符号整数，用作此 <see cref="T:System.TimeZoneInfo" /> 对象的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关更多详细信息<xref:System.TimeZoneInfo.GetHashCode%2A>方法，请参阅<xref:System.Object.GetHashCode%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSystemTimeZones">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;TimeZoneInfo&gt; GetSystemTimeZones ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.TimeZoneInfo&gt; GetSystemTimeZones() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetSystemTimeZones" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSystemTimeZones () As ReadOnlyCollection(Of TimeZoneInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;TimeZoneInfo ^&gt; ^ GetSystemTimeZones();" />
      <MemberSignature Language="F#" Value="static member GetSystemTimeZones : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;TimeZoneInfo&gt;" Usage="System.TimeZoneInfo.GetSystemTimeZones " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.TimeZoneInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回时区信息在本地系统上可用的所有时区的已排序集合。</summary>
        <returns>
          <see cref="T:System.TimeZoneInfo" /> 对象的只读集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.TimeZoneInfo.GetSystemTimeZones%2A>方法从注册表的 HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Time Zones 项的子项中检索所有可用的时区信息。 如果无法成功检索和分析的特定字符串属性的单个值<xref:System.TimeZoneInfo>对象，此方法将其值设置为空字符串 ("")。  
  
> [!IMPORTANT]
>  <xref:System.TimeZoneInfo.GetSystemTimeZones%2A>方法返回的集合<xref:System.TimeZoneInfo>对象仅在注册表中定义的时区。 它不包括使用的重载创建时区<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法。 它们只能通过时区创建方法返回的对象引用。  
  
 此方法返回的集合被按 UTC 偏移量，并且对于具有相同的 UTC 偏移量的时间范围按使用当前区域性的显示名称。 显示名称的信息，请参阅<xref:System.TimeZoneInfo.DisplayName%2A>。  
  
 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>此方法返回的对象支持<xref:System.Collections.Generic.IEnumerable%601>接口，这意味着可以使用迭代它`foreach`（在 C# 中) 或`For Each…Next`（在 Visual Basic) 语句。 循环每次迭代提供下一步<xref:System.TimeZoneInfo>集合中的对象。  
  
 集合<xref:System.TimeZoneInfo>对象表示本地计算机上定义的时区; 它不一定提供所有时间段内所有时区的完整信息。 如果应用程序需要在本地计算机上找不到的时区，则可以创建自定义时区使用的重载<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法。 有关详细信息，请参阅[如何： 创建调整规则无需时区](~/docs/standard/datetime/create-time-zones-without-adjustment-rules.md)并[如何： 创建时间的时区调整规则](~/docs/standard/datetime/create-time-zones-with-adjustment-rules.md)。  
  
 您还可以确定各个时区本地计算机上通过调用定义<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法并提供你想要作为参数检索时区的标识符。  
  
   
  
## Examples  
 下面的示例检索表示在计算机上定义的时区的时区对象的集合，并将它们的相关信息写入到文本文件。  
  
 [!code-csharp[System.TimeZone2.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/getsystemtimezones1.cs#6)]
 [!code-vb[System.TimeZone2.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/getsystemtimezones1.vb#6)]
  [!code-powershell[System.TimeZone2.Class#6](~/samples/snippets/powershell/VS_Snippets_CLR_System/System.TimeZone2.Class/PS/Timezone2_Examples.ps1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">没有足够的内存来存储所有的时区信息。</exception>
        <exception cref="T:System.Security.SecurityException">用户无权读取包含时区信息的注册表项。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUtcOffset">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>计算此时区中的时间与协调世界时 (UTC) 之间针对特定日期和时间的偏移量或差值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUtcOffset">
      <MemberSignature Language="C#" Value="public TimeSpan GetUtcOffset (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetUtcOffset(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetUtcOffset(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetUtcOffset(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="member this.GetUtcOffset : DateTime -&gt; TimeSpan" Usage="timeZoneInfo.GetUtcOffset dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">要为其确定偏移量的日期和时间。</param>
        <summary>计算此时区中的时间与协调世界时 (UTC) 之间针对特定日期和时间的偏移量或差值。</summary>
        <returns>一个对象，该对象指示两个时区之间的时差。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的时间跨度包括应用到当前时区的调整规则导致的任何差异。 它不同于<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性，它返回协调世界时 (UTC) 和时区的标准时间之间的差异，因此，不考虑调整规则。  
  
 如果`dateTime`参数的<xref:System.DateTime.Kind%2A>属性不对应时区对象，此方法将执行必要的转换之前返回的结果。 例如，发生这种情况<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>但时区对象不是本地时区。 如果`dateTime`不明确，或如果不明确转换后的时间，此方法会解释为标准时间的不明确时间。 如果`dateTime`是无效的此方法返回<xref:System.TimeSpan>反映 UTC 与时区的标准时间之间的差异的对象。  
  
 <xref:System.TimeZoneInfo.GetUtcOffset%28System.DateTime%29?displayProperty=nameWithType>方法是在对操作类似<xref:System.TimeZone.GetUtcOffset%2A>方法的<xref:System.TimeZone>类。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.TimeZoneInfo.GetUtcOffset%28System.DateTime%29>方法使用不同的时区和具有不同的日期值<xref:System.DateTime.Kind%2A>属性值。  
  
 [!code-csharp[System.TimeZone2.GetUtcOffset#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.GetUtcOffset/cs/System.TimeZone2.GetUtcOffset.cs#1)]
 [!code-vb[System.TimeZone2.GetUtcOffset#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.GetUtcOffset/vb/System.TimeZone2.GetUtcOffset.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用只是将当前的调整规则计算当前实例是否与 UTC 的偏移量时<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能会不准确地计算本地时间与 UTC 之间的差异上<paramref name="dateTime" />。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="P:System.TimeZoneInfo.BaseUtcOffset" />
      </Docs>
    </Member>
    <Member MemberName="GetUtcOffset">
      <MemberSignature Language="C#" Value="public TimeSpan GetUtcOffset (DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetUtcOffset(valuetype System.DateTimeOffset dateTimeOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.GetUtcOffset(System.DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="F#" Value="member this.GetUtcOffset : DateTimeOffset -&gt; TimeSpan" Usage="timeZoneInfo.GetUtcOffset dateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">要为其确定偏移量的日期和时间。</param>
        <summary>计算此时区中的时间与协调世界时 (UTC) 之间针对特定日期和时间的偏移量或差值。</summary>
        <returns>一个对象，该对象指示协调世界时 (UTC) 与当前时区之间的时差。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的时间跨度包括应用到当前时区的调整规则导致的任何差异。 它不同于<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性，它返回协调世界时 (UTC) 和时区的标准时间之间的差异，因此，不考虑调整规则。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用只是将当前的调整规则计算当前实例是否与 UTC 的偏移量时<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能会不准确地计算本地时间与 UTC 之间的差异上<paramref name="dateTimeOffset" />。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasSameRules">
      <MemberSignature Language="C#" Value="public bool HasSameRules (TimeZoneInfo other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasSameRules(class System.TimeZoneInfo other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.HasSameRules(System.TimeZoneInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasSameRules (other As TimeZoneInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasSameRules(TimeZoneInfo ^ other);" />
      <MemberSignature Language="F#" Value="member this.HasSameRules : TimeZoneInfo -&gt; bool" Usage="timeZoneInfo.HasSameRules other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.TimeZoneInfo" />
      </Parameters>
      <Docs>
        <param name="other">要与当前的 <see cref="T:System.TimeZoneInfo" /> 对象进行比较的第二个对象。</param>
        <summary>指示当前对象和另一个 <see cref="T:System.TimeZoneInfo" /> 对象是否具有相同的调整规则。</summary>
        <returns>如果两个时区具有相同的调整规则和相同的基本偏移量，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 像<xref:System.TimeZoneInfo.Equals%28System.TimeZoneInfo%29?displayProperty=nameWithType>方法，<xref:System.TimeZoneInfo.HasSameRules%2A>方法指示两个时区是否具有相同的基本偏移量 (由定义<xref:System.TimeZoneInfo.BaseUtcOffset%2A>属性) 和相同的调整规则。 与不同<xref:System.TimeZoneInfo.Equals%28System.TimeZoneInfo%29?displayProperty=nameWithType>方法，<xref:System.TimeZoneInfo.HasSameRules%2A>不会比较时区标识符 (由定义<xref:System.TimeZoneInfo.Id%2A>属性)。  
  
   
  
## Examples  
 通常情况下，多个注册表中定义的时间区域具有相同的偏移量从协调世界时 (UTC) 和相同的调整规则。 下面的示例向控制台显示这些时间区域的列表。  
  
 [!code-csharp[System.TimeZone2.HasSameRules#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.HasSameRules/cs/HasSameRules.cs#1)]
 [!code-vb[System.TimeZone2.HasSameRules#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.HasSameRules/vb/HasSameRules.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.TimeZoneInfo.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取时区标识符。</summary>
        <value>时区标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 时区标识符是唯一标识特定时区的键字符串。 在 Windows XP 和 Windows Vista 中，它对应于注册表的 HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Time 区域分支的子项。 它可以作为参数传递<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法来从注册表检索某个特定时区。  
  
> [!IMPORTANT]
>  尽管 Windows 注册表中的密钥名称最多可包含 255 个字符，但我们建议你将分配给自定义时区的标识符，是 32 个字符或更少。 标识符的时间越长，概率就越大，不正确的密钥名称将为检索它时提供。  
  
 值<xref:System.TimeZoneInfo.Id%2A>属性是通常情况下，但并不总是相同<xref:System.TimeZoneInfo.StandardName%2A>属性。 协调世界时时区的标识符是 UTC。  
  
   
  
## Examples  
 下面的示例列出了每个本地计算机上定义的时区的标识符。  
  
 [!code-csharp[System.TimeZone2.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#5)]
 [!code-vb[System.TimeZone2.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAmbiguousTime">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定特定时区中的特定日期和时间是否不明确以及是否可以映射至两个或多个协调世界时 (UTC) 时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAmbiguousTime">
      <MemberSignature Language="C#" Value="public bool IsAmbiguousTime (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAmbiguousTime(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.IsAmbiguousTime(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAmbiguousTime(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="member this.IsAmbiguousTime : DateTime -&gt; bool" Usage="timeZoneInfo.IsAmbiguousTime dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">日期和时间值。</param>
        <summary>确定特定时区中的特定日期和时间是否不明确以及是否可以映射至两个或多个协调世界时 (UTC) 时间。</summary>
        <returns>如果 <paramref name="dateTime" /> 参数不明确，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不明确时间之内的当前时区的时间范围。 这意味着它可以是标准时间或调整规则的应用程序而得出的时间。 通常情况下，时钟设置为从夏时制返回到标准时间时，将导致不明确时间。 请参阅示例部分的说明。  
  
 协调世界时 (UTC) 具有不明确的时间;既不执行操作的时间不支持夏时制的区域。 因此，这些时间的时区有没有调整规则，并且调用<xref:System.TimeZoneInfo.IsAmbiguousTime%2A>方法将始终返回`false`。  
  
 对于确实发现夏令时的时区，此方法的确切行为取决于之间的关系<xref:System.DateTime.Kind%2A>属性和<xref:System.TimeZoneInfo>对象，如下表所示。  
  
|TimeZoneInfo 对象类型|Kind 属性值|行为|  
|------------------------------|-------------------------|--------------|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|<xref:System.DateTimeKind.Local?displayProperty=nameWithType> 或 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|确定是否`dateTime`参数不明确。|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|将转换`dateTime`为本地时间，然后确定该时间是否不明确。|  
|<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType> 或 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|返回 `false`。|  
|<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|如果`dateTime`不明确，则假定它是标准时间，将其转换为 UTC，并返回`false`。|  
|任何其他时区。|<xref:System.DateTimeKind.Local?displayProperty=nameWithType> 或 <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|将转换`dateTime`为指定的时区中的时间，然后确定该时间是否不明确。|  
|任何其他时区。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|确定是否`dateTime`不明确。|  
  
   
  
## Examples  
 在太平洋时区中夏时制结束于凌晨 2:00。 2007 年 11 月 4日日。 下面的示例按一分钟时间间隔从凌晨 12:59 传递时间 2007 年 11 月 4日日到凌晨 2:01 2007 年 11 月 4 日，向<xref:System.TimeZoneInfo.IsAmbiguousTime%28System.DateTime%29>方法的<xref:System.TimeZoneInfo>对象，表示太平洋时区。 控制台输出指示从凌晨 1:00 2007 年 11 月 4日日至凌晨 1:59 2007 年 11 月 4 日，是不明确。  
  
 [!code-csharp[System.TimeZone2.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#8)]
 [!code-vb[System.TimeZone2.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 值的 <see cref="P:System.DateTime.Kind" /> 属性的值为 <see cref="F:System.DateTimeKind.Local" />，而 <paramref name="dateTime" /> 是无效时间。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅在当前的调整规则的当前实例是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告是否<paramref name="dateTime" />是当前的调整规则生效之前的时间不明确时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="IsAmbiguousTime">
      <MemberSignature Language="C#" Value="public bool IsAmbiguousTime (DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAmbiguousTime(valuetype System.DateTimeOffset dateTimeOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.IsAmbiguousTime(System.DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="F#" Value="member this.IsAmbiguousTime : DateTimeOffset -&gt; bool" Usage="timeZoneInfo.IsAmbiguousTime dateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">日期和时间。</param>
        <summary>确定特定时区中的特定日期和时间是否不明确以及是否可以映射至两个或多个协调世界时 (UTC) 时间。</summary>
        <returns>如果 <paramref name="dateTimeOffset" /> 参数在当前时区中不明确，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不明确时间之内的当前时区的时间范围。 这意味着它可以是标准时间或时间调整规则的应用程序而得出的。 通常情况下，时钟设置为从夏时制返回到标准时间时，将导致不明确时间。 协调世界时 (UTC) 具有不明确的时间;既不执行操作的时间不支持夏时制的区域。  
  
 该方法的确切行为取决于之间的关系<xref:System.DateTimeOffset.Offset%2A>属性的`dateTimeOffset`参数和当前所在的时区。 如果的值<xref:System.DateTimeOffset.Offset%2A>属性为可能发生的当前时区 UTC 偏移量，该方法确定是否该日期和时间不明确。 否则，它将为`dateTimeOffset`设为以当前所在的时区，时间，然后确定是否该日期和时间不明确。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅在当前的调整规则的当前实例是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告是否<paramref name="dateTimeOffset" />是当前的调整规则生效之前的时间不明确时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDaylightSavingTime">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示指定的日期和时间是否处于当前 <see cref="T:System.TimeZoneInfo" /> 对象时区的夏令制范围内。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool IsDaylightSavingTime (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDaylightSavingTime(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDaylightSavingTime(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="member this.IsDaylightSavingTime : DateTime -&gt; bool" Usage="timeZoneInfo.IsDaylightSavingTime dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">日期和时间值。</param>
        <summary>指示指定的日期和时间是否处于当前 <see cref="T:System.TimeZoneInfo" /> 对象时区的夏令制范围内。</summary>
        <returns>如果 <paramref name="dateTime" /> 参数为夏令制，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值<xref:System.TimeZoneInfo.IsDaylightSavingTime%2A?displayProperty=nameWithType>所表示的时区之间的关系影响<xref:System.TimeZoneInfo>对象和<xref:System.DateTime.Kind%2A>属性的`dateTime`参数，如下表所示。  
  
|TimeZoneInfo 对象|DateTime.Kind 属性|结果|  
|-------------------------|----------------------------|------------|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|`DateTimeKind.Local`|确定是否`dateTime`是夏时制。|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|`DateTimeKind.Utc`|将转换`dateTime`与协调世界时 (UTC) 为本地时间，并确定它是否为夏时制。|  
|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|`DateTimeKind.Unspecified`|假定`dateTime`表示本地时间，并确定它是否为夏时制。|  
|<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>|`DateTimeKind.Local`、`DateTimeKind.Unspecified` 或 `DateTimeKind.Utc`|返回`false`（UTC 不支持夏时制）。|  
|任何其他<xref:System.TimeZoneInfo>对象。|`DateTimeKind.Local`|将本地时间转换为等效的时间<xref:System.TimeZoneInfo>对象，然后确定是否后者为夏时制。|  
|任何其他<xref:System.TimeZoneInfo>对象。|`DateTimeKind.Utc`|将 UTC 转换为等效的时间的<xref:System.TimeZoneInfo>对象，然后确定是否后者为夏时制。|  
|任何其他<xref:System.TimeZoneInfo>对象。|`DateTimeKind.Unspecified`|确定是否`dateTime`是夏时制。|  
  
 如果由表示时区<xref:System.TimeZoneInfo>对象不支持夏令时，此方法始终返回`false`。 大量的时间区域，其中包括<xref:System.TimeZoneInfo.Utc%2A>，不会依循夏时制。  若要确定是否时区支持夏令时，检索的值及其<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A>属性。  
  
 如果`dateTime`参数指定在当前对象的时间区域中，将不明确时间<xref:System.TimeZoneInfo.IsDaylightSavingTime%2A?displayProperty=nameWithType>方法将解释`dateTime`作为标准时间，并返回`false`如果其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. 如果<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，此方法将选择正确的不明确时间，并且指示它是否是夏令时时间。  
  
 因为<xref:System.TimeZoneInfo.IsDaylightSavingTime%28System.DateTime%29?displayProperty=nameWithType>方法可返回`false`日期和时间不明确的 （即，日期和时间，可以表示标准时间还是夏令时中特定时区中），<xref:System.TimeZoneInfo.IsAmbiguousTime%28System.DateTime%29?displayProperty=nameWithType>可以搭配方法<xref:System.TimeZoneInfo.IsDaylightSavingTime%28System.DateTime%29>方法，以确定时间是否可能是夏令时时间。 不明确时间是指可以是夏令时和标准时间，因为<xref:System.TimeZoneInfo.IsAmbiguousTime%28System.DateTime%29>可以首先调用方法来确定日期和时间可能会是夏令时时间。 如果该方法返回`false`，则<xref:System.TimeZoneInfo.IsDaylightSavingTime%28System.DateTime%29>可以调用方法以确定是否<xref:System.DateTime>值是否为夏时制时间。 下面的示例演示此方法。  
  
 [!code-csharp[System.TimeZone2.IsDaylightSavingTime#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/cs/IsDaylightSavingTime.cs#2)]
 [!code-vb[System.TimeZone2.IsDaylightSavingTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/vb/IsDaylightSavingTime.vb#2)]  
  
 如果`dateTime`参数指定无效的时间，则方法调用将引发<xref:System.ArgumentException>如果的值`dateTime`参数的<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>; 否则为该方法将返回`false`。  
  
 调用<xref:System.TimeZoneInfo.IsDaylightSavingTime%2A?displayProperty=nameWithType>方法，以确定是否使用时区<xref:System.TimeZoneInfo.StandardName%2A>值或其<xref:System.TimeZoneInfo.DaylightName%2A>值时显示的时区名称。 请参阅示例部分的说明。  
  
   
  
## Examples  
 下面的示例定义一个名为方法`DisplayDateWithTimeZoneName`，它使用<xref:System.TimeZoneInfo.IsDaylightSavingTime%2A?displayProperty=nameWithType>方法，以确定是否显示时区的标准时间名称或夏令时名称。  
  
 [!code-csharp[System.TimeZone2.IsDaylightSavingTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/cs/IsDaylightSavingTime.cs#1)]
 [!code-vb[System.TimeZone2.IsDaylightSavingTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/vb/IsDaylightSavingTime.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime" /> 值的 <see cref="P:System.DateTime.Kind" /> 属性的值为 <see cref="F:System.DateTimeKind.Local" />，而 <paramref name="dateTime" /> 是无效时间。</exception>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅在当前的调整规则的当前实例是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告是否<paramref name="dateTime" />之前当前的调整规则生效时间内是夏令时。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="P:System.TimeZoneInfo.SupportsDaylightSavingTime" />
      </Docs>
    </Member>
    <Member MemberName="IsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool IsDaylightSavingTime (DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDaylightSavingTime(valuetype System.DateTimeOffset dateTimeOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);" />
      <MemberSignature Language="F#" Value="member this.IsDaylightSavingTime : DateTimeOffset -&gt; bool" Usage="timeZoneInfo.IsDaylightSavingTime dateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">日期和时间值。</param>
        <summary>指示指定的日期和时间是否处于当前 <see cref="T:System.TimeZoneInfo" /> 对象时区的夏令制范围内。</summary>
        <returns>如果 <paramref name="dateTimeOffset" /> 参数为夏令制，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值<xref:System.TimeZoneInfo.IsDaylightSavingTime%2A?displayProperty=nameWithType>所表示的时区之间的关系影响<xref:System.TimeZoneInfo>对象和<xref:System.DateTimeOffset.Offset%2A>属性的`dateTimeOffset`参数。 如果`dateTimeOffset`不对应于当前时区的偏移量从协调世界时 (UTC)，该方法将转换的时间中当前时区的时间。 然后，它确定是否该日期和时间夏时制节省时间。  
  
 如果由表示时区<xref:System.TimeZoneInfo>对象不支持夏令时，此方法始终返回`false`。 若要确定是否时区支持夏令时，检索的值及其<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A>属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅在当前的调整规则的当前实例是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告是否<paramref name="dateTimeOffset" />之前当前的调整规则生效时间内是夏令时。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="P:System.TimeZoneInfo.SupportsDaylightSavingTime" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalidTime">
      <MemberSignature Language="C#" Value="public bool IsInvalidTime (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInvalidTime(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInvalidTime(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="member this.IsInvalidTime : DateTime -&gt; bool" Usage="timeZoneInfo.IsInvalidTime dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">日期和时间值。</param>
        <summary>指示特定日期和时间是否无效。</summary>
        <returns>如果 <paramref name="dateTime" /> 无效，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 无效的时间之内的无法映射为协调世界时 (UTC) 由于调整规则的应用程序在当前时区的时间范围。 通常情况下，当时间继续移动夏时制时会出现无效时间。 请参阅示例部分的说明。  
  
 值<xref:System.DateTime.Kind%2A>的属性`dateTime`参数会影响是否`dateTime`表示无效的时间，如下表所示。  
  
|DateTime.Kind 属性|TimeZoneInfo 对象 （如果适用）|行为|  
|----------------------------|-------------------------------------------|--------------|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>|确定时间是否无效。|  
|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType> 或本地时间区域。|将转换`dateTime`的时间<xref:System.TimeZoneInfo>对象，并返回`false`。|  
|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|不适用。|假定`dateTime`的时间<xref:System.TimeZoneInfo>对象，并确定它是否无效。|  
|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|不适用。|返回 `false`。|  
  
   
  
## Examples  
 在太平洋时区，夏时制开始在凌晨 2:00 2006 年 4 月 2日日。 下面的代码在一分钟时间间隔从凌晨 1:59 传递时间 2006 年 4 月 2日日，上午 3:01 到 2006 年 4 月 2 日，向<xref:System.TimeZoneInfo.IsInvalidTime%2A>方法的<xref:System.TimeZoneInfo>对象，表示太平洋时区。 控制台输出指示从凌晨 2:00 2006 年 4 月 2日日至凌晨 2:59 2006 年 4 月 2 日均无效。  
  
 [!code-csharp[System.TimeZone2.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#9)]
 [!code-vb[System.TimeZone2.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#9)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统中，此方法适用于仅调整规则的当前实例是<see cref="P:System.TimeZoneInfo.Local" />。因此，该方法可能无法准确报告是否<paramref name="dateTime" />是无效之前当前的调整规则生效的时间。有关详细信息，请参阅中的调用方部分的说明<see cref="P:System.TimeZoneInfo.Local" />属性。</para>
        </block>
        <altmember cref="Overload:System.TimeZoneInfo.IsAmbiguousTime" />
      </Docs>
    </Member>
    <Member MemberName="Local">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo Local { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.TimeZoneInfo Local" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.Local" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Local As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeZoneInfo ^ Local { TimeZoneInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Local : TimeZoneInfo" Usage="System.TimeZoneInfo.Local" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示本地时区的 <see cref="T:System.TimeZoneInfo" /> 对象。</summary>
        <value>一个对象，表示本地时区。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地时区是执行代码的计算机上的时区。  
  
> [!IMPORTANT]
>  您应始终访问通过本地时区<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>属性，而不是无需分配本地时间时区分配给<xref:System.TimeZoneInfo>对象变量。 这可以防止<xref:System.TimeZoneInfo>调用而失效的对象变量<xref:System.TimeZoneInfo.ClearCachedData%2A>方法。  
  
 <xref:System.TimeZoneInfo>返回的对象<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>属性会反映出的设置**自动调整为夏时制的时钟**复选框或**自动调整为夏时制保存时钟时间**控制面板中的复选框**日期和时间**适用于 Windows XP 和 Windows Vista 应用程序分别。 如果未选中该复选框，则本地时区的缓存的副本不包含夏令时信息。 这表示：  
  
-   本地时区的<xref:System.TimeZoneInfo.GetAdjustmentRules%2A>方法返回一个数组，其长度为零。  
  
-   本地时区的<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A>属性返回`false`。  
  
-   本地时区具有不明确或无效时间 (所有调用的<xref:System.TimeZoneInfo.IsAmbiguousTime%2A>或<xref:System.TimeZoneInfo.IsInvalidTime%2A>返回`false`)。  
  
-   对所有调用<xref:System.TimeZoneInfo.IsDaylightSavingTime%2A>各个本地时间返回 false。  
  
 这是不为 true，但是，如果使用检索到的本地时区的引用<xref:System.TimeZoneInfo.FindSystemTimeZoneById%2A>方法。  
  
 <xref:System.TimeZoneInfo.Local%2A>属性对应于<xref:System.TimeZone.CurrentTimeZone%2A>属性的<xref:System.TimeZone>类。  
  
   
  
## Examples  
 下面的示例检索<xref:System.TimeZoneInfo>对象，表示本地时区，并输出其显示名称、 标准时间名称和夏时制名称。  
  
 [!code-csharp[System.TimeZone2.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/ShowTimeZoneNames1.cs#2)]
 [!code-vb[System.TimeZone2.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/ShowTimeZoneNames1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>在转换日期和时间，[!INCLUDE[winxp](~/includes/winxp-md.md)]识别仅当前调整规则，并将其应用到所有日期，包括低级别日期 （即早于当前的调整规则的开始日期的日期）。上[!INCLUDE[winxp](~/includes/winxp-md.md)]，以防止本地日期和时间信息由提供<see cref="P:System.TimeZoneInfo.Local" />背离系统任务栏中显示的日期和时间信息的对象<see cref="T:System.TimeZoneInfo" />返回的对象<see cref="P:System.TimeZoneInfo.Local" />属性也适用低级别日期到当前的调整规则。运行的应用程序[!INCLUDE[winxp](~/includes/winxp-md.md)]需要从历史上看准确的本地日期和时间计算通过使用必须解决此行为<see cref="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" />方法来检索<see cref="T:System.TimeZoneInfo" />对应于本地时区的对象。下面的示例说明了为[!INCLUDE[winxp](~/includes/winxp-md.md)]位于美国。由于前三个方法调用所有使用返回的本地时区<see cref="P:System.TimeZoneInfo.Local" />属性，它们不适用于当前时区调整规则 （这在 2007 年开始生效） 2006年中的日期。当前的调整规则提供到夏时制的年 3 月; 第二个星期日发生的转换上一个规则，这实际上是在 2006 年，提供为夏时制年 4 月的第一个星期日发生转换。仅第四个方法调用，它使用<see cref="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" />方法来检索本地时区，准确地执行此历史日期和时间的转换。 [！ 代码 csharp[System.TimeZoneInfo.ConvertTimeToUtc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timezoneinfo.converttimetoutc/cs/converttimetoutc.cs#1)] [！ 代码 vb[System.TimeZoneInfo.ConvertTimeToUtc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timezoneinfo.converttimetoutc/vb/converttimetoutc.vb#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="StandardName">
      <MemberSignature Language="C#" Value="public string StandardName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StandardName" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.StandardName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StandardName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardName : string" Usage="System.TimeZoneInfo.StandardName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取时区的标准时间的显示名称。</summary>
        <value>时区的标准时间的显示名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据随 Windows 操作系统一起安装的区域性进行本地化的显示名称。  
  
 <xref:System.TimeZoneInfo.StandardName%2A>属性等于<xref:System.TimeZone.StandardName%2A>属性的<xref:System.TimeZone>类。  
  
 如果在操作系统语言为英语的值<xref:System.TimeZoneInfo.StandardName%2A>属性是通常情况下，但并不总是相同<xref:System.TimeZoneInfo.Id%2A>属性。  
  
   
  
## Examples  
 下面的示例定义一个名为方法`DisplayDateWithTimeZoneName`，它使用<xref:System.TimeZoneInfo.IsDaylightSavingTime%28System.DateTime%29>方法，以确定是否显示时区的标准时间名称或夏令时名称。  
  
 [!code-csharp[System.TimeZone2.IsDaylightSavingTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/cs/IsDaylightSavingTime.cs#1)]
 [!code-vb[System.TimeZone2.IsDaylightSavingTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.IsDaylightSavingTime/vb/IsDaylightSavingTime.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool SupportsDaylightSavingTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsDaylightSavingTime" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.SupportsDaylightSavingTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsDaylightSavingTime As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsDaylightSavingTime { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsDaylightSavingTime : bool" Usage="System.TimeZoneInfo.SupportsDaylightSavingTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示时区是否具有任何夏令制规则。</summary>
        <value>如果时区支持夏令制，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A>属性返回的本地时区<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>属性反映控件面板设置**日期和时间**定义的应用程序的复选框是否系统自动针对夏令时进行调整。 如果未选中，或如果时间区域不显示任何复选框，则此属性的值是`false`。  
  
   
  
## Examples  
 下面的示例检索所有本地系统上可用的时区的集合，并显示这些不支持夏令时名称。  
  
 [!code-csharp[System.TimeZone2.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#4)]
 [!code-vb[System.TimeZone2.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#4)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">启动回调的对象。 当前未实现该参数的功能。</param>
        <summary>在对象的反序列化完成时运行。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <see cref="T:System.TimeZoneInfo" /> 对象包含无效数据或损坏的数据。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">要填充数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
        <param name="context">此序列化的目标（请参见 <see cref="T:System.Runtime.Serialization.StreamingContext" />）。</param>
        <summary>使用序列化当前的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象所需的所有数据填充 <see cref="T:System.TimeZoneInfo" /> 对象。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ToSerializedString">
      <MemberSignature Language="C#" Value="public string ToSerializedString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToSerializedString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ToSerializedString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToSerializedString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToSerializedString();" />
      <MemberSignature Language="F#" Value="member this.ToSerializedString : unit -&gt; string" Usage="timeZoneInfo.ToSerializedString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前的 <see cref="T:System.TimeZoneInfo" /> 对象转换为序列化字符串。</summary>
        <returns>表示当前 <see cref="T:System.TimeZoneInfo" /> 对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖于的 Windows 系统注册表中通常不定义的时区应用程序可以使用<xref:System.TimeZoneInfo.CreateCustomTimeZone%2A>方法来实例化必要的时间区域<xref:System.TimeZoneInfo>对象。 然后，应用程序可以调用<xref:System.TimeZoneInfo.ToSerializedString%2A>方法，将时区对象转换为字符串。  
  
 <xref:System.TimeZoneInfo>对象也存储在其中应用程序中检索它时所需的位置。 可能的位置包括：  
  
-   在注册表中。  
  
-   应用程序资源文件。  
  
-   外部文件，例如文本文件。  
  
   
  
## Examples  
 下面的示例尝试检索南极从本地系统时区。 如果失败，该代码将尝试从应用程序目录中的文本文件中检索有关时区信息。 如果此尝试失败，代码将创建时区，并将其相关信息写入到文本文件。  
  
 [!code-csharp[System.TimeZone2.CreateTimeZone#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/cs/System.TimeZone2.CreateTimeZone.cs#4)]
 [!code-vb[System.TimeZone2.CreateTimeZone#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.CreateTimeZone/vb/System.TimeZone2.CreateTimeZone.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.TimeZoneInfo.FromSerializedString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TimeZoneInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="timeZoneInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前 <see cref="T:System.TimeZoneInfo" /> 对象的显示名称。</summary>
        <returns>当前 <see cref="T:System.TimeZoneInfo" /> 对象的 <see cref="P:System.TimeZoneInfo.DisplayName" /> 属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当将集合分配包含<xref:System.TimeZoneInfo>如对象添加到列表控件<xref:System.Windows.Forms.ListBox>控件，该控件会自动调用<xref:System.TimeZoneInfo.ToString%2A>方法提取一个字符串，描述每个对象表示在列表中。 结果是，不需要将对象的有意义说明存储为一个字符串，并且用户无需使用该字符串从集合中提取对象。 请参阅[如何： 枚举存在于计算机上的时区](~/docs/standard/datetime/enumerate-time-zones.md)以了解详细信息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Utc">
      <MemberSignature Language="C#" Value="public static TimeZoneInfo Utc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.TimeZoneInfo Utc" />
      <MemberSignature Language="DocId" Value="P:System.TimeZoneInfo.Utc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Utc As TimeZoneInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeZoneInfo ^ Utc { TimeZoneInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Utc : TimeZoneInfo" Usage="System.TimeZoneInfo.Utc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeZoneInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示协调世界时 (UTC) 区域的 <see cref="T:System.TimeZoneInfo" /> 对象。</summary>
        <value>一个对象，表示协调世界时 (UTC) 区域。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个内置的对象;此类信息<xref:System.TimeZoneInfo>从注册表检索不到对象。  
  
> [!IMPORTANT]
>  您应始终访问通过协调世界时 (UTC) 区域<xref:System.TimeZoneInfo.Utc%2A?displayProperty=nameWithType>属性，而无需分配到 UTC 时区<xref:System.TimeZoneInfo>对象变量。 这可以防止<xref:System.TimeZoneInfo>调用而失效的对象变量<xref:System.TimeZoneInfo.ClearCachedData%2A>方法。  
  
 协调世界时是以前称为格林威治标准时间 (GMT)。  
  
   
  
## Examples  
 下面的示例检索<xref:System.TimeZoneInfo>对象，表示协调世界时 (UTC)，并输出其显示名称、 标准时间名称和夏时制名称。  
  
 [!code-csharp[System.TimeZone2.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TimeZone2.Class/CS/TimeZone2_Examples.cs#3)]
 [!code-vb[System.TimeZone2.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TimeZone2.Class/VB/TimeZone2_Examples.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>