<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="38641ff6378db3185a6ea1951a0568cfbe5d9774" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39887089" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供统一资源标识符 (URI) 的对象表示形式和对 URI 各部分的轻松访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI 是可用于在 intranet 或 Internet 上的应用程序资源的简洁表示形式。 <xref:System.Uri>类定义的属性和方法来处理 Uri，包括分析、 比较和合并。 <xref:System.Uri>类属性是只读的; 若要创建一个可修改的对象，使用<xref:System.UriBuilder>类。  
  
 相对 Uri (例如，"/ new/index.htm")，以便它们绝对必须展开相对于基 URI。 <xref:System.Uri.MakeRelative%2A>方法提供要转换为在必要时的相对 Uri 的绝对 Uri。  
  
 <xref:System.Uri>构造函数字符串是否格式正确的 URI，包括方案标识符未转义 URI 字符串。  
  
 <xref:System.Uri>属性返回规范化数据表示形式中转义的编码，其中包含所有字符 Unicode 值大于 127 替换为其十六进制等效项。 为使采用规范格式的 URI<xref:System.Uri>构造函数将执行以下步骤：  
  
-   将 URI 方案转换为小写。  
  
-   将主机名转换为小写。  
  
-   如果主机名是 IPv6 地址，则使用规范的 IPv6 地址。 删除 ScopeId 和其他可选的 IPv6 数据。  
  
-   删除默认值和空的端口号。

-   没有保留的用途的转义的字符 （也称为百分比编码八位字节） 为解码状态 （也称为进行转义的情况）。 这些非保留的字符包括大写和小写字母 (%41-%5a 和 %61-%7a)、 小数位数 （%30-%39)、 连字符 (%2d)、 句点 (%2e) 下划线 (%5f) 和颚化符 (%7e)。

-   Canonicalizes 路径的分层 Uri 由压缩序列如 /。 /.../，和 / / （是否转义序列）。 请注意，有不压缩这些序列的一些方案。
  
-   用于分层 Uri 时，如果主机未终止以正斜杠 （/），则添加一个。  
  
-   默认情况下，根据 RFC 2396 转义的 URI 中的任何保留的字符。 此行为更改如果国际资源标识符或国际域名分析启用了在 URI 中的保留字符进行转义根据 RFC 3986 和 RFC 3987。

 作为某些方案、 点段和空段的构造函数中的规范化的一部分 (/。 /.../，和 / /) 压缩的 （即，删除了）。 URI 将为其压缩这些序列的方案包括 http、 https、 tcp、 net.pipe 和 net.tcp。 对于其他方案，这些序列不会进行压缩。 下面是在实践中的此压缩外观。
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 此代码执行时，它返回以下输出，如有必要进行非转义，然后压缩的转义序列。

```  
http://myUrl/  
/  
```  
  
 可以将转换的内容<xref:System.Uri>类从与可读的 URI 引用通过使用编码的转义 URI 引用<xref:System.Uri.ToString%2A>方法。 请注意，可能仍保留的某些字符进行转义的输出中<xref:System.Uri.ToString%2A>方法。 这是为了支持从返回的值的 URI 的明确重新构造<xref:System.Uri.ToString%2A>。  
  
 某些 Uri 包含片段标识符和/或查询。 片断标识符是任何文本，跟在数字符号 （#），不包括数字符号;片段文本存储在<xref:System.Uri.Fragment%2A>属性。 查询信息是遵循 URI; 中为问号 （？） 的任何文本查询文本将存储在<xref:System.Uri.Query%2A>属性。  
  
 .NET Framework 版本 1.1 中，如果构造函数指定的字符串包含未知的方案中和"c:\\"，Uri 类插入"/ /"冒号后面。 例如，URI`xyz:c:\abc`转换为`xyz://c:/abc`。 在.NET Framework 2.0 版中，此行为已被删除，并且示例字符串转换为`xyz:c:/abc`。  
  
> [!NOTE]
>  URI 类支持 IPv4 协议的两个四组表示法和冒号十六进制的 IPv6 协议中使用的 IP 地址。 请记住将 IPv6 地址括在方括号内，如下所示 http://[::1]。  
  
## <a name="international-resource-identifier-support"></a>国际资源标识符支持  
 Web 地址通常表示使用统一资源标识符构成的一组非常有限的字符：  
  
-   英文字母表中的大小写 ASCII 字母。  
  
-   从 0 到 9 的数字。  
  
-   少量的其他 ASCII 符号。  
  
 Uri 的规范记录在 RFC 2396、 RFC 2732、 RFC 3986 和 RFC 3987 发布 Internet 工程任务组 (IETF) 中。  
  
 随着 Internet 的发展，越来越需要使用英语以外的语言识别资源。 标识符满足了这种需求，并且使得非 ASCII 字符（Unicode 中的字符/ISO 10646 字符集）被称为国际资源标识符（IRI）。 IETF 发布的 RFC 3987 记录了 IRI 的规格。 使用 IRI 允许 URL 包含 Unicode 字符。  
  
 现有<xref:System.Uri>类进行了扩展在.NET Framework 3.5 版，3.0 SP1 和 2.0 SP1 提供 IRI 支持根据 RFC 3987。 除非他们专门启用 IRI，.NET Framework 版本 4.5 之前的版本中的用户不会从.NET Framework 2.0 行为的任何更改。 这确保了 NET Framework 以前版本的应用程序兼容性。  
  
 若要启用 IRI 支持，则需要以下更改：  
  
-   指定是否对域名应用国际化域名 (IDN) 分析以及是否应该应用 IRI 分析规则。 这可以实现*machine.config*中或在*app.config*文件。 例如，添加以下代码：  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 .NET Framework 4.5 和更高版本的用户始终拥有启用 IRI。 IRI 分析不能更改使用 *.config*文件。  
  
 启用 IDN 可以将域名中所有 Unicode 标签转换成标签的 Punycode 等同项。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。 这样是为了支持 Internet 上的 DNS 服务器，因为大部分 DNS 服务器仅支持 ASCII 字符（参见 RFC 3940）。  
  
 启用 IRI 和 IDN 会影响 <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> 属性的值。 启用 IRI 和 IDN 还可能更改 <xref:System.Uri.Equals%2A>、<xref:System.Uri.OriginalString%2A>、<xref:System.Uri.GetComponents%2A> 和 <xref:System.Uri.IsWellFormedOriginalString%2A> 方法的行为。  
  
 有三个可能的 IDN 值具体取决于使用的 DNS 服务器：  
  
-   启用 idn = All  
  
     此值会将所有 Unicode 域名转换为它们的 Punycode 等效项（IDN 名称）。  
  
-   启用 idn = AllExceptIntranet  
  
     此值会将不在使用 Punycode 等效项 （IDN 名称） 在本地 Intranet 上的所有 Unicode 域名都转换。 在这种情况下若要处理本地 Intranet 上的国际化名称，用于 Intranet 的 DNS 服务器应该支持 Unicode 名称解析。  
  
-   启用 idn = 无  
  
     此值不会将任何 Unicode 域名转换为使用 Punycode。 这是默认值是与.NET Framework 2.0 行为一致。  
  
 当启用 IRI 分析 (iriParsing 启用 = `true`) 根据 RFC 3986 和 RFC 3987 中的最新 IRI 规则执行规范化和字符检查。 禁用 IRI 分析后，规范化和字符检查会根据 RFC 2396 和 RFC 2732 （对执行 IPv6 文本）。  在.NET Framework 版本 4.5 之前的版本中，默认值是`false`。 在.NET Framework 4.5 和更高版本中，默认值是`true`，并且不能由中设置修改的 IRI 分析的启用的状态 *.config*文件。  
  
 IRI 和 IDN 中处理<xref:System.Uri>还可以使用控制类<xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>， <xref:System.Configuration.IdnElement?displayProperty=nameWithType>，和<xref:System.Configuration.UriSection?displayProperty=nameWithType>配置设置类。 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 设置启用或禁用 <xref:System.Uri> 类中的 IRI 处理。 <xref:System.Configuration.IdnElement?displayProperty=nameWithType> 设置启用或禁用 <xref:System.Uri> 类中的 IDN 处理。 <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> 也可间接控制 IDN。 必须启用 IRI 处理才能进行 IDN 处理。 如果禁用 IRI，IDN 处理将被设置为默认值，这时 NET Framework 2.0 行为用于兼容性，并且 IDN 名称不可用。  
  
 配置设置<xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>并<xref:System.Configuration.IdnElement?displayProperty=nameWithType>将读取一次时第一个<xref:System.Uri?displayProperty=nameWithType>构造类。 忽略时间后更改为默认设置。  
  
 <xref:System.GenericUriParser?displayProperty=nameWithType> 类已得到扩展，允许创建支持 IRI 和 IDN 的自定义分析。 通过将枚举中可用值的按位组合传递给 <xref:System.GenericUriParserOptions?displayProperty=nameWithType> 构造函数 <xref:System.GenericUriParser?displayProperty=nameWithType> 来指定 <xref:System.GenericUriParser?displayProperty=nameWithType> 对象的行为。 <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> 类型表示分析程序支持 RFC 3987 中为国际资源标识符 (IRI) 指定的分析规则。 是否使用 IRI 由前面讨论的配置值指定。  
  
 <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> 类型表示分析程序支持主机名的国际化域名 (IDN) 分析。 是否使用 IDN 由前面讨论的配置值指定。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果使用 *Web.config * 处理 Uri，如果其方案标识符使用了非标准所需的文件，其中包含 Uri 来初始化应用程序、 其他时间。 在这种情况下，当需要 Uri 时，不是在启动时初始化应用程序的受影响的部分。  
  
   
  
## Examples  
 下面的示例创建的实例<xref:System.Uri>类，并使用它来创建<xref:System.Net.WebRequest>实例。  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>出于安全考虑，您的应用程序时应小心接受<see cref="T:System.Uri" />来自不受信任的源和使用的实例<paramref name="dontEscape" />设置为<see langword="true" />。可以通过调用检查有效性的 URI 字符串<see cref="M:System.Uri.IsWellFormedOriginalString" />方法。</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">标识将由 <see cref="T:System.Uri" /> 实例表示的资源的字符串。 请注意，必须用括号将字符串形式的 IPv6 地址括起来。 例如，“http://[2607:f8b0:400d:c06::69]”。</param>
        <summary>用指定的 URI 初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.Uri>从 URI 字符串的实例。 它分析 URI，将其放入规范格式，并使任何所需的转义编码。  
  
 此构造函数不能确保<xref:System.Uri>指的是可访问的资源。  
  
 此构造函数将假定`string`参数引用的绝对 URI，它是等效于调用<xref:System.Uri.%23ctor%2A>构造函数与<xref:System.UriKind>设置为<xref:System.UriKind.Absolute>。 如果`string`传递给构造函数的参数是一个相对 URI，此构造函数将引发<xref:System.UriFormatException>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例的 uri"http://www.contoso.com/"。  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>在<see href="http://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。</para>
          </block>
          <paramref name="uriString" /> 为空。  
  
或 
<paramref name="uriString" /> 中指定的方案形式不正确。 请参阅 <see cref="M:System.Uri.CheckSchemeName(System.String)" />。  
  
或 
 <paramref name="uriString" /> 包含太多斜杠。  
  
或 
<paramref name="uriString" /> 中指定的密码无效。  
  
或 
<paramref name="uriString" /> 中指定的主机名无效。  
  
或 
<paramref name="uriString" /> 中指定的文件名无效。  
  
或 
<paramref name="uriString" /> 中指定的用户名无效。  
  
或 
<paramref name="uriString" /> 中指定的主机名或证书颁发机构名不能以反斜杠结尾。  
  
或 
<paramref name="uriString" /> 中指定的端口号无效或无法分析。  
  
或 
<paramref name="uriString" /> 的长度超过 65519 个字符。  
  
或 
<paramref name="uriString" /> 中指定的方案的长度超过 1023 个字符。  
  
或 
<paramref name="uriString" /> 中存在无效的字符序列。  
  
或 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 类的实例，包含序列化新的 <see cref="T:System.Uri" /> 实例所需的信息。</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> 类的实例，包含与新的 <see cref="T:System.Uri" /> 实例关联的序列化流的源。</param>
        <summary>从 <see cref="T:System.Uri" /> 和 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 类的指定实例初始化 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数实现<xref:System.Runtime.Serialization.ISerializable>接口<xref:System.Uri>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serializationInfo" /> 参数包含 <see langword="null" /> URI。</exception>
        <exception cref="T:System.UriFormatException">包含 <paramref name="serializationInfo" /> 参数包含一个空的 URI。  
  
或 
指定的方案形式不正确。 请参阅 <see cref="M:System.Uri.CheckSchemeName(System.String)" />。  
  
或 
该 URI 包含过多斜杠。  
  
或 
URI 中指定的密码无效。  
  
或 
URI 中指定的主机名无效。  
  
或 
URI 中指定的文件名无效。  
  
或 
URI 中指定的用户名无效。  
  
或 
URI 中指定的主机名或证书颁发机构名称不能以反斜杠结尾。  
  
或 
URI 中指定的端口号无效或无法分析。  
  
或 
URI 的长度超过 65519 个字符。  
  
或 
URI 中指定的方案的长度超过 1023 个字符。  
  
或 
URI 中存在无效的字符序列。  
  
或 
URI 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">标识将由 <see cref="T:System.Uri" /> 实例表示的资源的字符串。 请注意，必须用括号将字符串形式的 IPv6 地址括起来。 例如，“http://[2607:f8b0:400d:c06::69]”。</param>
        <param name="dontEscape">如果 <c>uriString</c> 已完全转义，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>用指定的 URI 初始化 <see cref="T:System.Uri" /> 类的新实例，并对字符转义进行显式控制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.Uri>从 URI 字符串的实例。 它分析 URI，并将其放入规范格式。  
  
 `dontEscape`参数控制是否保留的字符将转换为转义序列。 此参数应设置为`true`仅当确定已转义的 URI 中的所有保留的字符。 将值设置为`true`为完全未转义的 URI 会导致意外的行为。 强烈建议始终将此参数设置为`false`。  
  
 如果`dontEscape`设置为`false`，构造函数通过检查百分号 （%） 的所有匹配项后跟一个有效的转义序列转义任何保留的字符。 如果百分号后面的字符序列不是有效的百分比是替换为 25%。  
  
 此构造函数不能确保<xref:System.Uri>指的是可访问的资源。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>uri 实例http://www.contoso.com/Hello%20World.htm。 因为包含的 URI 完全转义，而是采用规范格式`dontEscape`参数可以设置为`true`。  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" /> 为空或只包含空格。  
  
或 
在 <paramref name="uriString" /> 中指定的方案无效。  
  
或 
 <paramref name="uriString" /> 包含太多斜杠。  
  
或 
<paramref name="uriString" /> 中指定的密码无效。  
  
或 
<paramref name="uriString" /> 中指定的主机名无效。  
  
或 
<paramref name="uriString" /> 中指定的文件名无效。  
  
或 
<paramref name="uriString" /> 中指定的用户名无效。  
  
或 
<paramref name="uriString" /> 中指定的主机名或证书颁发机构名不能以反斜杠结尾。  
  
或 
<paramref name="uriString" /> 中指定的端口号无效或无法分析。  
  
或 
<paramref name="uriString" /> 的长度超过 65519 个字符。  
  
或 
<paramref name="uriString" /> 中指定的方案的长度超过 1023 个字符。  
  
或 
<paramref name="uriString" /> 中存在无效的字符序列。  
  
或 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">标识将由 <see cref="T:System.Uri" /> 实例表示的资源的字符串。 请注意，必须用括号将字符串形式的 IPv6 地址括起来。 例如，“http://[2607:f8b0:400d:c06::69]”。</param>
        <param name="uriKind">指定 URI 字符串是相对 URI、绝对 URI 还是不确定。</param>
        <summary>用指定的 URI 初始化 <see cref="T:System.Uri" /> 类的新实例。 此构造函数允许指定 URI 字符串是相对 URI、绝对 URI 还是不确定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相对和绝对 Uri 具有不同限制它们的格式。 例如，一个相对 URI 不需要的方案或证书颁发机构。 在指定的值`uriKind`中传递的 URI 的类型必须匹配`uriString`。 但是，如果<xref:System.UriKind.RelativeOrAbsolute>URI 字符串可以相对或绝对的指定。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>在<see href="http://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。</para>
          </block>
          <paramref name="uriString" /> 包含相对 URI，而 <paramref name="uriKind" /> 为 <see cref="F:System.UriKind.Absolute" />。  
  
或 
 <paramref name="uriString" /> 包含绝对 URI，而 <paramref name="uriKind" /> 为 <see cref="F:System.UriKind.Relative" />。  
  
或 
 <paramref name="uriString" /> 为空。  
  
或 
<paramref name="uriString" /> 中指定的方案形式不正确。 请参阅 <see cref="M:System.Uri.CheckSchemeName(System.String)" />。  
  
或 
 <paramref name="uriString" /> 包含太多斜杠。  
  
或 
<paramref name="uriString" /> 中指定的密码无效。  
  
或 
<paramref name="uriString" /> 中指定的主机名无效。  
  
或 
<paramref name="uriString" /> 中指定的文件名无效。  
  
或 
<paramref name="uriString" /> 中指定的用户名无效。  
  
或 
<paramref name="uriString" /> 中指定的主机名或证书颁发机构名不能以反斜杠结尾。  
  
或 
<paramref name="uriString" /> 中指定的端口号无效或无法分析。  
  
或 
<paramref name="uriString" /> 的长度超过 65519 个字符。  
  
或 
<paramref name="uriString" /> 中指定的方案的长度超过 1023 个字符。  
  
或 
<paramref name="uriString" /> 中存在无效的字符序列。  
  
或 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 URI。</param>
        <param name="relativeUri">要添加到基 URI 的相对 URI。</param>
        <summary>根据指定的基 URI 和相对 URI 字符串，初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.Uri>通过组合实例`baseUri`和`relativeUri`。 如果`relativeUri`是绝对的 URI （包含一种方案、 主机名和 （可选） 端口号），<xref:System.Uri>实例创建仅使用`relativeUri`。  
 
 如果`baseUri`具有相对部分 (如`/api`)，则必须以斜杠，终止的相对部分 (如`/api/`)，如果的相对部分`baseUri`将被保留在构造<xref:System.Uri>。 

 此外，如果`relativeUri`以斜线，开头，则它将替换任何相对一部分 `baseUri`

 此构造函数不能确保<xref:System.Uri>指的是可访问的资源。  
  
   
  
## Examples  
 下面的示例创建的新实例<xref:System.Uri>类的组合的相对 Uri http://www.contoso.com catalog/shownew.htm 以构成绝对 URI 和http://www.contoso.com/catalog/shownew.htm。  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>在<see href="http://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。</para>
          </block>
          <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 是空的或只包含空格。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的方案无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合所形成的 URI 包含太多的斜杠。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的密码无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的主机名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的文件名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的用户名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的主机名或证书颁发机构名不能以反斜杠结尾。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的端口号无效或无法分析。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 的长度超过 65519 个字符。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的方案的长度超过 1023 个字符。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中存在无效的字符序列。  
  
或 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">作为新 <see cref="T:System.Uri" /> 实例的基的绝对 <see cref="T:System.Uri" />。</param>
        <param name="relativeUri">与 <c>baseUri</c> 组合的相对 <see cref="T:System.Uri" /> 实例。</param>
        <summary>根据指定的基 <see cref="T:System.Uri" /> 实例和相对 <see cref="T:System.Uri" /> 实例的组合，初始化 <see cref="T:System.Uri" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建一个新<xref:System.Uri>实例通过组合绝对<xref:System.Uri>实例， `baseUri`，使用相对<xref:System.Uri>实例， `relativeUri`。 如果`relativeUri`是绝对<xref:System.Uri>（包含一种方案、 主机名和 （可选） 端口号） 的实例，<xref:System.Uri>仅使用创建实例`relativeUri`。  
 
 如果`baseUri`具有相对部分 (如`/api`)，则必须以斜杠，终止的相对部分 (如`/api/`)，如果的相对部分`baseUri`将被保留在构造<xref:System.Uri>。 

 此外，如果`relativeUri`以斜线，开头，则它将替换任何相对一部分 `baseUri`
 
 此构造函数不能确保<xref:System.Uri>指的是可访问的资源。  
  
   
  
## Examples  
 此示例创建一个绝对<xref:System.Uri>实例， `absoluteUri`，且是相对<xref:System.Uri>实例， `relativeUri`。 一个新<xref:System.Uri>实例， `combinedUri`，然后创建从这两个实例。  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>在<see href="http://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。</para>
          </block>
          <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 是空的或只包含空格。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的方案无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合所形成的 URI 包含太多的斜杠。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的密码无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的主机名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的文件名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的用户名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的主机名或证书颁发机构名不能以反斜杠结尾。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的端口号无效或无法分析。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 的长度超过 65519 个字符。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的方案的长度超过 1023 个字符。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中存在无效的字符序列。  
  
或 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 URI。</param>
        <param name="relativeUri">要添加到基 URI 的相对 URI。</param>
        <param name="dontEscape">如果 <c>uriString</c> 已完全转义，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>根据指定的基 URI 和相对 URI，初始化 <see cref="T:System.Uri" /> 类的新实例，并对字符转义进行显式控制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建<xref:System.Uri>通过组合实例`baseUri`和`relativeUri`。 如果 URI 中传递`relativeUri`是绝对的 URI （包含一种方案、 主机名和 （可选） 端口号），<xref:System.Uri>实例创建仅使用`relativeUri`。  
  
 `dontEscape`参数控制是否保留的字符将转换为转义序列。 此参数应设置为`true`仅当确定已转义的 URI 中的所有保留的字符。 将值设置为`true`为完全未转义的 URI 会导致意外的行为。 强烈建议始终将此参数设置为`false`。 如果`dontEscape`设置为`false`，构造函数通过检查百分号 （%） 的所有匹配项后跟一个有效的转义序列转义任何保留的字符。 如果百分号后面的字符序列不是有效的百分比是替换为 25%。  
  
 此构造函数不能确保<xref:System.Uri>指的是可访问的资源。  
  
   
  
## Examples  
 下面的示例创建的新实例<xref:System.Uri>类的组合的相对 Urihttp://www.contoso.com和 Hello%20World.htm 以构成绝对 URI。  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> 不是绝对的 <see cref="T:System.Uri" /> 实例。</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 是空的或只包含空格。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的方案无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合所形成的 URI 包含太多的斜杠。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的密码无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的主机名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的文件名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的用户名无效。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的主机名或证书颁发机构名不能以反斜杠结尾。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的端口号无效或无法分析。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 的长度超过 65519 个字符。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中指定的方案的长度超过 1023 个字符。  
  
或 
<paramref name="baseUri" /> 和 <paramref name="relativeUri" /> 组合形成的 URI 中存在无效的字符序列。  
  
或 
<paramref name="uriString" /> 中指定的 MS-DOS 路径必须以 c:\\\\ 开头。</exception>
        <block subset="none" type="usage">
          <para>出于安全考虑，您的应用程序不应调用此构造函数用于 URI 字符串来自不受信任的源和使用<paramref name="dontEscape" />设置为<see langword="true" />。或者，可以通过调用检查有效性的 URI 字符串<see cref="M:System.Uri.IsWellFormedOriginalString" />方法之前调用此构造函数。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 URI 的绝对路径。</summary>
        <value>包含资源的绝对路径的 <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A>属性包含服务器用来解析请求信息的路径信息。 通常这是服务器的文件系统上所需的信息的路径，尽管它也可能表明应用程序或脚本，则服务器必须运行提供的信息。  
  
 路径信息不包括方案、 主机名或 URI 查询部分。  
  
   
  
## Examples  
 以下示例向控制台写入路径 /catalog/shownew.htm。  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取绝对 URI。</summary>
        <value>包含整个 URI 的 <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsoluteUri%2A>属性包含整个 URI 存储在<xref:System.Uri>实例，包括所有片段和查询字符串。  
  
   
  
## Examples  
 下面的示例的完整内容写入<xref:System.Uri>实例到控制台。 在示例中所示，http://www.contoso.com/catalog/shownew.htm?date=today写入到控制台。  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取服务器的域名系统 (DNS) 主机名或 IP 地址和端口号。</summary>
        <value>包含此实例所表示的 URI 的证书颁发机构部分的 <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A>属性通常是服务器 DNS 主机名或 IP 地址。 此属性可能包括服务端口号，如果它不同于默认端口为 URI。 如果<xref:System.Uri.Authority%2A>组件包含保留的字符，这些转义中此属性返回的字符串值。  
  
   
  
## Examples  
 下面的示例将主机名称 (www.contoso.com) 和端口号 (8080) 到控制台的服务器。  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将内部存储的 URI 转换为规范化格式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在内部存储 URI 的规范版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此方法仅对绝对 URI 有效。</exception>
        <exception cref="T:System.UriFormatException">URI 的格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要验证的主机名。 可以是 IPv4 或 IPv6 地址或 Internet 主机名。</param>
        <summary>确定指定的主机名是否为有效的 DNS 名称。</summary>
        <returns>指示主机名类型的 <see cref="T:System.UriHostNameType" />。 如果无法确定主机名的类型，或者主机名为 <see langword="null" /> 或零长度字符串，则此方法返回 <see cref="F:System.UriHostNameType.Unknown" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A>方法检查提供的主机名是否满足有效的 Internet 主机名称的要求。 但是，它不执行主机名查找来验证主机存在。  
  
   
  
## Examples  
 以下示例检查主机名是否有效。  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">要验证的方案名。</param>
        <summary>确定指定的方案名是否有效。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果方案名有效，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检查默认情况下根据 RFC 2396 有效性的方案名称。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，此方法将检查根据 RFC 3986 的有效性的方案名称。 方案名称必须以字母开头，并且必须包含字母、 数字和字符"。"，"+"或"-"。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并检查的方案名称是否有效。  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>调用此方法不起任何作用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">第一个 <see cref="T:System.Uri" />。</param>
        <param name="uri2">第二个 <see cref="T:System.Uri" />。</param>
        <param name="partsToCompare">
          <see cref="T:System.UriComponents" /> 值的按位组合，它指定要比较的 <c>uri1</c> 和 <c>uri2</c> 部分。</param>
        <param name="compareFormat">
          <see cref="T:System.UriFormat" /> 值中的一个，它指定在比较 URI 部分时使用的字符转义。</param>
        <param name="comparisonType">
          <see cref="T:System.StringComparison" /> 值之一。</param>
        <summary>使用指定的比较规则比较两个 URI 的指定部分。</summary>
        <returns>一个 <see cref="T:System.Int32" /> 值，指示进行比较的 <see cref="T:System.Uri" /> 部分之间的词法关系。  
  
 <list type="table"><listheader><term> 值  </term><description> 含义  </description></listheader><item><term> 小于零  </term><description><paramref name="uri1" /> 小于 <paramref name="uri2" />。</description></item><item><term> 零  </term><description><paramref name="uri1" /> 等于 <paramref name="uri2" />。</description></item><item><term> 大于零  </term><description><paramref name="uri1" /> 大于 <paramref name="uri2" />。  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果这两个`uri1`并`uri2`是`null`，此方法返回 0。 在比较 URI 值时，相对 URI 始终是，不会早于绝对 URI 和一个非 null URI 始终是大于 null URI。 情况下，这两`uri1`并`uri2`不是`null`和相对 Uri 或绝对 Uri 时，<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>方法执行比较。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> 不是有效的 <see cref="T:System.StringComparison" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获得可安全用于 DNS 解析的未转义主机名（如必要）。</summary>
        <value>一个<see cref="T:System.String" />，其中包含适用于 DNS 解析; 或原始主机字符串格式的 URI 主机部分，如果已适用于解析。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 IPv6 地址，删除方括号 ([]) 和<xref:System.Net.IPAddress.ScopeId%2A>设置属性，如果构造此实例中时指定了。

如果已转义的字符串用于构造此实例 （例如，"http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm")，然后 DnsSafeHost 返回已转义的字符串。 Unescape 从返回任何转义的字符串`DnsSafeHost`之前使用该字符串进行 DNS 解析 （参阅示例）。 如果使用无效的非转义的字符串来构造此实例 （例如，"http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm")，然后 DnsSafeHost 返回未转义的字符串。
  
 <xref:System.Uri.DnsSafeHost%2A>属性是依赖于配置设置，如本主题后面所述。 Windows 应用商店应用程序，这可能会导致不一致的结果使用时不能更改配置设置<xref:System.Uri.DnsSafeHost%2A>。 <xref:System.Uri.IdnHost%2A>属性提供对使用的首选备用<xref:System.Uri.DnsSafeHost%2A>，因为<xref:System.Uri.IdnHost%2A>保证始终是安全的无论何种当前 DNS *app.config*可能设置。  
  
 <xref:System.Uri.DnsSafeHost%2A>属性已得到扩展，在.NET Framework 3.5 版，3.0 SP1 和 2.0 SP1 提供国际资源标识符 (IRI) 支持根据的 RFC 3987。 除非当前用户专门启用 IRI，否则他们看不到任何 NET Framework 2.0 行为的改变。 这确保了 NET Framework 以前版本的应用程序兼容性。  
  
 若要启用 IRI 支持，以下两项更改是必需的：  
  
1.  添加下面的代码行*machine.config* .NET Framework 2.0 目录下的文件  
  
     \<节名称 ="uri"type="System.Configuration.UriSection，系统中，版本 = 2.0.0.0，区域性 = 中性，PublicKeyToken = b77a5c561934e089"/ >  
  
2.  指定是否对域名应用国际化域名 (IDN) 分析以及是否应该应用 IRI 分析规则。 这可以实现*machine.config*中或在*app.config*文件。 例如，添加以下代码：  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 启用 IDN 可以将域名中所有 Unicode 标签转换成标签的 Punycode 等同项。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。 这样是为了支持 Internet 上的 DNS 服务器，因为大部分 DNS 服务器仅支持 ASCII 字符（参见 RFC 3940）。  
  
 启用 IDN 只会影响的值<xref:System.Uri.DnsSafeHost%2A>属性。  
  
 有三个可能的 IDN 值具体取决于使用的 DNS 服务器：  
  
-   启用 idn = All  
  
     此值会将所有 Unicode 域名转换为它们的 Punycode 等效项（IDN 名称）。  
  
-   启用 idn = AllExceptIntranet  
  
     此值会将所有外部 Unicode 域名转换为使用 Punycode 等效项（IDN 名称）。 在这种情况下，若要处理本地 Intranet 上的国际化名称，用于 Intranet 的 DNS 服务器应该支持 Unicode 名称。  
  
-   启用 idn = 无  
  
     此值不会将任何 Unicode 域名转换为使用 Punycode。 这是默认值是与.NET Framework 2.0 行为一致。  
  
 启用 IRI 分析 (iriParsing 启用 = `true`) 将执行规范化和字符检查根据最新 IRI 规则在 RFC 3987。 默认值是`false`，将执行规范化和字符检查根据 RFC 2396 和 RFC 2732 （适用于 IPv6 文本）。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>从字符串的实例。 它阐释了如何从返回的值之间的差异<xref:System.Uri.Host%2A>，其中返回的主机名或地址的 URI 中指定，并且从返回的值<xref:System.Uri.DnsSafeHost%2A>，这会返回可安全用于 DNS 解析中的地址。  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 如备注中所述，它在解决前 unescape 的主机名。 可以使用<xref:System.Uri.UnescapeDataString%2A>方法以取消转义主机名，并且您可以通过调用来解决它<xref:System.Net.Dns.GetHostEntry%2A>方法。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">与当前实例相比较的 <see cref="T:System.Uri" /> 实例或 URI 标识符。</param>
        <summary>比较两个 <see cref="T:System.Uri" /> 实例是否相等。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果两个实例表示相同的 URI，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Equals%2A>方法比较两个实例而不考虑用户信息 (<xref:System.Uri.UserInfo%2A>) 和片段 (<xref:System.Uri.Fragment%2A>) 可能包含的部件。 例如，给定 Urihttp://www.contoso.com/index.htm#search并http://user:password@www.contoso.com/index.htm，则<xref:System.Uri.Equals%2A>方法将返回`true`。  
  
 如果一个<xref:System.Uri>实例格式使用 Unicode 主机名和`comparand`参数包含<xref:System.Uri>实例或使用有等效的 Punycode 主机名，则主机名格式正确的标识符<xref:System.Uri.Equals%2A>返回`true`启用仅在国际资源标识符 (IRI) 和国际化域名 (IDN) 支持。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1，<xref:System.Uri.Query%2A>也被忽略。  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A>可以在派生类中重写方法; 的恶意实体可以修改该方法，请谨慎使用。 不应使用此方法来执行安全检查，除非你知道此实例来自受信任的源。  
  
   
  
## Examples  
 此示例创建两个<xref:System.Uri>实例从字符串并将它们，以确定它们是否表示相同的值进行比较。 `address1` 并`address2`是相同，因为<xref:System.Uri.Fragment%2A>部分此比较将被忽略。 结果将写入控制台。  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要防止部分受信任的代码派生自<see cref="T:System.Uri" />。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将路径部分中的任何不安全字符或保留字符转换为对应的十六进制字符表示形式。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">从构造函数传来的 URI 无效。 如果 URI 字符太多或 URI 是相对的，则会发生这种异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">要转义的字符串。</param>
        <summary>将字符串转换为它的转义表示形式。</summary>
        <returns>一个 <see cref="T:System.String" />，包含 <paramref name="stringToEscape" /> 的转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，<xref:System.Uri.EscapeDataString%2A>方法将 RFC 2396 非保留字符除外的所有字符都转换为其十六进制表示形式。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，<xref:System.Uri.EscapeDataString%2A>方法的所有字符转换，除了 RFC 3986 非保留的字符，为其十六进制表示形式。 转义之前，所有 Unicode 字符都转换为 utf-8 格式。  
  
 此方法假定`stringToEscape`中有任何转义序列。  
  
 默认情况下，根据 RFC 2396 转义字符串。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，根据 RFC 3986 和 RFC 3987 转义字符串。 请参阅有关的保留和非保留字符定义这些 Rfc。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>在<see href="http://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。</para>
          </block>
          <paramref name="stringToEscape" /> 的长度超过 32766 个字符。</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要转换为它的转义表示形式的字符串。</param>
        <summary>将字符串转换为它的转义表示形式。</summary>
        <returns>字符串的转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A>方法将 RFC 2396 保留字符和字符值大于 127 的所有字符转换为十六进制表示形式。 转义之前，所有 Unicode 字符都转换为 utf-8 格式。  
  
 默认情况下，根据 RFC 2396 转义字符串。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，根据 RFC 3986 和 RFC 3987 转义字符串。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">要转义的字符串。</param>
        <summary>将 URI 字符串转换为它的转义表示形式。</summary>
        <returns>一个 <see cref="T:System.String" />，包含 <paramref name="stringToEscape" /> 的转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Uri.EscapeUriString%2A>方法以准备要进行的参数未转义的 URI 字符串<xref:System.Uri.%23ctor%2A>构造函数。  
  
 默认情况下，<xref:System.Uri.EscapeUriString%2A>方法将 RFC 2396 非保留字符以外的所有字符都转换为其十六进制表示形式。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，<xref:System.Uri.EscapeUriString%2A>方法的所有字符转换，除了 RFC 3986 非保留的字符，为其十六进制表示形式。 转义之前，所有 Unicode 字符都转换为 utf-8 格式。  
  
 此方法假定`stringToEscape`中有任何转义序列。  
  
 默认情况下，根据 RFC 2396 转义字符串。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，根据 RFC 3986 和 RFC 3987 转义字符串。 请参阅有关的保留和非保留字符定义这些 Rfc。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>在<see href="http://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。</para>
          </block>
          <paramref name="stringToEscape" /> 的长度超过 32766 个字符。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取转义 URI 片段。</summary>
        <value>一个包含任意 URI 片段信息的 <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A>属性获取后片段标记 （#） 的 URI，包括片段标记本身中的所有文本。 给定 URI http://www.contoso.com/index.htm#main，则<xref:System.Uri.Fragment%2A>属性将返回 #main。  
  
 <xref:System.Uri.Fragment%2A>属性不在任何被视为<xref:System.Uri.Equals%2A>比较。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例并将片段信息输出到控制台。  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">要转换的十六进制数字（0-9、a-f、A-F）。</param>
        <summary>获取十六进制数字的十进制值。</summary>
        <returns>一个 <see cref="T:System.Int32" /> 值，包含与指定的十六进制数字对应的介于 0 到 15 之间的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A>方法将转换的字符所表示的十六进制数字 (0-9、 a-f、 A-F) 为十进制值 (0 到 15)。 如果`digit`不是有效的十六进制数字，<xref:System.ArgumentException>引发异常。  
  
   
  
## Examples  
 下面的示例确定字符是否为十六进制字符，是否是，则会将对应的十进制值写入控制台。  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> 不是有效的十六进制数字（0-9、a-f、A-F）。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">
          <see cref="T:System.UriComponents" /> 值的按位组合，它指定当前实例中要返回到调用方的部分。</param>
        <param name="format">
          <see cref="T:System.UriFormat" /> 值中的一个，它控制如何转义特殊字符。</param>
        <summary>使用特殊字符的指定转义，获取当前实例的指定部分。</summary>
        <returns>一个包含这些部分的 <see cref="T:System.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriComponents.Query>， <xref:System.UriComponents.Fragment>， <xref:System.UriComponents.Scheme>， <xref:System.UriComponents.UserInfo>， <xref:System.UriComponents.Host>， <xref:System.UriComponents.Port>，和<xref:System.UriComponents.Path>组件不包含分隔符。 你可以组合<xref:System.UriComponents.KeepDelimiter>任何这些值来获取具有分隔符的值 （使用按位 OR 运算符） 的标志。 对于所有其他<xref:System.UriComponents>值和的值组合，分隔符会包括在返回的值。  
  
 组件是它们在 URI 中显示的顺序返回。 例如，如果<xref:System.UriComponents.Scheme>指定，则它显示在最前面。  
  
 在中启用国际资源标识符 (IRI) 和国际化域名 (IDN) 支持后，返回的字符数<xref:System.String>会增加。 用于支持 IRI Punycode 名称只能包含 ASCII 字符，并且始终以 xn--前缀开头。 启用 IRI 和 IDN，正确处理 Unicode 代理项字符<xref:System.Uri.GetComponents%2A>方法。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
> [!NOTE]
>  如果<xref:System.Uri.GetComponents%2A>与调用方法`format`设置为<xref:System.UriFormat.Unescaped>，不能使用返回的值作为参数<xref:System.Uri.%23ctor%2A>构造函数创建等效<xref:System.Uri>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> 不是有效 <see cref="T:System.UriComponents" /> 值的组合。</exception>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Uri" /> 不是绝对 URI。 相对 URI 不能和此方法一起使用。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 URI 的哈希代码。</summary>
        <returns>一个 <see cref="T:System.Int32" />，其中包含为此 URI 生成的哈希值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并向控制台进行写入的哈希代码。  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">
          <see cref="T:System.UriPartial" /> 值之一，指定要返回的 URI 部分的结尾。</param>
        <summary>获取 <see cref="T:System.Uri" /> 实例的指定部分。</summary>
        <returns>一个 <see cref="T:System.String" />，其中包含 <see cref="T:System.Uri" /> 实例的指定部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.GetLeftPart%2A>方法返回一个包含与指定的部分结束的 URI 字符串的最左侧部分字符串`part`。  
  
 <xref:System.Uri.GetLeftPart%2A> 在以下情况下包括分隔符：  
  
-   <xref:System.UriPartial.Scheme> 包括方案分隔符。  
  
-   <xref:System.UriPartial.Authority> 不包括路径分隔符。  
  
-   <xref:System.UriPartial.Path> 最多的查询或片段的分隔符的原始 URI 中包括任何分隔符。  
  
-   <xref:System.UriPartial.Query> 包括<xref:System.UriPartial.Path>，加上查询和其分隔符。  
  
 下面的示例演示将 URI 和调用的结果<xref:System.Uri.GetLeftPart%2A>与<xref:System.UriPartial.Scheme>， <xref:System.UriPartial.Authority>， <xref:System.UriPartial.Path>，或<xref:System.UriPartial.Query>。  
  
|URI|方案|颁发机构|路径|查询|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com?subject=uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com?subject=uri|\<无 >|  
|nntp://news.contoso.com/123456@contoso.com|nntp: / /|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|新闻：|news:123456@contoso.com|news:123456@contoso.com|\<无 >|  
|file://server/filename.ext|file://|file://server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例并将路径输出到控制台。  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Uri" /> 实例不是绝对实例。</exception>
        <exception cref="T:System.ArgumentException">指定的 <paramref name="part" /> 无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">一个 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象包含序列化 <see cref="T:System.Uri" /> 所需的信息。</param>
        <param name="streamingContext">一个 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象包含与<see cref="T:System.Uri" /> 关联的序列化流的源和目标。</param>
        <summary>返回序列化当前实例所需的数据。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用序列化方法。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">要转换为十六进制表示形式的字符。</param>
        <summary>将指定的字符转换为它的等效十六进制字符。</summary>
        <returns>指定字符的十六进制表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例将字符转换为其十六进制等效值，并将其写入到控制台。  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> 大于 255。</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">字符的十六进制表示形式。</param>
        <param name="index">
          <c>pattern</c> 中字符的十六进制表示形式开始的位置。</param>
        <summary>将字符的指定十六进制表示形式转换为字符。</summary>
        <returns>用十六进制编码表示的位于 <paramref name="index" /> 的字符。 如果位于 <paramref name="index" /> 的字符不是用十六进制编码的，则返回位于 <paramref name="index" /> 的字符。 <paramref name="index" /> 的值递增以指向跟在返回的字符后面的字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下面的代码示例确定字符是否为十六进制编码，是否是这样，则会将等效的字符写入控制台。  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0，或大于等于 <paramref name="pattern" /> 中的字符数。</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的主机部分。</summary>
        <value>一个包含主机名的 <see cref="T:System.String" />。 这通常是服务器的 DNS 主机名或 IP 地址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Uri.Authority%2A>属性，此属性的值不包括端口号。  
  
   
  
## Examples  
 下面的示例将写入控制台的服务器的主机名称 (www.contoso.com)。  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 URI 中指定的主机名的类型。</summary>
        <value>
          <see cref="T:System.UriHostNameType" /> 枚举的一个成员。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例并将事件写入<xref:System.Uri.HostNameType%2A>到控制台。  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RFC 3490 根据需要使用 Punycode，符合主机的国际域名要求。 该字符串在不进行转义的情况下（如必要）可安全用于 DNS 解析。</summary>
        <value>根据 IDN 标准，返回采用 Punycode 格式的主机名<see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 需要 Punycode 窗体中的域名的较低级别网络协议用于提供此属性。 如果你的代码不需要该特定的格式，使用<xref:System.Uri.Host%2A>主机名。  
  
 已弃用<xref:System.Uri.DnsSafeHost%2A>属性是依赖于*app.config*设置，Windows 应用商店应用程序不能更改。 作为使用首选替代方法提供 IdnHost <xref:System.Uri.DnsSafeHost%2A>，因为<xref:System.Uri.IdnHost%2A>保证始终是安全的无论何种当前 DNS *app.config*可能设置。  

 如果已转义的字符串用于构造此实例 （例如，"http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm")，然后 IdnHost 返回已转义的字符串。 应取消之前进行 DNS 解析中使用该字符串从 IdnHost 返回任何已转义的字符串。 请注意，如果您使用了无效非转义的字符串将构造此实例 （例如，"http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm")，然后 IdnHost 返回未转义的字符串。


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Uri" /> 实例是否为绝对 URI。</summary>
        <value>一个 <see cref="T:System.Boolean" /> 值。如果 <see langword="true" /> 实例是绝对 URI，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是`true`如果在字符串或<xref:System.Uri>传递到构造函数的实例可以解析为绝对<xref:System.Uri>实例，其中包含一种方案、 一个颁发机构和的路径。 否则为<xref:System.Uri>实例被视为相对和可能会省略方案或其他 URI 组件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">要测试的 <see cref="T:System.Char" />。</param>
        <summary>获取一个值，该值指示字符是否在文件系统名称中无效。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果指定的字符无效，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据 NTFS 文件系统的规则分析字符。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">要测试的指定 <see cref="T:System.Uri" /> 实例。</param>
        <summary>确定当前的 <see cref="T:System.Uri" /> 实例是否为指定 <see cref="T:System.Uri" /> 实例的基。</summary>
        <returns>如果当前 <see langword="true" /> 实例是 <see cref="T:System.Uri" /> 的基，则为 <paramref name="uri" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> 用于比较当前<xref:System.Uri>实例与指定<xref:System.Uri>来确定此 URI 是否为指定的基础<xref:System.Uri>。 当比较两个<xref:System.Uri>对象，以确定基本关系，用户信息 (<xref:System.Uri.UserInfo%2A>) 则不会评估。 在比较两个 Uri （uri1 和 uri2） 时，如果当你忽略 uri2 中的所有内容后的最后一个斜杠 （/），两个 Uri 同时 uri1 就是 uri2 的基。 使用http://host/path/path/file?query作为基 URI，下表显示了，无论它是其他 Uri 的基础。  
  
|URI|http://host/path/path/file?query 是基项|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|是|  
|http://host/path/path/#fragment|是|  
|http://host/path/path/MoreDir/"|是|  
|http://host/path/path/OtherFile?Query|是|  
|http://host/path/path/|是|  
|http://host/path/path/file|是|  
|http://host/path/path|否|  
|http://host/path/path?query|否|  
|http://host/path/path#Fragment|否|  
|http://host/path/path2/|否|  
: //host/path/path2/MoreDir|否|  
|http://host/path/File|否|  
  
   
  
## Examples  
 此示例将创建<xref:System.Uri>实例，它表示基础<xref:System.Uri>实例。 然后，创建第二个<xref:System.Uri>从字符串的实例。 它将调用<xref:System.Uri.IsBaseOf%2A>以确定基本实例是否为第二个实例的基。 结果将写入控制台。  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 URI 的端口值是否为此方案的默认值。</summary>
        <value>一个 <see cref="T:System.Boolean" /> 值。如果 <see langword="true" /> 属性中的值是此方案的默认端口，则该值为 <see cref="P:System.Uri.Port" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并检查它是否使用默认端口。  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">要测试的 <see cref="T:System.Char" />。</param>
        <summary>获取一个值，该值指示是否应该转义指定的字符。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果应该转义指定的字符，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示指定的 <see cref="T:System.Uri" /> 是否为文件 URI。</summary>
        <value>一个 <see cref="T:System.Boolean" /> 值。如果 <see langword="true" /> 是文件 URI，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsFile%2A>属性是`true`时<xref:System.Uri.Scheme%2A>属性等于<xref:System.Uri.UriSchemeFile>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定它是否为文件 URI。  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">要验证的字符。</param>
        <summary>确定指定的字符是否为有效的十六进制数字。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果字符是有效的十六进制数字，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 十六进制数字为 0 到 9 的数字和字母 A-F 或 a-f。  
  
   
  
## Examples  
 下面的示例确定字符是否为十六进制字符，是否是，则会将对应的十进制值写入控制台。  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">要检查的字符串。</param>
        <param name="index">要检查十六进制编码的 <c>pattern</c> 中的位置。</param>
        <summary>确定字符串中的一个字符是否为十六进制编码。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果 <see langword="true" /> 在指定位置进行了十六进制编码，则该值为 <paramref name="pattern" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsHexEncoding%2A>方法检查十六进制编码，其中"hex"遵循模式遵循"%hexhex"在字符串中，为数字 0 到 9 或从 A 到 F （不区分大小写） 以字母。  
  
   
  
## Examples  
 下面的代码示例确定字符是否为十六进制编码，是否是这样，则会将等效的字符写入控制台。  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示指定的 <see cref="T:System.Uri" /> 是否引用了本地主机。</summary>
        <value>一个 <see cref="T:System.Boolean" /> 值。如果此 <see langword="true" /> 引用了本地主机，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> 返回`true`如果创建此实例时指定的 URI 为 127.0.0.1，环回，或 localhost，或者如果 URI 未指定主机信息 (例如，file:///c:Dir/file.txt)。 所有其他 Uri 返回`false`。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定它是否引用本地主机。  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">要测试的 <see cref="T:System.Char" />。</param>
        <summary>获取一个值，该值指示指定的字符是否为保留字符。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果指定的字符是保留字符，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示指定的 <see cref="T:System.Uri" /> 是否为统一命名约定 (UNC) 路径。</summary>
        <value>一个 <see cref="T:System.Boolean" /> 值。如果 <see langword="true" /> 是 UNC 路径，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsUnc%2A>属性是`true`如果指定<xref:System.Uri>实例是 UNC 路径 (如\\\server\folder 或 file://server/folder)。 此属性始终返回`true`如果 URI 具有 file:// 方案和指定的主机组件。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定它是否是 UNC 路径。  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示用于构造此 <see cref="T:System.Uri" /> 的字符串是否格式良好，以及它是否不需要进一步转义。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果该字符串格式正确，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下是根据 RFC 2396 和 RFC 2732 格式正确，认为该字符串。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，该字符串被视为可根据 RFC 3986 和 RFC 3987 格式正确  
  
 将认为该字符串格式很差，并导致此方法返回 false，如果发生以下情况。  
  
|Error|示例|  
|-----------|-------------|  
|未正确转义字符串。|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) 名称|  
|字符串是绝对<xref:System.Uri>，表示隐式文件<xref:System.Uri>。|c:\\\directory\filename|  
|该字符串是缺少斜杠之前路径的绝对 URI。|file://c:/directory/filename|  
|字符串包含非转义反斜杠，即使它们被视为正斜杠。|http:\\\host/path/file|  
|该字符串表示层次结构的绝对<xref:System.Uri>，并且不包含"://"。|www.contoso.com/path/file|  
|分析器<xref:System.Uri.Scheme%2A?displayProperty=nameWithType>指示原始字符串不是格式正确。|此示例依赖于 URI 的方案。|  
  
 默认情况下，该字符串用于构造此<xref:System.Uri>被视为格式正确，符合 RFC 2396 和 RFC 2732。  
  
 当启用时国际资源标识符 (IRI) 和国际化域名 (IDN) 支持，用于构造此字符串<xref:System.Uri>被视为格式正确，符合 RFC 3986 和 RFC 3987。 用于支持 IRI Punycode 名称只能包含 ASCII 字符，并且始终以 xn--前缀开头。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">用于尝试构造 <see cref="T:System.Uri" /> 的字符串。</param>
        <param name="uriKind">
          <c>uriString</c> 中的 <see cref="T:System.Uri" /> 的类型。</param>
        <summary>通过尝试用字符串构造一个 URI 来指示字符串是否为格式良好的，并确保字符串不需要进一步转义。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果该字符串格式正确，则该值为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下在版本 4.5 之前的.NET 版本中，该字符串被视为格式正确，符合 RFC 2396 和 RFC 2732。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，则认为该字符串是格式正确，符合 RFC 3986 和 RFC 3987。  
  
 从.NET 4.5 开始，始终认为字符串的格式正确的根据 RFC 3986 和 RFC 3987，该值指示是否 IRI 或 IDN 启用。 但是，请注意，此选项仅适用于面向.NET 4.5 的应用，或更高版本。 面向.NET 4.0 的应用调用兼容性代码和体验的旧 (4.5 版本之前的) 行为。  
  
 则认为字符串的格式很差，并导致此方法返回 false，如果出现任何以下条件  
  
|Error|示例|  
|-----------|-------------|  
|未正确转义字符串。|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) 名称|  
|字符串是绝对<xref:System.Uri>，表示隐式文件<xref:System.Uri>。|c:\\\directory\filename|  
|该字符串是缺少斜杠之前路径的绝对 URI。|file://c:/directory/filename|  
|该字符串包含非转义反斜杠，即使将被视为正斜杠|http:\\\host/path/file|  
|该字符串表示层次结构的绝对<xref:System.Uri>，并且不包含"://"|www.contoso.com/path/file|  
|分析器<xref:System.Uri.Scheme%2A>指示原始字符串不是格式正确。|此示例依赖于 URI 的方案。|  
|从.NET 4.5 中，用冒号的相对 Uri (:) 不考虑其第一个段中格式正确。|2013.05.29_14:33:41|  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取文件名的本地操作系统表示形式。</summary>
        <value>一个 <see cref="T:System.String" />，包含文件名的本地操作系统表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值未转义。 如果路径被识别为 Windows 文件路径，所有正斜杠 （/） 替换为反斜杠 (\\)。  
  
 Uri`file://computer/file.ext`的绝对路径`/file.ext`的本地路径是`\\computer\file.ext`。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并向控制台进行写入的本地路径。  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">与当前 URI 进行比较的 URI。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例之间的差异。</summary>
        <returns>如果此 URI 实例与 <paramref name="toUri" /> 的主机名和方案相同，则此方法返回一个表示相对 URI 的 <see cref="T:System.String" />。若将此相对 URI 追加到当前 URI 实例，就可以得到 <paramref name="toUri" /> 参数。  
  
如果主机名或方案不同，则此方法返回一个表示 <see cref="T:System.String" /> 参数的 <paramref name="toUri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了 URI 实例， `toUri`，并调用的结果<xref:System.Uri.MakeRelative%2A>。  
  
|当前 URI 实例|`toUri`|返回值|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 用户信息，如果存在在 URI 中，则忽略。  
  
   
  
## Examples  
 下面的示例创建 2<xref:System.Uri>实例。 中的路径信息的差异写入到控制台。  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此方法仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">与当前 URI 进行比较的 URI。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例之间的差异。</summary>
        <returns>如果此 URI 实例与 <paramref name="uri" /> 的主机名和方案相同，则此方法返回一个相对 <see cref="T:System.Uri" />。若将此相对 URI 追加到当前 URI 实例，就可以得到 <paramref name="uri" />。  
  
如果主机名或方案不同，则此方法返回一个表示 <see cref="T:System.Uri" /> 参数的 <paramref name="uri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了 URI 实例， `toUri`，并调用的结果<xref:System.Uri.MakeRelativeUri%2A>。  
  
|当前 URI 实例|`toUri`|返回值|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 用户信息，如果存在在 URI 中，则忽略。  
  
   
  
## Examples  
 下面的示例创建 2<xref:System.Uri>实例。 中的路径信息的差异写入到控制台。  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">要与 <c>uri2</c> 比较的 <see cref="T:System.Uri" /> 实例。</param>
        <param name="uri2">要与 <c>uri1</c> 比较的 <see cref="T:System.Uri" /> 实例。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例是否具有相同的值。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果这两个 <see langword="true" /> 实例是等效的，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载使用<xref:System.Uri.Equals%2A>方法，以确定是否两个<xref:System.Uri>实例是否相等。 <xref:System.Uri.UserInfo%2A> 和<xref:System.Uri.Fragment%2A>内容进行这种比较时被忽略。  
  
   
  
## Examples  
 此示例创建三个<xref:System.Uri>实例从字符串并将它们，以确定它们是否表示相同的值进行比较。 `Address1` 并`Address2`是相同，因为<xref:System.Uri.Fragment%2A>部分此比较将被忽略。 结果将写入控制台。  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">要与 <c>uri2</c> 比较的 <see cref="T:System.Uri" /> 实例。</param>
        <param name="uri2">要与 <c>uri1</c> 比较的 <see cref="T:System.Uri" /> 实例。</param>
        <summary>确定两个 <see cref="T:System.Uri" /> 实例是否具有不同的值。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果两个 <see langword="true" /> 实例不相等，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。 如果两者中任意一个参数为 <see langword="null" />，则此方法返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载使用<xref:System.Uri.Equals%2A>方法，以确定是否两个<xref:System.Uri>实例是否不相等。 <xref:System.Uri.UserInfo%2A> 和<xref:System.Uri.Fragment%2A>内容进行这种比较时被忽略。  
  
   
  
## Examples  
 此示例创建三个<xref:System.Uri>实例从字符串并将它们，以确定它们是否表示相同的值进行比较。 `Address2` 并`Address3`是不相同，因为`Address3`包含<xref:System.Uri.Query%2A>中未找到`Address2`。 结果将写入控制台。  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传递给 <see cref="T:System.Uri" /> 构造函数的原始 URI 字符串。</summary>
        <value>包含构造此实例时指定的同一 URI，则为 <see cref="T:System.String" />；否则，为 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果向构造函数指定的 URI 包含前导或尾随空格，将保留这些空格。  
  
 此属性返回的值与不同<xref:System.Uri.ToString%2A>和<xref:System.Uri.AbsoluteUri%2A>。 <xref:System.Uri.ToString%2A> 返回 URI 的规范地非转义的形式。 <xref:System.Uri.AbsoluteUri%2A> 返回 URI 的规范化转义的形式。  
  
 如果启用了国际资源标识符 (IRI) 和国际化域名 (IDN) 支持，<xref:System.Uri.OriginalString%2A>返回原始的非正常化的字符串使用 Punycode 主机名，如果其中一个用于初始化<xref:System.Uri>实例。 Punycode 名称只包含 ASCII 字符，并且始终以 xn-- 前缀开头。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
 当<xref:System.Uri>序列化对象，<xref:System.Uri.OriginalString%2A>不会保留。 序列化过程使用完全转义和规范化<xref:System.Uri.AbsoluteUri%2A>属性序列化时。 有关<xref:System.Uri>，其中包含 IPv6 地址，会包含 IPv6 地址和范围 ID 中的序列化<xref:System.Uri>对象。  
  
   
  
## Examples  
 下面的示例创建一个新<xref:System.Uri>从字符串的实例。 它阐释了如何从返回的值之间的差异<xref:System.Uri.OriginalString%2A>，它返回传递的字符串到构造函数中，并通过调用<xref:System.Uri.ToString%2A>，它返回字符串的规范格式。  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>分析当前实例的 URI 以确保它包含有效 URI 所需的所有部分。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">从构造函数传来的 URI 无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用问号 (?) 分隔的 <see cref="P:System.Uri.AbsolutePath" /> 和 <see cref="P:System.Uri.Query" /> 属性。</summary>
        <value>一个 <see cref="T:System.String" />，它包含用问号 (?) 分隔的 <see cref="P:System.Uri.AbsolutePath" /> 和 <see cref="P:System.Uri.Query" /> 属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A>属性包含在服务器和与请求一起发送的查询信息上的绝对路径。 它等同于串联<xref:System.Uri.AbsolutePath%2A>和<xref:System.Uri.Query%2A>属性。  
  
 <xref:System.Uri.PathAndQuery%2A>属性根据 RFC 2396 转义默认情况下。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，<xref:System.Uri.PathAndQuery%2A>根据 RFC 3986 和 RFC 3987 转义属性。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
   
  
## Examples  
 下面的示例编写的 URI 路径 (/ catalog/shownew.htm) 和查询 (date = today) 到控制台的信息。  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 URI 的端口号。</summary>
        <value>一个包含此 URI 的端口号的 <see cref="T:System.Int32" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 端口号定义联系的 URI 中引用的服务器使用的协议端口。 如果端口未指定的 URI，一部分<xref:System.Uri.Port%2A>属性返回的默认值为协议。 如果没有默认端口号，则此属性将返回-1。  
  
   
  
## Examples  
 以下示例向控制台写入 URI 的端口号。 在这种情况下，值为 HTTP，端口 80 的默认端口号。  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定 URI 中包括的任何查询信息。</summary>
        <value>一个<see cref="T:System.String" />，包含指定 URI 中包括的任何查询信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A>属性包含在 URI 中包括的任何查询信息。 查询信息由问号 （？） 分隔的路径信息，并将继续执行到 URI 的末尾。 返回的查询信息包括前导问号。  
  
 默认情况下，查询信息转义根据 RFC 2396。 如果启用了国际资源标识符 (Iri) 或国际化域名 (IDN) 分析，根据 RFC 3986 和 RFC 3987 转义查询信息。  
  
 IRI 支持的详细信息，请参阅备注部分<xref:System.Uri>类。  
  
   
  
## Examples  
 下面的示例将查询？ date = today 到控制台。  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 URI 的方案名称。</summary>
        <value>一个 <see cref="T:System.String" />，包含此 URI 的方案（已转换为小写形式）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Scheme%2A>属性返回用于初始化的方案<xref:System.Uri>实例。 此属性不指示方案用来初始化<xref:System.Uri>实例已识别出。  
  
 下表显示了返回的某些可能值的示例<xref:System.Uri.Scheme%2A>属性。  
  
|方案|描述|  
|------------|-----------------|  
|文件|资源是本地计算机上的文件。|  
|ftp|通过 FTP 访问资源。|  
|gopher|通过 Gopher 协议访问资源。|  
|http|通过 HTTP 访问资源。|  
|https|通过 SSL 加密的 HTTP 访问资源。|  
|ldap|通过 LDAP 协议访问资源。|  
|mailto|资源是电子邮件地址，并通过 SMTP 协议访问。|  
|net.pipe|通过命名管道访问资源。|  
|net.tcp|从 TCP 终结点访问该资源。|  
|news|通过采用 NNTP 协议访问资源。|  
|nntp|通过采用 NNTP 协议访问资源。|  
|telnet|通过 TELNET 协议访问资源。|  
|uuid|通过与服务通信的唯一 UUID 终结点名称访问资源。|  
  
   
  
## Examples  
 以下示例向控制台写入的方案名称 (http) http://www.contoso.com/ URI。  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定将通讯协议方案同 URI 的地址部分分开的字符。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建一个由字符串<xref:System.Uri.UriSchemeHttp>， <xref:System.Uri.SchemeDelimiter>，和地址。 一个<xref:System.Uri>然后从字符串创建实例。  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含构成指定 URI 的路径段的数组。</summary>
        <value>一个 <see cref="T:System.String" /> 数组，包含构成指定 URI 的路径段。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A>属性返回包含"段"（子字符串） 构成的 URI 的绝对路径的字符串数组。 第一个段被通过分析从其第一个字符的绝对路径，直到达到斜杠 （/） 或路径的末尾。 每增加一个段后前一段开始于第一个字符下, 一步斜杠或路径的末尾终止。 （一个 URI 的绝对路径包含的所有内容之后的主机和端口和之前的查询和片段。）  
  
 下面的示例显示两个 Uri 的绝对路径和段。 第二个示例说明了，片段和查询不是绝对路径的一部分，因而不是段。  
  
 绝对 URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 绝对路径：  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 段：  
 - /
 - 章节 /
 - 第 1 章 /
 - 部分 /
 - Section1.htm  
  
 绝对 URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 绝对路径：  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 段：  
 - /
 - 章节 /
 - 第 1 章 /
 - 部分 /
 - Section1.htm  
  
 请注意因为的绝对路径以 / 开头，第一个段包含它和其他任何内容。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例 3 段，并在屏幕上显示的段。  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">一个 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象包含序列化 <see cref="T:System.Uri" /> 所需的信息。</param>
        <param name="streamingContext">一个 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象包含与<see cref="T:System.Uri" /> 关联的序列化流的源和目标。</param>
        <summary>返回序列化当前实例所需的数据。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用序列化方法。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取指定的 <see cref="T:System.Uri" /> 实例的规范化字符串表示形式。</summary>
        <returns>一个 <see cref="T:System.String" /> 实例，它包含 <see cref="T:System.Uri" /> 实例的非转义规范化表示形式。 除了 #、? 和 %，所有字符均为非转义字符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 端口是方案的默认端口时，此方法返回的字符串不包含端口的信息。  
  
> [!NOTE]
>  返回的字符串<xref:System.Uri.ToString%2A>方法可能包含控制字符，可能会损坏的控制台应用程序的状态。 可以使用<xref:System.Uri.GetComponents%2A>方法替换<xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType>格式从返回的字符串中删除的控制字符。  
  
   
  
## Examples  
 下面的示例创建一个新<xref:System.Uri>从字符串的实例。 它阐释了如何从返回的值之间的差异<xref:System.Uri.OriginalString%2A>，它返回传递的字符串到构造函数中，并通过调用<xref:System.Uri.ToString%2A>，它返回字符串的规范格式。  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要防止部分受信任的代码派生自<see cref="T:System.Uri" />。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新的 <see cref="T:System.Uri" />。 在无法创建 <see cref="T:System.Uri" /> 时不引发异常。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">表示 <see cref="T:System.String" /> 的 <see cref="T:System.Uri" />。</param>
        <param name="uriKind">URI 的类型。</param>
        <param name="result">此方法返回时，包含构造的 <see cref="T:System.Uri" />。</param>
        <summary>使用指定的 <see cref="T:System.Uri" /> 实例和 <see cref="T:System.String" /> 创建一个新的 <see cref="T:System.UriKind" />。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果成功创建了 <see langword="true" />，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回`true`，新<xref:System.Uri>处于`result`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 <see cref="T:System.Uri" />。</param>
        <param name="relativeUri">要添加到基 <see cref="T:System.Uri" /> 的相对 <see cref="T:System.String" />（表示为 <see cref="T:System.Uri" />）。</param>
        <param name="result">此方法返回时，包含根据 <c>baseUri</c> 和 <c>relativeUri</c> 构造的 <see cref="T:System.Uri" />。 此参数未经初始化即被传递。</param>
        <summary>使用指定基和相对 <see cref="T:System.Uri" /> 实例创建一个新的 <see cref="T:System.String" />。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果成功创建了 <see langword="true" />，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回`true`，新<xref:System.Uri>处于`result`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">基 <see cref="T:System.Uri" />。</param>
        <param name="relativeUri">要添加到基 <see cref="T:System.Uri" /> 的相对 <see cref="T:System.Uri" />。</param>
        <param name="result">此方法返回时，包含根据 <c>baseUri</c> 和 <c>relativeUri</c> 构造的 <see cref="T:System.Uri" />。 此参数未经初始化即被传递。</param>
        <summary>使用指定基和相对 <see cref="T:System.Uri" /> 实例创建一个新的 <see cref="T:System.Uri" />。</summary>
        <returns>一个 <see cref="T:System.Boolean" /> 值。如果成功创建了 <see langword="true" />，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法返回`true`，新<xref:System.Uri>处于`result`。  
  
 此方法构造快照的 URI，将其放入规范格式，并对其进行验证。 发生未经处理的异常时，此方法将捕获它。 如果你想要创建<xref:System.Uri>get 异常使用其中一个<xref:System.Uri.%23ctor%2A>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要转换的 <see cref="T:System.String" />。</param>
        <summary>转换指定的字符串，方法是将任何转义序列替换为相应的未转义表示形式。</summary>
        <returns>一个 <see cref="T:System.String" />，包含 <paramref name="path" /> 参数的非转义值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">要恢复原义的字符串。</param>
        <summary>将字符串转换为它的非转义表示形式。</summary>
        <returns>一个 <see cref="T:System.String" />，包含 <paramref name="stringToUnescape" /> 的非转义表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应谨慎使用此方法。 非转义已被以前未转义的字符串可能会导致二义性和错误。  
  
 许多 Web 浏览器到加号转义 Uri 内的空格 （"+"） 字符;但是，UnescapeDataString 方法不会不加上字符组成将转换为空格因为此行为不是标准跨所有 URI 方案。  
  
   
  
## Examples  
 下面的代码示例恢复原义使用 URI，并将任何加号字符 （"+"） 为空格。  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是指向文件的指针。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 1.1 版中，"`file:///path`"URI 已转换成"`file:/path`"。 已为版本 2.0 已更正此问题。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeFile>。  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过文件传输协议 (FTP) 访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeFtp>。  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过 Gopher 协议访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeGopher>。  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过超文本传输协议 (HTTP) 访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeHttp>。  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通过安全超文本传输协议 (HTTPS) 访问 URI。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeHttps>。  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是一个电子邮件地址，需通过简单邮件传输协议 (SMTP) 访问。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeMailto>。  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指明通过 Windows Communication Foundation (WCF) 使用的 NetPipe 方案访问该 URI。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指明通过 Windows Communication Foundation (WCF) 使用的 NetTcp 方案访问该 URI。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是 Internet 新闻组，而且可以通过 Network 新闻传输协议 (NNTP) 进行访问。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeNews>。  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定 URI 是 Internet 新闻组，而且可以通过 Network 新闻传输协议 (NNTP) 进行访问。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NNTP<xref:System.Uri>分析.NET Framework 中的错误版本 1.1 中已经得到更正。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否为方案<xref:System.Uri.UriSchemeNntp>。  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示 URI 字符串在创建 <see cref="T:System.Uri" /> 实例之前已被完全转义。</summary>
        <value>一个 <see cref="T:System.Boolean" /> 值。如果在创建 <see langword="true" /> 实例时 <paramref name="dontEscape" /> 参数设置为 <see langword="true" />，则该值为 <see cref="T:System.Uri" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.UserEscaped%2A>属性设置为`true`以指示使用的字符串来创建<xref:System.Uri>实例已被完全转义之前传递给构造函数; 这就是，则`dontEscape`构造函数调用的参数设置为`true`.  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例，并确定是否它已被完全转义时创建它。  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户名、密码或其他与指定 URI 关联的特定于用户的信息。</summary>
        <value>一个 <see cref="T:System.String" />，包含与该 URI 关联的用户信息。 返回值不包括“@”字符，该字符是一个保留字符，用于分隔 URI 的用户信息部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值通常是中"用户名： 密码"的格式。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Uri>实例并将用户信息输出到控制台。  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此实例代表一个相对 URI，而此属性仅对绝对 URI 有效。</exception>
      </Docs>
    </Member>
  </Members>
</Type>